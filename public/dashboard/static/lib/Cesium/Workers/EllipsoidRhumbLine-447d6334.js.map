{"version":3,"file":"EllipsoidRhumbLine-447d6334.js","sources":["../../../../Source/Core/EllipsoidRhumbLine.js"],"sourcesContent":["import Cartesian3 from \"./Cartesian3.js\";\nimport Cartographic from \"./Cartographic.js\";\nimport Check from \"./Check.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport CesiumMath from \"./Math.js\";\n\nfunction calculateM(ellipticity, major, latitude) {\n  if (ellipticity === 0.0) {\n    // sphere\n    return major * latitude;\n  }\n\n  var e2 = ellipticity * ellipticity;\n  var e4 = e2 * e2;\n  var e6 = e4 * e2;\n  var e8 = e6 * e2;\n  var e10 = e8 * e2;\n  var e12 = e10 * e2;\n  var phi = latitude;\n  var sin2Phi = Math.sin(2 * phi);\n  var sin4Phi = Math.sin(4 * phi);\n  var sin6Phi = Math.sin(6 * phi);\n  var sin8Phi = Math.sin(8 * phi);\n  var sin10Phi = Math.sin(10 * phi);\n  var sin12Phi = Math.sin(12 * phi);\n\n  return (\n    major *\n    ((1 -\n      e2 / 4 -\n      (3 * e4) / 64 -\n      (5 * e6) / 256 -\n      (175 * e8) / 16384 -\n      (441 * e10) / 65536 -\n      (4851 * e12) / 1048576) *\n      phi -\n      ((3 * e2) / 8 +\n        (3 * e4) / 32 +\n        (45 * e6) / 1024 +\n        (105 * e8) / 4096 +\n        (2205 * e10) / 131072 +\n        (6237 * e12) / 524288) *\n        sin2Phi +\n      ((15 * e4) / 256 +\n        (45 * e6) / 1024 +\n        (525 * e8) / 16384 +\n        (1575 * e10) / 65536 +\n        (155925 * e12) / 8388608) *\n        sin4Phi -\n      ((35 * e6) / 3072 +\n        (175 * e8) / 12288 +\n        (3675 * e10) / 262144 +\n        (13475 * e12) / 1048576) *\n        sin6Phi +\n      ((315 * e8) / 131072 + (2205 * e10) / 524288 + (43659 * e12) / 8388608) *\n        sin8Phi -\n      ((693 * e10) / 1310720 + (6237 * e12) / 5242880) * sin10Phi +\n      ((1001 * e12) / 8388608) * sin12Phi)\n  );\n}\n\nfunction calculateInverseM(M, ellipticity, major) {\n  var d = M / major;\n\n  if (ellipticity === 0.0) {\n    // sphere\n    return d;\n  }\n\n  var d2 = d * d;\n  var d3 = d2 * d;\n  var d4 = d3 * d;\n  var e = ellipticity;\n  var e2 = e * e;\n  var e4 = e2 * e2;\n  var e6 = e4 * e2;\n  var e8 = e6 * e2;\n  var e10 = e8 * e2;\n  var e12 = e10 * e2;\n  var sin2D = Math.sin(2 * d);\n  var cos2D = Math.cos(2 * d);\n  var sin4D = Math.sin(4 * d);\n  var cos4D = Math.cos(4 * d);\n  var sin6D = Math.sin(6 * d);\n  var cos6D = Math.cos(6 * d);\n  var sin8D = Math.sin(8 * d);\n  var cos8D = Math.cos(8 * d);\n  var sin10D = Math.sin(10 * d);\n  var cos10D = Math.cos(10 * d);\n  var sin12D = Math.sin(12 * d);\n\n  return (\n    d +\n    (d * e2) / 4 +\n    (7 * d * e4) / 64 +\n    (15 * d * e6) / 256 +\n    (579 * d * e8) / 16384 +\n    (1515 * d * e10) / 65536 +\n    (16837 * d * e12) / 1048576 +\n    ((3 * d * e4) / 16 +\n      (45 * d * e6) / 256 -\n      (d * (32 * d2 - 561) * e8) / 4096 -\n      (d * (232 * d2 - 1677) * e10) / 16384 +\n      (d * (399985 - 90560 * d2 + 512 * d4) * e12) / 5242880) *\n      cos2D +\n    ((21 * d * e6) / 256 +\n      (483 * d * e8) / 4096 -\n      (d * (224 * d2 - 1969) * e10) / 16384 -\n      (d * (33152 * d2 - 112599) * e12) / 1048576) *\n      cos4D +\n    ((151 * d * e8) / 4096 +\n      (4681 * d * e10) / 65536 +\n      (1479 * d * e12) / 16384 -\n      (453 * d3 * e12) / 32768) *\n      cos6D +\n    ((1097 * d * e10) / 65536 + (42783 * d * e12) / 1048576) * cos8D +\n    ((8011 * d * e12) / 1048576) * cos10D +\n    ((3 * e2) / 8 +\n      (3 * e4) / 16 +\n      (213 * e6) / 2048 -\n      (3 * d2 * e6) / 64 +\n      (255 * e8) / 4096 -\n      (33 * d2 * e8) / 512 +\n      (20861 * e10) / 524288 -\n      (33 * d2 * e10) / 512 +\n      (d4 * e10) / 1024 +\n      (28273 * e12) / 1048576 -\n      (471 * d2 * e12) / 8192 +\n      (9 * d4 * e12) / 4096) *\n      sin2D +\n    ((21 * e4) / 256 +\n      (21 * e6) / 256 +\n      (533 * e8) / 8192 -\n      (21 * d2 * e8) / 512 +\n      (197 * e10) / 4096 -\n      (315 * d2 * e10) / 4096 +\n      (584039 * e12) / 16777216 -\n      (12517 * d2 * e12) / 131072 +\n      (7 * d4 * e12) / 2048) *\n      sin4D +\n    ((151 * e6) / 6144 +\n      (151 * e8) / 4096 +\n      (5019 * e10) / 131072 -\n      (453 * d2 * e10) / 16384 +\n      (26965 * e12) / 786432 -\n      (8607 * d2 * e12) / 131072) *\n      sin6D +\n    ((1097 * e8) / 131072 +\n      (1097 * e10) / 65536 +\n      (225797 * e12) / 10485760 -\n      (1097 * d2 * e12) / 65536) *\n      sin8D +\n    ((8011 * e10) / 2621440 + (8011 * e12) / 1048576) * sin10D +\n    ((293393 * e12) / 251658240) * sin12D\n  );\n}\n\nfunction calculateSigma(ellipticity, latitude) {\n  if (ellipticity === 0.0) {\n    // sphere\n    return Math.log(Math.tan(0.5 * (CesiumMath.PI_OVER_TWO + latitude)));\n  }\n\n  var eSinL = ellipticity * Math.sin(latitude);\n  return (\n    Math.log(Math.tan(0.5 * (CesiumMath.PI_OVER_TWO + latitude))) -\n    (ellipticity / 2.0) * Math.log((1 + eSinL) / (1 - eSinL))\n  );\n}\n\nfunction calculateHeading(\n  ellipsoidRhumbLine,\n  firstLongitude,\n  firstLatitude,\n  secondLongitude,\n  secondLatitude\n) {\n  var sigma1 = calculateSigma(ellipsoidRhumbLine._ellipticity, firstLatitude);\n  var sigma2 = calculateSigma(ellipsoidRhumbLine._ellipticity, secondLatitude);\n  return Math.atan2(\n    CesiumMath.negativePiToPi(secondLongitude - firstLongitude),\n    sigma2 - sigma1\n  );\n}\n\nfunction calculateArcLength(\n  ellipsoidRhumbLine,\n  major,\n  minor,\n  firstLongitude,\n  firstLatitude,\n  secondLongitude,\n  secondLatitude\n) {\n  var heading = ellipsoidRhumbLine._heading;\n  var deltaLongitude = secondLongitude - firstLongitude;\n\n  var distance = 0.0;\n\n  //Check to see if the rhumb line has constant latitude\n  //This equation will diverge if heading gets close to 90 degrees\n  if (\n    CesiumMath.equalsEpsilon(\n      Math.abs(heading),\n      CesiumMath.PI_OVER_TWO,\n      CesiumMath.EPSILON8\n    )\n  ) {\n    //If heading is close to 90 degrees\n    if (major === minor) {\n      distance =\n        major *\n        Math.cos(firstLatitude) *\n        CesiumMath.negativePiToPi(deltaLongitude);\n    } else {\n      var sinPhi = Math.sin(firstLatitude);\n      distance =\n        (major *\n          Math.cos(firstLatitude) *\n          CesiumMath.negativePiToPi(deltaLongitude)) /\n        Math.sqrt(1 - ellipsoidRhumbLine._ellipticitySquared * sinPhi * sinPhi);\n    }\n  } else {\n    var M1 = calculateM(ellipsoidRhumbLine._ellipticity, major, firstLatitude);\n    var M2 = calculateM(ellipsoidRhumbLine._ellipticity, major, secondLatitude);\n\n    distance = (M2 - M1) / Math.cos(heading);\n  }\n  return Math.abs(distance);\n}\n\nvar scratchCart1 = new Cartesian3();\nvar scratchCart2 = new Cartesian3();\n\nfunction computeProperties(ellipsoidRhumbLine, start, end, ellipsoid) {\n  var firstCartesian = Cartesian3.normalize(\n    ellipsoid.cartographicToCartesian(start, scratchCart2),\n    scratchCart1\n  );\n  var lastCartesian = Cartesian3.normalize(\n    ellipsoid.cartographicToCartesian(end, scratchCart2),\n    scratchCart2\n  );\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number.greaterThanOrEquals(\n    \"value\",\n    Math.abs(\n      Math.abs(Cartesian3.angleBetween(firstCartesian, lastCartesian)) - Math.PI\n    ),\n    0.0125\n  );\n  //>>includeEnd('debug');\n\n  var major = ellipsoid.maximumRadius;\n  var minor = ellipsoid.minimumRadius;\n  var majorSquared = major * major;\n  var minorSquared = minor * minor;\n  ellipsoidRhumbLine._ellipticitySquared =\n    (majorSquared - minorSquared) / majorSquared;\n  ellipsoidRhumbLine._ellipticity = Math.sqrt(\n    ellipsoidRhumbLine._ellipticitySquared\n  );\n\n  ellipsoidRhumbLine._start = Cartographic.clone(\n    start,\n    ellipsoidRhumbLine._start\n  );\n  ellipsoidRhumbLine._start.height = 0;\n\n  ellipsoidRhumbLine._end = Cartographic.clone(end, ellipsoidRhumbLine._end);\n  ellipsoidRhumbLine._end.height = 0;\n\n  ellipsoidRhumbLine._heading = calculateHeading(\n    ellipsoidRhumbLine,\n    start.longitude,\n    start.latitude,\n    end.longitude,\n    end.latitude\n  );\n  ellipsoidRhumbLine._distance = calculateArcLength(\n    ellipsoidRhumbLine,\n    ellipsoid.maximumRadius,\n    ellipsoid.minimumRadius,\n    start.longitude,\n    start.latitude,\n    end.longitude,\n    end.latitude\n  );\n}\n\nfunction interpolateUsingSurfaceDistance(\n  start,\n  heading,\n  distance,\n  major,\n  ellipticity,\n  result\n) {\n  if (distance === 0.0) {\n    return Cartographic.clone(start, result);\n  }\n\n  var ellipticitySquared = ellipticity * ellipticity;\n\n  var longitude;\n  var latitude;\n  var deltaLongitude;\n\n  //Check to see if the rhumb line has constant latitude\n  //This won't converge if heading is close to 90 degrees\n  if (\n    Math.abs(CesiumMath.PI_OVER_TWO - Math.abs(heading)) > CesiumMath.EPSILON8\n  ) {\n    //Calculate latitude of the second point\n    var M1 = calculateM(ellipticity, major, start.latitude);\n    var deltaM = distance * Math.cos(heading);\n    var M2 = M1 + deltaM;\n    latitude = calculateInverseM(M2, ellipticity, major);\n\n    //Now find the longitude of the second point\n    var sigma1 = calculateSigma(ellipticity, start.latitude);\n    var sigma2 = calculateSigma(ellipticity, latitude);\n    deltaLongitude = Math.tan(heading) * (sigma2 - sigma1);\n    longitude = CesiumMath.negativePiToPi(start.longitude + deltaLongitude);\n  } else {\n    //If heading is close to 90 degrees\n    latitude = start.latitude;\n    var localRad;\n\n    if (ellipticity === 0.0) {\n      // sphere\n      localRad = major * Math.cos(start.latitude);\n    } else {\n      var sinPhi = Math.sin(start.latitude);\n      localRad =\n        (major * Math.cos(start.latitude)) /\n        Math.sqrt(1 - ellipticitySquared * sinPhi * sinPhi);\n    }\n\n    deltaLongitude = distance / localRad;\n    if (heading > 0.0) {\n      longitude = CesiumMath.negativePiToPi(start.longitude + deltaLongitude);\n    } else {\n      longitude = CesiumMath.negativePiToPi(start.longitude - deltaLongitude);\n    }\n  }\n\n  if (defined(result)) {\n    result.longitude = longitude;\n    result.latitude = latitude;\n    result.height = 0;\n\n    return result;\n  }\n\n  return new Cartographic(longitude, latitude, 0);\n}\n\n/**\n * Initializes a rhumb line on the ellipsoid connecting the two provided planetodetic points.\n *\n * @alias EllipsoidRhumbLine\n * @constructor\n *\n * @param {Cartographic} [start] The initial planetodetic point on the path.\n * @param {Cartographic} [end] The final planetodetic point on the path.\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the rhumb line lies.\n *\n * @exception {DeveloperError} angle between start and end must be at least 0.0125 radians.\n */\nfunction EllipsoidRhumbLine(start, end, ellipsoid) {\n  var e = defaultValue(ellipsoid, Ellipsoid.WGS84);\n  this._ellipsoid = e;\n  this._start = new Cartographic();\n  this._end = new Cartographic();\n\n  this._heading = undefined;\n  this._distance = undefined;\n  this._ellipticity = undefined;\n  this._ellipticitySquared = undefined;\n\n  if (defined(start) && defined(end)) {\n    computeProperties(this, start, end, e);\n  }\n}\n\nObject.defineProperties(EllipsoidRhumbLine.prototype, {\n  /**\n   * Gets the ellipsoid.\n   * @memberof EllipsoidRhumbLine.prototype\n   * @type {Ellipsoid}\n   * @readonly\n   */\n  ellipsoid: {\n    get: function () {\n      return this._ellipsoid;\n    },\n  },\n\n  /**\n   * Gets the surface distance between the start and end point\n   * @memberof EllipsoidRhumbLine.prototype\n   * @type {Number}\n   * @readonly\n   */\n  surfaceDistance: {\n    get: function () {\n      //>>includeStart('debug', pragmas.debug);\n      Check.defined(\"distance\", this._distance);\n      //>>includeEnd('debug');\n\n      return this._distance;\n    },\n  },\n\n  /**\n   * Gets the initial planetodetic point on the path.\n   * @memberof EllipsoidRhumbLine.prototype\n   * @type {Cartographic}\n   * @readonly\n   */\n  start: {\n    get: function () {\n      return this._start;\n    },\n  },\n\n  /**\n   * Gets the final planetodetic point on the path.\n   * @memberof EllipsoidRhumbLine.prototype\n   * @type {Cartographic}\n   * @readonly\n   */\n  end: {\n    get: function () {\n      return this._end;\n    },\n  },\n\n  /**\n   * Gets the heading from the start point to the end point.\n   * @memberof EllipsoidRhumbLine.prototype\n   * @type {Number}\n   * @readonly\n   */\n  heading: {\n    get: function () {\n      //>>includeStart('debug', pragmas.debug);\n      Check.defined(\"distance\", this._distance);\n      //>>includeEnd('debug');\n\n      return this._heading;\n    },\n  },\n});\n\n/**\n * Create a rhumb line using an initial position with a heading and distance.\n *\n * @param {Cartographic} start The initial planetodetic point on the path.\n * @param {Number} heading The heading in radians.\n * @param {Number} distance The rhumb line distance between the start and end point.\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the rhumb line lies.\n * @param {EllipsoidRhumbLine} [result] The object in which to store the result.\n * @returns {EllipsoidRhumbLine} The EllipsoidRhumbLine object.\n */\nEllipsoidRhumbLine.fromStartHeadingDistance = function (\n  start,\n  heading,\n  distance,\n  ellipsoid,\n  result\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"start\", start);\n  Check.defined(\"heading\", heading);\n  Check.defined(\"distance\", distance);\n  Check.typeOf.number.greaterThan(\"distance\", distance, 0.0);\n  //>>includeEnd('debug');\n\n  var e = defaultValue(ellipsoid, Ellipsoid.WGS84);\n  var major = e.maximumRadius;\n  var minor = e.minimumRadius;\n  var majorSquared = major * major;\n  var minorSquared = minor * minor;\n  var ellipticity = Math.sqrt((majorSquared - minorSquared) / majorSquared);\n\n  heading = CesiumMath.negativePiToPi(heading);\n  var end = interpolateUsingSurfaceDistance(\n    start,\n    heading,\n    distance,\n    e.maximumRadius,\n    ellipticity\n  );\n\n  if (\n    !defined(result) ||\n    (defined(ellipsoid) && !ellipsoid.equals(result.ellipsoid))\n  ) {\n    return new EllipsoidRhumbLine(start, end, e);\n  }\n\n  result.setEndPoints(start, end);\n  return result;\n};\n\n/**\n * Sets the start and end points of the rhumb line.\n *\n * @param {Cartographic} start The initial planetodetic point on the path.\n * @param {Cartographic} end The final planetodetic point on the path.\n */\nEllipsoidRhumbLine.prototype.setEndPoints = function (start, end) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"start\", start);\n  Check.defined(\"end\", end);\n  //>>includeEnd('debug');\n\n  computeProperties(this, start, end, this._ellipsoid);\n};\n\n/**\n * Provides the location of a point at the indicated portion along the rhumb line.\n *\n * @param {Number} fraction The portion of the distance between the initial and final points.\n * @param {Cartographic} [result] The object in which to store the result.\n * @returns {Cartographic} The location of the point along the rhumb line.\n */\nEllipsoidRhumbLine.prototype.interpolateUsingFraction = function (\n  fraction,\n  result\n) {\n  return this.interpolateUsingSurfaceDistance(\n    fraction * this._distance,\n    result\n  );\n};\n\n/**\n * Provides the location of a point at the indicated distance along the rhumb line.\n *\n * @param {Number} distance The distance from the inital point to the point of interest along the rhumbLine.\n * @param {Cartographic} [result] The object in which to store the result.\n * @returns {Cartographic} The location of the point along the rhumb line.\n *\n * @exception {DeveloperError} start and end must be set before calling function interpolateUsingSurfaceDistance\n */\nEllipsoidRhumbLine.prototype.interpolateUsingSurfaceDistance = function (\n  distance,\n  result\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"distance\", distance);\n  if (!defined(this._distance) || this._distance === 0.0) {\n    throw new DeveloperError(\n      \"EllipsoidRhumbLine must have distinct start and end set.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  return interpolateUsingSurfaceDistance(\n    this._start,\n    this._heading,\n    distance,\n    this._ellipsoid.maximumRadius,\n    this._ellipticity,\n    result\n  );\n};\n\n/**\n * Provides the location of a point at the indicated longitude along the rhumb line.\n * If the longitude is outside the range of start and end points, the first intersection with the longitude from the start point in the direction of the heading is returned. This follows the spiral property of a rhumb line.\n *\n * @param {Number} intersectionLongitude The longitude, in radians, at which to find the intersection point from the starting point using the heading.\n * @param {Cartographic} [result] The object in which to store the result.\n * @returns {Cartographic} The location of the intersection point along the rhumb line, undefined if there is no intersection or infinite intersections.\n *\n * @exception {DeveloperError} start and end must be set before calling function findIntersectionWithLongitude.\n */\nEllipsoidRhumbLine.prototype.findIntersectionWithLongitude = function (\n  intersectionLongitude,\n  result\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"intersectionLongitude\", intersectionLongitude);\n  if (!defined(this._distance) || this._distance === 0.0) {\n    throw new DeveloperError(\n      \"EllipsoidRhumbLine must have distinct start and end set.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  var ellipticity = this._ellipticity;\n  var heading = this._heading;\n  var absHeading = Math.abs(heading);\n  var start = this._start;\n\n  intersectionLongitude = CesiumMath.negativePiToPi(intersectionLongitude);\n\n  if (\n    CesiumMath.equalsEpsilon(\n      Math.abs(intersectionLongitude),\n      Math.PI,\n      CesiumMath.EPSILON14\n    )\n  ) {\n    intersectionLongitude = CesiumMath.sign(start.longitude) * Math.PI;\n  }\n\n  if (!defined(result)) {\n    result = new Cartographic();\n  }\n\n  // If heading is -PI/2 or PI/2, this is an E-W rhumb line\n  // If heading is 0 or PI, this is an N-S rhumb line\n  if (Math.abs(CesiumMath.PI_OVER_TWO - absHeading) <= CesiumMath.EPSILON8) {\n    result.longitude = intersectionLongitude;\n    result.latitude = start.latitude;\n    result.height = 0;\n    return result;\n  } else if (\n    CesiumMath.equalsEpsilon(\n      Math.abs(CesiumMath.PI_OVER_TWO - absHeading),\n      CesiumMath.PI_OVER_TWO,\n      CesiumMath.EPSILON8\n    )\n  ) {\n    if (\n      CesiumMath.equalsEpsilon(\n        intersectionLongitude,\n        start.longitude,\n        CesiumMath.EPSILON12\n      )\n    ) {\n      return undefined;\n    }\n\n    result.longitude = intersectionLongitude;\n    result.latitude =\n      CesiumMath.PI_OVER_TWO *\n      CesiumMath.sign(CesiumMath.PI_OVER_TWO - heading);\n    result.height = 0;\n    return result;\n  }\n\n  // Use iterative solver from Equation 9 from http://edwilliams.org/ellipsoid/ellipsoid.pdf\n  var phi1 = start.latitude;\n  var eSinPhi1 = ellipticity * Math.sin(phi1);\n  var leftComponent =\n    Math.tan(0.5 * (CesiumMath.PI_OVER_TWO + phi1)) *\n    Math.exp((intersectionLongitude - start.longitude) / Math.tan(heading));\n  var denominator = (1 + eSinPhi1) / (1 - eSinPhi1);\n\n  var newPhi = start.latitude;\n  var phi;\n  do {\n    phi = newPhi;\n    var eSinPhi = ellipticity * Math.sin(phi);\n    var numerator = (1 + eSinPhi) / (1 - eSinPhi);\n    newPhi =\n      2 *\n        Math.atan(\n          leftComponent * Math.pow(numerator / denominator, ellipticity / 2)\n        ) -\n      CesiumMath.PI_OVER_TWO;\n  } while (!CesiumMath.equalsEpsilon(newPhi, phi, CesiumMath.EPSILON12));\n\n  result.longitude = intersectionLongitude;\n  result.latitude = newPhi;\n  result.height = 0;\n  return result;\n};\n\n/**\n * Provides the location of a point at the indicated latitude along the rhumb line.\n * If the latitude is outside the range of start and end points, the first intersection with the latitude from that start point in the direction of the heading is returned. This follows the spiral property of a rhumb line.\n *\n * @param {Number} intersectionLatitude The latitude, in radians, at which to find the intersection point from the starting point using the heading.\n * @param {Cartographic} [result] The object in which to store the result.\n * @returns {Cartographic} The location of the intersection point along the rhumb line, undefined if there is no intersection or infinite intersections.\n *\n * @exception {DeveloperError} start and end must be set before calling function findIntersectionWithLongitude.\n */\nEllipsoidRhumbLine.prototype.findIntersectionWithLatitude = function (\n  intersectionLatitude,\n  result\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"intersectionLatitude\", intersectionLatitude);\n  if (!defined(this._distance) || this._distance === 0.0) {\n    throw new DeveloperError(\n      \"EllipsoidRhumbLine must have distinct start and end set.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  var ellipticity = this._ellipticity;\n  var heading = this._heading;\n  var start = this._start;\n\n  // If start and end have same latitude, return undefined since it's either no intersection or infinite intersections\n  if (\n    CesiumMath.equalsEpsilon(\n      Math.abs(heading),\n      CesiumMath.PI_OVER_TWO,\n      CesiumMath.EPSILON8\n    )\n  ) {\n    return;\n  }\n\n  // Can be solved using the same equations from interpolateUsingSurfaceDistance\n  var sigma1 = calculateSigma(ellipticity, start.latitude);\n  var sigma2 = calculateSigma(ellipticity, intersectionLatitude);\n  var deltaLongitude = Math.tan(heading) * (sigma2 - sigma1);\n  var longitude = CesiumMath.negativePiToPi(start.longitude + deltaLongitude);\n\n  if (defined(result)) {\n    result.longitude = longitude;\n    result.latitude = intersectionLatitude;\n    result.height = 0;\n\n    return result;\n  }\n\n  return new Cartographic(longitude, intersectionLatitude, 0);\n};\nexport default EllipsoidRhumbLine;\n"],"names":["calculateM","ellipticity","major","latitude","e2","e4","e6","e8","e10","e12","phi","Math","sin","calculateSigma","log","tan","CesiumMath","PI_OVER_TWO","eSinL","scratchCart1","Cartesian3","scratchCart2","computeProperties","ellipsoidRhumbLine","start","end","ellipsoid","firstCartesian","normalize","cartographicToCartesian","lastCartesian","Check","typeOf","number","greaterThanOrEquals","abs","angleBetween","PI","maximumRadius","minor","minimumRadius","majorSquared","minorSquared","_ellipticitySquared","_ellipticity","sqrt","_start","Cartographic","clone","height","_end","_heading","firstLongitude","firstLatitude","secondLongitude","secondLatitude","sigma1","sigma2","atan2","negativePiToPi","calculateHeading","longitude","_distance","heading","deltaLongitude","distance","equalsEpsilon","EPSILON8","cos","sinPhi","M1","calculateArcLength","interpolateUsingSurfaceDistance","result","ellipticitySquared","M","d","d2","d3","d4","sin2D","cos2D","sin4D","cos4D","sin6D","cos6D","sin8D","cos8D","sin10D","calculateInverseM","localRad","defined","EllipsoidRhumbLine","e","defaultValue","Ellipsoid","WGS84","this","_ellipsoid","undefined","Object","defineProperties","prototype","get","surfaceDistance","fromStartHeadingDistance","greaterThan","equals","setEndPoints","interpolateUsingFraction","fraction","DeveloperError","findIntersectionWithLongitude","intersectionLongitude","absHeading","EPSILON14","sign","EPSILON12","phi1","eSinPhi1","leftComponent","exp","denominator","newPhi","eSinPhi","numerator","atan","pow","findIntersectionWithLatitude","intersectionLatitude"],"mappings":"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"}