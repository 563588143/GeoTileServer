{"version":3,"file":"createVectorTileClampedPolylines.js","sources":["../../../../Source/WorkersES6/createVectorTileClampedPolylines.js"],"sourcesContent":["import AttributeCompression from \"../Core/AttributeCompression.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartographic from \"../Core/Cartographic.js\";\nimport combine from \"../Core/combine.js\";\nimport Ellipsoid from \"../Core/Ellipsoid.js\";\nimport IndexDatatype from \"../Core/IndexDatatype.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport Rectangle from \"../Core/Rectangle.js\";\nimport createTaskProcessorWorker from \"./createTaskProcessorWorker.js\";\n\nvar MAX_SHORT = 32767;\nvar MITER_BREAK = Math.cos(CesiumMath.toRadians(150.0));\n\nvar scratchBVCartographic = new Cartographic();\nvar scratchEncodedPosition = new Cartesian3();\n\nfunction decodePositions(\n  uBuffer,\n  vBuffer,\n  heightBuffer,\n  rectangle,\n  minimumHeight,\n  maximumHeight,\n  ellipsoid\n) {\n  var positionsLength = uBuffer.length;\n  var decodedPositions = new Float64Array(positionsLength * 3);\n  for (var i = 0; i < positionsLength; ++i) {\n    var u = uBuffer[i];\n    var v = vBuffer[i];\n    var h = heightBuffer[i];\n\n    var lon = CesiumMath.lerp(rectangle.west, rectangle.east, u / MAX_SHORT);\n    var lat = CesiumMath.lerp(rectangle.south, rectangle.north, v / MAX_SHORT);\n    var alt = CesiumMath.lerp(minimumHeight, maximumHeight, h / MAX_SHORT);\n\n    var cartographic = Cartographic.fromRadians(\n      lon,\n      lat,\n      alt,\n      scratchBVCartographic\n    );\n    var decodedPosition = ellipsoid.cartographicToCartesian(\n      cartographic,\n      scratchEncodedPosition\n    );\n    Cartesian3.pack(decodedPosition, decodedPositions, i * 3);\n  }\n  return decodedPositions;\n}\n\nfunction getPositionOffsets(counts) {\n  var countsLength = counts.length;\n  var positionOffsets = new Uint32Array(countsLength + 1);\n  var offset = 0;\n  for (var i = 0; i < countsLength; ++i) {\n    positionOffsets[i] = offset;\n    offset += counts[i];\n  }\n  positionOffsets[countsLength] = offset;\n  return positionOffsets;\n}\n\nvar previousCompressedCartographicScratch = new Cartographic();\nvar currentCompressedCartographicScratch = new Cartographic();\nfunction removeDuplicates(uBuffer, vBuffer, heightBuffer, counts) {\n  var countsLength = counts.length;\n  var positionsLength = uBuffer.length;\n  var markRemoval = new Uint8Array(positionsLength);\n  var previous = previousCompressedCartographicScratch;\n  var current = currentCompressedCartographicScratch;\n  var offset = 0;\n  for (var i = 0; i < countsLength; i++) {\n    var count = counts[i];\n    var updatedCount = count;\n    for (var j = 1; j < count; j++) {\n      var index = offset + j;\n      var previousIndex = index - 1;\n      current.longitude = uBuffer[index];\n      current.latitude = vBuffer[index];\n      previous.longitude = uBuffer[previousIndex];\n      previous.latitude = vBuffer[previousIndex];\n\n      if (Cartographic.equals(current, previous)) {\n        updatedCount--;\n        markRemoval[previousIndex] = 1;\n      }\n    }\n    counts[i] = updatedCount;\n    offset += count;\n  }\n\n  var nextAvailableIndex = 0;\n  for (var k = 0; k < positionsLength; k++) {\n    if (markRemoval[k] !== 1) {\n      uBuffer[nextAvailableIndex] = uBuffer[k];\n      vBuffer[nextAvailableIndex] = vBuffer[k];\n      heightBuffer[nextAvailableIndex] = heightBuffer[k];\n      nextAvailableIndex++;\n    }\n  }\n}\n\nfunction VertexAttributesAndIndices(volumesCount) {\n  var vertexCount = volumesCount * 8;\n  var vec3Floats = vertexCount * 3;\n  var vec4Floats = vertexCount * 4;\n  this.startEllipsoidNormals = new Float32Array(vec3Floats);\n  this.endEllipsoidNormals = new Float32Array(vec3Floats);\n  this.startPositionAndHeights = new Float32Array(vec4Floats);\n  this.startFaceNormalAndVertexCornerIds = new Float32Array(vec4Floats);\n  this.endPositionAndHeights = new Float32Array(vec4Floats);\n  this.endFaceNormalAndHalfWidths = new Float32Array(vec4Floats);\n  this.vertexBatchIds = new Uint16Array(vertexCount);\n\n  this.indices = IndexDatatype.createTypedArray(vertexCount, 36 * volumesCount);\n\n  this.vec3Offset = 0;\n  this.vec4Offset = 0;\n  this.batchIdOffset = 0;\n  this.indexOffset = 0;\n\n  this.volumeStartIndex = 0;\n}\n\nvar towardCurrScratch = new Cartesian3();\nvar towardNextScratch = new Cartesian3();\nfunction computeMiteredNormal(\n  previousPosition,\n  position,\n  nextPosition,\n  ellipsoidSurfaceNormal,\n  result\n) {\n  var towardNext = Cartesian3.subtract(\n    nextPosition,\n    position,\n    towardNextScratch\n  );\n  var towardCurr = Cartesian3.subtract(\n    position,\n    previousPosition,\n    towardCurrScratch\n  );\n  Cartesian3.normalize(towardNext, towardNext);\n  Cartesian3.normalize(towardCurr, towardCurr);\n\n  if (Cartesian3.dot(towardNext, towardCurr) < MITER_BREAK) {\n    towardCurr = Cartesian3.multiplyByScalar(\n      towardCurr,\n      -1.0,\n      towardCurrScratch\n    );\n  }\n\n  Cartesian3.add(towardNext, towardCurr, result);\n  if (Cartesian3.equals(result, Cartesian3.ZERO)) {\n    result = Cartesian3.subtract(previousPosition, position);\n  }\n\n  // Make sure the normal is orthogonal to the ellipsoid surface normal\n  Cartesian3.cross(result, ellipsoidSurfaceNormal, result);\n  Cartesian3.cross(ellipsoidSurfaceNormal, result, result);\n  Cartesian3.normalize(result, result);\n  return result;\n}\n\n// Winding order is reversed so each segment's volume is inside-out\n//          3-----------7\n//         /|   left   /|\n//        / | 1       / |\n//       2-----------6  5  end\n//       | /         | /\n// start |/  right   |/\n//       0-----------4\n//\nvar REFERENCE_INDICES = [\n  0,\n  2,\n  6,\n  0,\n  6,\n  4, // right\n  0,\n  1,\n  3,\n  0,\n  3,\n  2, // start face\n  0,\n  4,\n  5,\n  0,\n  5,\n  1, // bottom\n  5,\n  3,\n  1,\n  5,\n  7,\n  3, // left\n  7,\n  5,\n  4,\n  7,\n  4,\n  6, // end face\n  7,\n  6,\n  2,\n  7,\n  2,\n  3, // top\n];\nvar REFERENCE_INDICES_LENGTH = REFERENCE_INDICES.length;\n\nvar positionScratch = new Cartesian3();\nvar scratchStartEllipsoidNormal = new Cartesian3();\nvar scratchStartFaceNormal = new Cartesian3();\nvar scratchEndEllipsoidNormal = new Cartesian3();\nvar scratchEndFaceNormal = new Cartesian3();\nVertexAttributesAndIndices.prototype.addVolume = function (\n  preStartRTC,\n  startRTC,\n  endRTC,\n  postEndRTC,\n  startHeight,\n  endHeight,\n  halfWidth,\n  batchId,\n  center,\n  ellipsoid\n) {\n  var position = Cartesian3.add(startRTC, center, positionScratch);\n  var startEllipsoidNormal = ellipsoid.geodeticSurfaceNormal(\n    position,\n    scratchStartEllipsoidNormal\n  );\n  position = Cartesian3.add(endRTC, center, positionScratch);\n  var endEllipsoidNormal = ellipsoid.geodeticSurfaceNormal(\n    position,\n    scratchEndEllipsoidNormal\n  );\n\n  var startFaceNormal = computeMiteredNormal(\n    preStartRTC,\n    startRTC,\n    endRTC,\n    startEllipsoidNormal,\n    scratchStartFaceNormal\n  );\n  var endFaceNormal = computeMiteredNormal(\n    postEndRTC,\n    endRTC,\n    startRTC,\n    endEllipsoidNormal,\n    scratchEndFaceNormal\n  );\n\n  var startEllipsoidNormals = this.startEllipsoidNormals;\n  var endEllipsoidNormals = this.endEllipsoidNormals;\n  var startPositionAndHeights = this.startPositionAndHeights;\n  var startFaceNormalAndVertexCornerIds = this\n    .startFaceNormalAndVertexCornerIds;\n  var endPositionAndHeights = this.endPositionAndHeights;\n  var endFaceNormalAndHalfWidths = this.endFaceNormalAndHalfWidths;\n  var vertexBatchIds = this.vertexBatchIds;\n\n  var batchIdOffset = this.batchIdOffset;\n  var vec3Offset = this.vec3Offset;\n  var vec4Offset = this.vec4Offset;\n\n  var i;\n  for (i = 0; i < 8; i++) {\n    Cartesian3.pack(startEllipsoidNormal, startEllipsoidNormals, vec3Offset);\n    Cartesian3.pack(endEllipsoidNormal, endEllipsoidNormals, vec3Offset);\n\n    Cartesian3.pack(startRTC, startPositionAndHeights, vec4Offset);\n    startPositionAndHeights[vec4Offset + 3] = startHeight;\n\n    Cartesian3.pack(endRTC, endPositionAndHeights, vec4Offset);\n    endPositionAndHeights[vec4Offset + 3] = endHeight;\n\n    Cartesian3.pack(\n      startFaceNormal,\n      startFaceNormalAndVertexCornerIds,\n      vec4Offset\n    );\n    startFaceNormalAndVertexCornerIds[vec4Offset + 3] = i;\n\n    Cartesian3.pack(endFaceNormal, endFaceNormalAndHalfWidths, vec4Offset);\n    endFaceNormalAndHalfWidths[vec4Offset + 3] = halfWidth;\n\n    vertexBatchIds[batchIdOffset++] = batchId;\n\n    vec3Offset += 3;\n    vec4Offset += 4;\n  }\n\n  this.batchIdOffset = batchIdOffset;\n  this.vec3Offset = vec3Offset;\n  this.vec4Offset = vec4Offset;\n  var indices = this.indices;\n  var volumeStartIndex = this.volumeStartIndex;\n\n  var indexOffset = this.indexOffset;\n  for (i = 0; i < REFERENCE_INDICES_LENGTH; i++) {\n    indices[indexOffset + i] = REFERENCE_INDICES[i] + volumeStartIndex;\n  }\n\n  this.volumeStartIndex += 8;\n  this.indexOffset += REFERENCE_INDICES_LENGTH;\n};\n\nvar scratchRectangle = new Rectangle();\nvar scratchEllipsoid = new Ellipsoid();\nvar scratchCenter = new Cartesian3();\n\nvar scratchPrev = new Cartesian3();\nvar scratchP0 = new Cartesian3();\nvar scratchP1 = new Cartesian3();\nvar scratchNext = new Cartesian3();\nfunction createVectorTileClampedPolylines(parameters, transferableObjects) {\n  var encodedPositions = new Uint16Array(parameters.positions);\n  var widths = new Uint16Array(parameters.widths);\n  var counts = new Uint32Array(parameters.counts);\n  var batchIds = new Uint16Array(parameters.batchIds);\n\n  // Unpack tile decoding parameters\n  var rectangle = scratchRectangle;\n  var ellipsoid = scratchEllipsoid;\n  var center = scratchCenter;\n  var packedBuffer = new Float64Array(parameters.packedBuffer);\n\n  var offset = 0;\n  var minimumHeight = packedBuffer[offset++];\n  var maximumHeight = packedBuffer[offset++];\n\n  Rectangle.unpack(packedBuffer, offset, rectangle);\n  offset += Rectangle.packedLength;\n\n  Ellipsoid.unpack(packedBuffer, offset, ellipsoid);\n  offset += Ellipsoid.packedLength;\n\n  Cartesian3.unpack(packedBuffer, offset, center);\n\n  var i;\n\n  // Unpack positions and generate volumes\n  var positionsLength = encodedPositions.length / 3;\n  var uBuffer = encodedPositions.subarray(0, positionsLength);\n  var vBuffer = encodedPositions.subarray(positionsLength, 2 * positionsLength);\n  var heightBuffer = encodedPositions.subarray(\n    2 * positionsLength,\n    3 * positionsLength\n  );\n  AttributeCompression.zigZagDeltaDecode(uBuffer, vBuffer, heightBuffer);\n\n  removeDuplicates(uBuffer, vBuffer, heightBuffer, counts);\n\n  // Figure out how many volumes and how many vertices there will be.\n  var countsLength = counts.length;\n  var volumesCount = 0;\n  for (i = 0; i < countsLength; i++) {\n    var polylinePositionCount = counts[i];\n    volumesCount += polylinePositionCount - 1;\n  }\n\n  var attribsAndIndices = new VertexAttributesAndIndices(volumesCount);\n\n  var positions = decodePositions(\n    uBuffer,\n    vBuffer,\n    heightBuffer,\n    rectangle,\n    minimumHeight,\n    maximumHeight,\n    ellipsoid,\n    center\n  );\n\n  positionsLength = uBuffer.length;\n  var positionsRTC = new Float32Array(positionsLength * 3);\n  for (i = 0; i < positionsLength; ++i) {\n    positionsRTC[i * 3] = positions[i * 3] - center.x;\n    positionsRTC[i * 3 + 1] = positions[i * 3 + 1] - center.y;\n    positionsRTC[i * 3 + 2] = positions[i * 3 + 2] - center.z;\n  }\n\n  var currentPositionIndex = 0;\n  var currentHeightIndex = 0;\n  for (i = 0; i < countsLength; i++) {\n    var polylineVolumeCount = counts[i] - 1;\n    var halfWidth = widths[i] * 0.5;\n    var batchId = batchIds[i];\n    var volumeFirstPositionIndex = currentPositionIndex;\n    for (var j = 0; j < polylineVolumeCount; j++) {\n      var volumeStart = Cartesian3.unpack(\n        positionsRTC,\n        currentPositionIndex,\n        scratchP0\n      );\n      var volumeEnd = Cartesian3.unpack(\n        positionsRTC,\n        currentPositionIndex + 3,\n        scratchP1\n      );\n\n      var startHeight = heightBuffer[currentHeightIndex];\n      var endHeight = heightBuffer[currentHeightIndex + 1];\n      startHeight = CesiumMath.lerp(\n        minimumHeight,\n        maximumHeight,\n        startHeight / MAX_SHORT\n      );\n      endHeight = CesiumMath.lerp(\n        minimumHeight,\n        maximumHeight,\n        endHeight / MAX_SHORT\n      );\n\n      currentHeightIndex++;\n\n      var preStart = scratchPrev;\n      var postEnd = scratchNext;\n      if (j === 0) {\n        // Check if this volume is like a loop\n        var finalPositionIndex =\n          volumeFirstPositionIndex + polylineVolumeCount * 3;\n        var finalPosition = Cartesian3.unpack(\n          positionsRTC,\n          finalPositionIndex,\n          scratchPrev\n        );\n        if (Cartesian3.equals(finalPosition, volumeStart)) {\n          Cartesian3.unpack(positionsRTC, finalPositionIndex - 3, preStart);\n        } else {\n          var offsetPastStart = Cartesian3.subtract(\n            volumeStart,\n            volumeEnd,\n            scratchPrev\n          );\n          preStart = Cartesian3.add(offsetPastStart, volumeStart, scratchPrev);\n        }\n      } else {\n        Cartesian3.unpack(positionsRTC, currentPositionIndex - 3, preStart);\n      }\n\n      if (j === polylineVolumeCount - 1) {\n        // Check if this volume is like a loop\n        var firstPosition = Cartesian3.unpack(\n          positionsRTC,\n          volumeFirstPositionIndex,\n          scratchNext\n        );\n        if (Cartesian3.equals(firstPosition, volumeEnd)) {\n          Cartesian3.unpack(\n            positionsRTC,\n            volumeFirstPositionIndex + 3,\n            postEnd\n          );\n        } else {\n          var offsetPastEnd = Cartesian3.subtract(\n            volumeEnd,\n            volumeStart,\n            scratchNext\n          );\n          postEnd = Cartesian3.add(offsetPastEnd, volumeEnd, scratchNext);\n        }\n      } else {\n        Cartesian3.unpack(positionsRTC, currentPositionIndex + 6, postEnd);\n      }\n\n      attribsAndIndices.addVolume(\n        preStart,\n        volumeStart,\n        volumeEnd,\n        postEnd,\n        startHeight,\n        endHeight,\n        halfWidth,\n        batchId,\n        center,\n        ellipsoid\n      );\n\n      currentPositionIndex += 3;\n    }\n    currentPositionIndex += 3;\n    currentHeightIndex++;\n  }\n\n  var indices = attribsAndIndices.indices;\n\n  transferableObjects.push(attribsAndIndices.startEllipsoidNormals.buffer);\n  transferableObjects.push(attribsAndIndices.endEllipsoidNormals.buffer);\n  transferableObjects.push(attribsAndIndices.startPositionAndHeights.buffer);\n  transferableObjects.push(\n    attribsAndIndices.startFaceNormalAndVertexCornerIds.buffer\n  );\n  transferableObjects.push(attribsAndIndices.endPositionAndHeights.buffer);\n  transferableObjects.push(attribsAndIndices.endFaceNormalAndHalfWidths.buffer);\n  transferableObjects.push(attribsAndIndices.vertexBatchIds.buffer);\n  transferableObjects.push(indices.buffer);\n\n  var results = {\n    indexDatatype:\n      indices.BYTES_PER_ELEMENT === 2\n        ? IndexDatatype.UNSIGNED_SHORT\n        : IndexDatatype.UNSIGNED_INT,\n    startEllipsoidNormals: attribsAndIndices.startEllipsoidNormals.buffer,\n    endEllipsoidNormals: attribsAndIndices.endEllipsoidNormals.buffer,\n    startPositionAndHeights: attribsAndIndices.startPositionAndHeights.buffer,\n    startFaceNormalAndVertexCornerIds:\n      attribsAndIndices.startFaceNormalAndVertexCornerIds.buffer,\n    endPositionAndHeights: attribsAndIndices.endPositionAndHeights.buffer,\n    endFaceNormalAndHalfWidths:\n      attribsAndIndices.endFaceNormalAndHalfWidths.buffer,\n    vertexBatchIds: attribsAndIndices.vertexBatchIds.buffer,\n    indices: indices.buffer,\n  };\n\n  if (parameters.keepDecodedPositions) {\n    var positionOffsets = getPositionOffsets(counts);\n    transferableObjects.push(positions.buffer, positionOffsets.buffer);\n    results = combine(results, {\n      decodedPositions: positions.buffer,\n      decodedPositionOffsets: positionOffsets.buffer,\n    });\n  }\n\n  return results;\n}\nexport default createTaskProcessorWorker(createVectorTileClampedPolylines);\n"],"names":["MAX_SHORT","MITER_BREAK","Math","cos","CesiumMath","toRadians","scratchBVCartographic","Cartographic","scratchEncodedPosition","Cartesian3","previousCompressedCartographicScratch","currentCompressedCartographicScratch","VertexAttributesAndIndices","volumesCount","vertexCount","vec3Floats","vec4Floats","this","startEllipsoidNormals","Float32Array","endEllipsoidNormals","startPositionAndHeights","startFaceNormalAndVertexCornerIds","endPositionAndHeights","endFaceNormalAndHalfWidths","vertexBatchIds","Uint16Array","indices","IndexDatatype","createTypedArray","vec3Offset","vec4Offset","batchIdOffset","indexOffset","volumeStartIndex","towardCurrScratch","towardNextScratch","computeMiteredNormal","previousPosition","position","nextPosition","ellipsoidSurfaceNormal","result","towardNext","subtract","towardCurr","normalize","dot","multiplyByScalar","add","equals","ZERO","cross","REFERENCE_INDICES","REFERENCE_INDICES_LENGTH","length","positionScratch","scratchStartEllipsoidNormal","scratchStartFaceNormal","scratchEndEllipsoidNormal","scratchEndFaceNormal","prototype","addVolume","preStartRTC","startRTC","endRTC","postEndRTC","startHeight","endHeight","halfWidth","batchId","center","ellipsoid","startEllipsoidNormal","geodeticSurfaceNormal","i","endEllipsoidNormal","startFaceNormal","endFaceNormal","pack","scratchRectangle","Rectangle","scratchEllipsoid","Ellipsoid","scratchCenter","scratchPrev","scratchP0","scratchP1","scratchNext","createTaskProcessorWorker","parameters","transferableObjects","encodedPositions","positions","widths","counts","Uint32Array","batchIds","rectangle","packedBuffer","Float64Array","offset","minimumHeight","maximumHeight","unpack","packedLength","positionsLength","uBuffer","subarray","vBuffer","heightBuffer","AttributeCompression","zigZagDeltaDecode","countsLength","markRemoval","Uint8Array","previous","current","count","updatedCount","j","index","previousIndex","longitude","latitude","nextAvailableIndex","k","removeDuplicates","attribsAndIndices","decodedPositions","u","v","h","lon","lerp","west","east","lat","south","north","alt","cartographic","fromRadians","decodedPosition","cartographicToCartesian","decodePositions","positionsRTC","x","y","z","currentPositionIndex","currentHeightIndex","polylineVolumeCount","volumeFirstPositionIndex","volumeStart","volumeEnd","preStart","postEnd","finalPositionIndex","finalPosition","offsetPastStart","firstPosition","offsetPastEnd","push","buffer","results","indexDatatype","BYTES_PER_ELEMENT","UNSIGNED_SHORT","UNSIGNED_INT","keepDecodedPositions","positionOffsets","getPositionOffsets","combine","decodedPositionOffsets"],"mappings":"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"}