{"version":3,"file":"TerrainEncoding-304a796a.js","sources":["../../../../Source/Core/EllipsoidalOccluder.js","../../../../Source/Core/TerrainExaggeration.js","../../../../Source/Core/TerrainQuantization.js","../../../../Source/Core/TerrainEncoding.js"],"sourcesContent":["import BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Check from \"./Check.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport Rectangle from \"./Rectangle.js\";\n\n/**\n * Determine whether or not other objects are visible or hidden behind the visible horizon defined by\n * an {@link Ellipsoid} and a camera position.  The ellipsoid is assumed to be located at the\n * origin of the coordinate system.  This class uses the algorithm described in the\n * {@link https://cesium.com/blog/2013/04/25/Horizon-culling/|Horizon Culling} blog post.\n *\n * @alias EllipsoidalOccluder\n *\n * @param {Ellipsoid} ellipsoid The ellipsoid to use as an occluder.\n * @param {Cartesian3} [cameraPosition] The coordinate of the viewer/camera.  If this parameter is not\n *        specified, {@link EllipsoidalOccluder#cameraPosition} must be called before\n *        testing visibility.\n *\n * @constructor\n *\n * @example\n * // Construct an ellipsoidal occluder with radii 1.0, 1.1, and 0.9.\n * var cameraPosition = new Cesium.Cartesian3(5.0, 6.0, 7.0);\n * var occluderEllipsoid = new Cesium.Ellipsoid(1.0, 1.1, 0.9);\n * var occluder = new Cesium.EllipsoidalOccluder(occluderEllipsoid, cameraPosition);\n *\n * @private\n */\nfunction EllipsoidalOccluder(ellipsoid, cameraPosition) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"ellipsoid\", ellipsoid);\n  //>>includeEnd('debug');\n\n  this._ellipsoid = ellipsoid;\n  this._cameraPosition = new Cartesian3();\n  this._cameraPositionInScaledSpace = new Cartesian3();\n  this._distanceToLimbInScaledSpaceSquared = 0.0;\n\n  // cameraPosition fills in the above values\n  if (defined(cameraPosition)) {\n    this.cameraPosition = cameraPosition;\n  }\n}\n\nObject.defineProperties(EllipsoidalOccluder.prototype, {\n  /**\n   * Gets the occluding ellipsoid.\n   * @memberof EllipsoidalOccluder.prototype\n   * @type {Ellipsoid}\n   */\n  ellipsoid: {\n    get: function () {\n      return this._ellipsoid;\n    },\n  },\n  /**\n   * Gets or sets the position of the camera.\n   * @memberof EllipsoidalOccluder.prototype\n   * @type {Cartesian3}\n   */\n  cameraPosition: {\n    get: function () {\n      return this._cameraPosition;\n    },\n    set: function (cameraPosition) {\n      // See https://cesium.com/blog/2013/04/25/Horizon-culling/\n      var ellipsoid = this._ellipsoid;\n      var cv = ellipsoid.transformPositionToScaledSpace(\n        cameraPosition,\n        this._cameraPositionInScaledSpace\n      );\n      var vhMagnitudeSquared = Cartesian3.magnitudeSquared(cv) - 1.0;\n\n      Cartesian3.clone(cameraPosition, this._cameraPosition);\n      this._cameraPositionInScaledSpace = cv;\n      this._distanceToLimbInScaledSpaceSquared = vhMagnitudeSquared;\n    },\n  },\n});\n\nvar scratchCartesian = new Cartesian3();\n\n/**\n * Determines whether or not a point, the <code>occludee</code>, is hidden from view by the occluder.\n *\n * @param {Cartesian3} occludee The point to test for visibility.\n * @returns {Boolean} <code>true</code> if the occludee is visible; otherwise <code>false</code>.\n *\n * @example\n * var cameraPosition = new Cesium.Cartesian3(0, 0, 2.5);\n * var ellipsoid = new Cesium.Ellipsoid(1.0, 1.1, 0.9);\n * var occluder = new Cesium.EllipsoidalOccluder(ellipsoid, cameraPosition);\n * var point = new Cesium.Cartesian3(0, -3, -3);\n * occluder.isPointVisible(point); //returns true\n */\nEllipsoidalOccluder.prototype.isPointVisible = function (occludee) {\n  var ellipsoid = this._ellipsoid;\n  var occludeeScaledSpacePosition = ellipsoid.transformPositionToScaledSpace(\n    occludee,\n    scratchCartesian\n  );\n  return isScaledSpacePointVisible(\n    occludeeScaledSpacePosition,\n    this._cameraPositionInScaledSpace,\n    this._distanceToLimbInScaledSpaceSquared\n  );\n};\n\n/**\n * Determines whether or not a point expressed in the ellipsoid scaled space, is hidden from view by the\n * occluder.  To transform a Cartesian X, Y, Z position in the coordinate system aligned with the ellipsoid\n * into the scaled space, call {@link Ellipsoid#transformPositionToScaledSpace}.\n *\n * @param {Cartesian3} occludeeScaledSpacePosition The point to test for visibility, represented in the scaled space.\n * @returns {Boolean} <code>true</code> if the occludee is visible; otherwise <code>false</code>.\n *\n * @example\n * var cameraPosition = new Cesium.Cartesian3(0, 0, 2.5);\n * var ellipsoid = new Cesium.Ellipsoid(1.0, 1.1, 0.9);\n * var occluder = new Cesium.EllipsoidalOccluder(ellipsoid, cameraPosition);\n * var point = new Cesium.Cartesian3(0, -3, -3);\n * var scaledSpacePoint = ellipsoid.transformPositionToScaledSpace(point);\n * occluder.isScaledSpacePointVisible(scaledSpacePoint); //returns true\n */\nEllipsoidalOccluder.prototype.isScaledSpacePointVisible = function (\n  occludeeScaledSpacePosition\n) {\n  return isScaledSpacePointVisible(\n    occludeeScaledSpacePosition,\n    this._cameraPositionInScaledSpace,\n    this._distanceToLimbInScaledSpaceSquared\n  );\n};\n\nvar scratchCameraPositionInScaledSpaceShrunk = new Cartesian3();\n\n/**\n * Similar to {@link EllipsoidalOccluder#isScaledSpacePointVisible} except tests against an\n * ellipsoid that has been shrunk by the minimum height when the minimum height is below\n * the ellipsoid. This is intended to be used with points generated by\n * {@link EllipsoidalOccluder#computeHorizonCullingPointPossiblyUnderEllipsoid} or\n * {@link EllipsoidalOccluder#computeHorizonCullingPointFromVerticesPossiblyUnderEllipsoid}.\n *\n * @param {Cartesian3} occludeeScaledSpacePosition The point to test for visibility, represented in the scaled space of the possibly-shrunk ellipsoid.\n * @returns {Boolean} <code>true</code> if the occludee is visible; otherwise <code>false</code>.\n */\nEllipsoidalOccluder.prototype.isScaledSpacePointVisiblePossiblyUnderEllipsoid = function (\n  occludeeScaledSpacePosition,\n  minimumHeight\n) {\n  var ellipsoid = this._ellipsoid;\n  var vhMagnitudeSquared;\n  var cv;\n\n  if (\n    defined(minimumHeight) &&\n    minimumHeight < 0.0 &&\n    ellipsoid.minimumRadius > -minimumHeight\n  ) {\n    // This code is similar to the cameraPosition setter, but unrolled for performance because it will be called a lot.\n    cv = scratchCameraPositionInScaledSpaceShrunk;\n    cv.x = this._cameraPosition.x / (ellipsoid.radii.x + minimumHeight);\n    cv.y = this._cameraPosition.y / (ellipsoid.radii.y + minimumHeight);\n    cv.z = this._cameraPosition.z / (ellipsoid.radii.z + minimumHeight);\n    vhMagnitudeSquared = cv.x * cv.x + cv.y * cv.y + cv.z * cv.z - 1.0;\n  } else {\n    cv = this._cameraPositionInScaledSpace;\n    vhMagnitudeSquared = this._distanceToLimbInScaledSpaceSquared;\n  }\n\n  return isScaledSpacePointVisible(\n    occludeeScaledSpacePosition,\n    cv,\n    vhMagnitudeSquared\n  );\n};\n\n/**\n * Computes a point that can be used for horizon culling from a list of positions.  If the point is below\n * the horizon, all of the positions are guaranteed to be below the horizon as well.  The returned point\n * is expressed in the ellipsoid-scaled space and is suitable for use with\n * {@link EllipsoidalOccluder#isScaledSpacePointVisible}.\n *\n * @param {Cartesian3} directionToPoint The direction that the computed point will lie along.\n *                     A reasonable direction to use is the direction from the center of the ellipsoid to\n *                     the center of the bounding sphere computed from the positions.  The direction need not\n *                     be normalized.\n * @param {Cartesian3[]} positions The positions from which to compute the horizon culling point.  The positions\n *                       must be expressed in a reference frame centered at the ellipsoid and aligned with the\n *                       ellipsoid's axes.\n * @param {Cartesian3} [result] The instance on which to store the result instead of allocating a new instance.\n * @returns {Cartesian3} The computed horizon culling point, expressed in the ellipsoid-scaled space.\n */\nEllipsoidalOccluder.prototype.computeHorizonCullingPoint = function (\n  directionToPoint,\n  positions,\n  result\n) {\n  return computeHorizonCullingPointFromPositions(\n    this._ellipsoid,\n    directionToPoint,\n    positions,\n    result\n  );\n};\n\nvar scratchEllipsoidShrunk = Ellipsoid.clone(Ellipsoid.UNIT_SPHERE);\n\n/**\n * Similar to {@link EllipsoidalOccluder#computeHorizonCullingPoint} except computes the culling\n * point relative to an ellipsoid that has been shrunk by the minimum height when the minimum height is below\n * the ellipsoid. The returned point is expressed in the possibly-shrunk ellipsoid-scaled space and is suitable\n * for use with {@link EllipsoidalOccluder#isScaledSpacePointVisiblePossiblyUnderEllipsoid}.\n *\n * @param {Cartesian3} directionToPoint The direction that the computed point will lie along.\n *                     A reasonable direction to use is the direction from the center of the ellipsoid to\n *                     the center of the bounding sphere computed from the positions.  The direction need not\n *                     be normalized.\n * @param {Cartesian3[]} positions The positions from which to compute the horizon culling point.  The positions\n *                       must be expressed in a reference frame centered at the ellipsoid and aligned with the\n *                       ellipsoid's axes.\n * @param {Number} [minimumHeight] The minimum height of all positions. If this value is undefined, all positions are assumed to be above the ellipsoid.\n * @param {Cartesian3} [result] The instance on which to store the result instead of allocating a new instance.\n * @returns {Cartesian3} The computed horizon culling point, expressed in the possibly-shrunk ellipsoid-scaled space.\n */\nEllipsoidalOccluder.prototype.computeHorizonCullingPointPossiblyUnderEllipsoid = function (\n  directionToPoint,\n  positions,\n  minimumHeight,\n  result\n) {\n  var possiblyShrunkEllipsoid = getPossiblyShrunkEllipsoid(\n    this._ellipsoid,\n    minimumHeight,\n    scratchEllipsoidShrunk\n  );\n  return computeHorizonCullingPointFromPositions(\n    possiblyShrunkEllipsoid,\n    directionToPoint,\n    positions,\n    result\n  );\n};\n/**\n * Computes a point that can be used for horizon culling from a list of positions.  If the point is below\n * the horizon, all of the positions are guaranteed to be below the horizon as well.  The returned point\n * is expressed in the ellipsoid-scaled space and is suitable for use with\n * {@link EllipsoidalOccluder#isScaledSpacePointVisible}.\n *\n * @param {Cartesian3} directionToPoint The direction that the computed point will lie along.\n *                     A reasonable direction to use is the direction from the center of the ellipsoid to\n *                     the center of the bounding sphere computed from the positions.  The direction need not\n *                     be normalized.\n * @param {Number[]} vertices  The vertices from which to compute the horizon culling point.  The positions\n *                   must be expressed in a reference frame centered at the ellipsoid and aligned with the\n *                   ellipsoid's axes.\n * @param {Number} [stride=3]\n * @param {Cartesian3} [center=Cartesian3.ZERO]\n * @param {Cartesian3} [result] The instance on which to store the result instead of allocating a new instance.\n * @returns {Cartesian3} The computed horizon culling point, expressed in the ellipsoid-scaled space.\n */\nEllipsoidalOccluder.prototype.computeHorizonCullingPointFromVertices = function (\n  directionToPoint,\n  vertices,\n  stride,\n  center,\n  result\n) {\n  return computeHorizonCullingPointFromVertices(\n    this._ellipsoid,\n    directionToPoint,\n    vertices,\n    stride,\n    center,\n    result\n  );\n};\n\n/**\n * Similar to {@link EllipsoidalOccluder#computeHorizonCullingPointFromVertices} except computes the culling\n * point relative to an ellipsoid that has been shrunk by the minimum height when the minimum height is below\n * the ellipsoid. The returned point is expressed in the possibly-shrunk ellipsoid-scaled space and is suitable\n * for use with {@link EllipsoidalOccluder#isScaledSpacePointVisiblePossiblyUnderEllipsoid}.\n *\n * @param {Cartesian3} directionToPoint The direction that the computed point will lie along.\n *                     A reasonable direction to use is the direction from the center of the ellipsoid to\n *                     the center of the bounding sphere computed from the positions.  The direction need not\n *                     be normalized.\n * @param {Number[]} vertices  The vertices from which to compute the horizon culling point.  The positions\n *                   must be expressed in a reference frame centered at the ellipsoid and aligned with the\n *                   ellipsoid's axes.\n * @param {Number} [stride=3]\n * @param {Cartesian3} [center=Cartesian3.ZERO]\n * @param {Number} [minimumHeight] The minimum height of all vertices. If this value is undefined, all vertices are assumed to be above the ellipsoid.\n * @param {Cartesian3} [result] The instance on which to store the result instead of allocating a new instance.\n * @returns {Cartesian3} The computed horizon culling point, expressed in the possibly-shrunk ellipsoid-scaled space.\n */\nEllipsoidalOccluder.prototype.computeHorizonCullingPointFromVerticesPossiblyUnderEllipsoid = function (\n  directionToPoint,\n  vertices,\n  stride,\n  center,\n  minimumHeight,\n  result\n) {\n  var possiblyShrunkEllipsoid = getPossiblyShrunkEllipsoid(\n    this._ellipsoid,\n    minimumHeight,\n    scratchEllipsoidShrunk\n  );\n  return computeHorizonCullingPointFromVertices(\n    possiblyShrunkEllipsoid,\n    directionToPoint,\n    vertices,\n    stride,\n    center,\n    result\n  );\n};\n\nvar subsampleScratch = [];\n\n/**\n * Computes a point that can be used for horizon culling of a rectangle.  If the point is below\n * the horizon, the ellipsoid-conforming rectangle is guaranteed to be below the horizon as well.\n * The returned point is expressed in the ellipsoid-scaled space and is suitable for use with\n * {@link EllipsoidalOccluder#isScaledSpacePointVisible}.\n *\n * @param {Rectangle} rectangle The rectangle for which to compute the horizon culling point.\n * @param {Ellipsoid} ellipsoid The ellipsoid on which the rectangle is defined.  This may be different from\n *                    the ellipsoid used by this instance for occlusion testing.\n * @param {Cartesian3} [result] The instance on which to store the result instead of allocating a new instance.\n * @returns {Cartesian3} The computed horizon culling point, expressed in the ellipsoid-scaled space.\n */\nEllipsoidalOccluder.prototype.computeHorizonCullingPointFromRectangle = function (\n  rectangle,\n  ellipsoid,\n  result\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"rectangle\", rectangle);\n  //>>includeEnd('debug');\n\n  var positions = Rectangle.subsample(\n    rectangle,\n    ellipsoid,\n    0.0,\n    subsampleScratch\n  );\n  var bs = BoundingSphere.fromPoints(positions);\n\n  // If the bounding sphere center is too close to the center of the occluder, it doesn't make\n  // sense to try to horizon cull it.\n  if (Cartesian3.magnitude(bs.center) < 0.1 * ellipsoid.minimumRadius) {\n    return undefined;\n  }\n\n  return this.computeHorizonCullingPoint(bs.center, positions, result);\n};\n\nvar scratchEllipsoidShrunkRadii = new Cartesian3();\n\nfunction getPossiblyShrunkEllipsoid(ellipsoid, minimumHeight, result) {\n  if (\n    defined(minimumHeight) &&\n    minimumHeight < 0.0 &&\n    ellipsoid.minimumRadius > -minimumHeight\n  ) {\n    var ellipsoidShrunkRadii = Cartesian3.fromElements(\n      ellipsoid.radii.x + minimumHeight,\n      ellipsoid.radii.y + minimumHeight,\n      ellipsoid.radii.z + minimumHeight,\n      scratchEllipsoidShrunkRadii\n    );\n    ellipsoid = Ellipsoid.fromCartesian3(ellipsoidShrunkRadii, result);\n  }\n  return ellipsoid;\n}\n\nfunction computeHorizonCullingPointFromPositions(\n  ellipsoid,\n  directionToPoint,\n  positions,\n  result\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"directionToPoint\", directionToPoint);\n  Check.defined(\"positions\", positions);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n\n  var scaledSpaceDirectionToPoint = computeScaledSpaceDirectionToPoint(\n    ellipsoid,\n    directionToPoint\n  );\n  var resultMagnitude = 0.0;\n\n  for (var i = 0, len = positions.length; i < len; ++i) {\n    var position = positions[i];\n    var candidateMagnitude = computeMagnitude(\n      ellipsoid,\n      position,\n      scaledSpaceDirectionToPoint\n    );\n    if (candidateMagnitude < 0.0) {\n      // all points should face the same direction, but this one doesn't, so return undefined\n      return undefined;\n    }\n    resultMagnitude = Math.max(resultMagnitude, candidateMagnitude);\n  }\n\n  return magnitudeToPoint(scaledSpaceDirectionToPoint, resultMagnitude, result);\n}\n\nvar positionScratch = new Cartesian3();\n\nfunction computeHorizonCullingPointFromVertices(\n  ellipsoid,\n  directionToPoint,\n  vertices,\n  stride,\n  center,\n  result\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"directionToPoint\", directionToPoint);\n  Check.defined(\"vertices\", vertices);\n  Check.typeOf.number(\"stride\", stride);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n\n  stride = defaultValue(stride, 3);\n  center = defaultValue(center, Cartesian3.ZERO);\n  var scaledSpaceDirectionToPoint = computeScaledSpaceDirectionToPoint(\n    ellipsoid,\n    directionToPoint\n  );\n  var resultMagnitude = 0.0;\n\n  for (var i = 0, len = vertices.length; i < len; i += stride) {\n    positionScratch.x = vertices[i] + center.x;\n    positionScratch.y = vertices[i + 1] + center.y;\n    positionScratch.z = vertices[i + 2] + center.z;\n\n    var candidateMagnitude = computeMagnitude(\n      ellipsoid,\n      positionScratch,\n      scaledSpaceDirectionToPoint\n    );\n    if (candidateMagnitude < 0.0) {\n      // all points should face the same direction, but this one doesn't, so return undefined\n      return undefined;\n    }\n    resultMagnitude = Math.max(resultMagnitude, candidateMagnitude);\n  }\n\n  return magnitudeToPoint(scaledSpaceDirectionToPoint, resultMagnitude, result);\n}\n\nfunction isScaledSpacePointVisible(\n  occludeeScaledSpacePosition,\n  cameraPositionInScaledSpace,\n  distanceToLimbInScaledSpaceSquared\n) {\n  // See https://cesium.com/blog/2013/04/25/Horizon-culling/\n  var cv = cameraPositionInScaledSpace;\n  var vhMagnitudeSquared = distanceToLimbInScaledSpaceSquared;\n  var vt = Cartesian3.subtract(\n    occludeeScaledSpacePosition,\n    cv,\n    scratchCartesian\n  );\n  var vtDotVc = -Cartesian3.dot(vt, cv);\n  // If vhMagnitudeSquared < 0 then we are below the surface of the ellipsoid and\n  // in this case, set the culling plane to be on V.\n  var isOccluded =\n    vhMagnitudeSquared < 0\n      ? vtDotVc > 0\n      : vtDotVc > vhMagnitudeSquared &&\n        (vtDotVc * vtDotVc) / Cartesian3.magnitudeSquared(vt) >\n          vhMagnitudeSquared;\n  return !isOccluded;\n}\n\nvar scaledSpaceScratch = new Cartesian3();\nvar directionScratch = new Cartesian3();\n\nfunction computeMagnitude(ellipsoid, position, scaledSpaceDirectionToPoint) {\n  var scaledSpacePosition = ellipsoid.transformPositionToScaledSpace(\n    position,\n    scaledSpaceScratch\n  );\n  var magnitudeSquared = Cartesian3.magnitudeSquared(scaledSpacePosition);\n  var magnitude = Math.sqrt(magnitudeSquared);\n  var direction = Cartesian3.divideByScalar(\n    scaledSpacePosition,\n    magnitude,\n    directionScratch\n  );\n\n  // For the purpose of this computation, points below the ellipsoid are consider to be on it instead.\n  magnitudeSquared = Math.max(1.0, magnitudeSquared);\n  magnitude = Math.max(1.0, magnitude);\n\n  var cosAlpha = Cartesian3.dot(direction, scaledSpaceDirectionToPoint);\n  var sinAlpha = Cartesian3.magnitude(\n    Cartesian3.cross(direction, scaledSpaceDirectionToPoint, direction)\n  );\n  var cosBeta = 1.0 / magnitude;\n  var sinBeta = Math.sqrt(magnitudeSquared - 1.0) * cosBeta;\n\n  return 1.0 / (cosAlpha * cosBeta - sinAlpha * sinBeta);\n}\n\nfunction magnitudeToPoint(\n  scaledSpaceDirectionToPoint,\n  resultMagnitude,\n  result\n) {\n  // The horizon culling point is undefined if there were no positions from which to compute it,\n  // the directionToPoint is pointing opposite all of the positions,  or if we computed NaN or infinity.\n  if (\n    resultMagnitude <= 0.0 ||\n    resultMagnitude === 1.0 / 0.0 ||\n    resultMagnitude !== resultMagnitude\n  ) {\n    return undefined;\n  }\n\n  return Cartesian3.multiplyByScalar(\n    scaledSpaceDirectionToPoint,\n    resultMagnitude,\n    result\n  );\n}\n\nvar directionToPointScratch = new Cartesian3();\n\nfunction computeScaledSpaceDirectionToPoint(ellipsoid, directionToPoint) {\n  if (Cartesian3.equals(directionToPoint, Cartesian3.ZERO)) {\n    return directionToPoint;\n  }\n\n  ellipsoid.transformPositionToScaledSpace(\n    directionToPoint,\n    directionToPointScratch\n  );\n  return Cartesian3.normalize(directionToPointScratch, directionToPointScratch);\n}\nexport default EllipsoidalOccluder;\n","import Cartesian3 from \"./Cartesian3.js\";\n\n/**\n * @private\n */\nvar TerrainExaggeration = {};\n\n/**\n * Scales a height relative to an offset.\n *\n * @param {Number} height The height.\n * @param {Number} scale A scalar used to exaggerate the terrain. If the value is 1.0 there will be no effect.\n * @param {Number} relativeHeight The height relative to which terrain is exaggerated. If the value is 0.0 terrain will be exaggerated relative to the ellipsoid surface.\n */\nTerrainExaggeration.getHeight = function (height, scale, relativeHeight) {\n  return (height - relativeHeight) * scale + relativeHeight;\n};\n\nvar scratchCartographic = new Cartesian3();\n\n/**\n * Scales a position by exaggeration.\n */\nTerrainExaggeration.getPosition = function (\n  position,\n  ellipsoid,\n  terrainExaggeration,\n  terrainExaggerationRelativeHeight,\n  result\n) {\n  var cartographic = ellipsoid.cartesianToCartographic(\n    position,\n    scratchCartographic\n  );\n  var newHeight = TerrainExaggeration.getHeight(\n    cartographic.height,\n    terrainExaggeration,\n    terrainExaggerationRelativeHeight\n  );\n  return Cartesian3.fromRadians(\n    cartographic.longitude,\n    cartographic.latitude,\n    newHeight,\n    ellipsoid,\n    result\n  );\n};\n\nexport default TerrainExaggeration;\n","/**\n * This enumerated type is used to determine how the vertices of the terrain mesh are compressed.\n *\n * @enum {Number}\n *\n * @private\n */\nvar TerrainQuantization = {\n  /**\n   * The vertices are not compressed.\n   *\n   * @type {Number}\n   * @constant\n   */\n  NONE: 0,\n\n  /**\n   * The vertices are compressed to 12 bits.\n   *\n   * @type {Number}\n   * @constant\n   */\n  BITS12: 1,\n};\nexport default Object.freeze(TerrainQuantization);\n","import AttributeCompression from \"./AttributeCompression.js\";\nimport Cartesian2 from \"./Cartesian2.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport ComponentDatatype from \"./ComponentDatatype.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport CesiumMath from \"./Math.js\";\nimport Matrix4 from \"./Matrix4.js\";\nimport TerrainExaggeration from \"./TerrainExaggeration.js\";\nimport TerrainQuantization from \"./TerrainQuantization.js\";\n\nvar cartesian3Scratch = new Cartesian3();\nvar cartesian3DimScratch = new Cartesian3();\nvar cartesian2Scratch = new Cartesian2();\nvar matrix4Scratch = new Matrix4();\nvar matrix4Scratch2 = new Matrix4();\n\nvar SHIFT_LEFT_12 = Math.pow(2.0, 12.0);\n\n/**\n * Data used to quantize and pack the terrain mesh. The position can be unpacked for picking and all attributes\n * are unpacked in the vertex shader.\n *\n * @alias TerrainEncoding\n * @constructor\n *\n * @param {Cartesian3} center The center point of the vertices.\n * @param {AxisAlignedBoundingBox} axisAlignedBoundingBox The bounds of the tile in the east-north-up coordinates at the tiles center.\n * @param {Number} minimumHeight The minimum height.\n * @param {Number} maximumHeight The maximum height.\n * @param {Matrix4} fromENU The east-north-up to fixed frame matrix at the center of the terrain mesh.\n * @param {Boolean} hasVertexNormals If the mesh has vertex normals.\n * @param {Boolean} [hasWebMercatorT=false] true if the terrain data includes a Web Mercator texture coordinate; otherwise, false.\n * @param {Boolean} [hasGeodeticSurfaceNormals=false] true if the terrain data includes geodetic surface normals; otherwise, false.\n * @param {Number} [exaggeration=1.0] A scalar used to exaggerate terrain.\n * @param {Number} [exaggerationRelativeHeight=0.0] The relative height from which terrain is exaggerated.\n *\n * @private\n */\nfunction TerrainEncoding(\n  center,\n  axisAlignedBoundingBox,\n  minimumHeight,\n  maximumHeight,\n  fromENU,\n  hasVertexNormals,\n  hasWebMercatorT,\n  hasGeodeticSurfaceNormals,\n  exaggeration,\n  exaggerationRelativeHeight\n) {\n  var quantization = TerrainQuantization.NONE;\n  var toENU;\n  var matrix;\n\n  if (\n    defined(axisAlignedBoundingBox) &&\n    defined(minimumHeight) &&\n    defined(maximumHeight) &&\n    defined(fromENU)\n  ) {\n    var minimum = axisAlignedBoundingBox.minimum;\n    var maximum = axisAlignedBoundingBox.maximum;\n\n    var dimensions = Cartesian3.subtract(\n      maximum,\n      minimum,\n      cartesian3DimScratch\n    );\n    var hDim = maximumHeight - minimumHeight;\n    var maxDim = Math.max(Cartesian3.maximumComponent(dimensions), hDim);\n\n    if (maxDim < SHIFT_LEFT_12 - 1.0) {\n      quantization = TerrainQuantization.BITS12;\n    } else {\n      quantization = TerrainQuantization.NONE;\n    }\n\n    toENU = Matrix4.inverseTransformation(fromENU, new Matrix4());\n\n    var translation = Cartesian3.negate(minimum, cartesian3Scratch);\n    Matrix4.multiply(\n      Matrix4.fromTranslation(translation, matrix4Scratch),\n      toENU,\n      toENU\n    );\n\n    var scale = cartesian3Scratch;\n    scale.x = 1.0 / dimensions.x;\n    scale.y = 1.0 / dimensions.y;\n    scale.z = 1.0 / dimensions.z;\n    Matrix4.multiply(Matrix4.fromScale(scale, matrix4Scratch), toENU, toENU);\n\n    matrix = Matrix4.clone(fromENU);\n    Matrix4.setTranslation(matrix, Cartesian3.ZERO, matrix);\n\n    fromENU = Matrix4.clone(fromENU, new Matrix4());\n\n    var translationMatrix = Matrix4.fromTranslation(minimum, matrix4Scratch);\n    var scaleMatrix = Matrix4.fromScale(dimensions, matrix4Scratch2);\n    var st = Matrix4.multiply(translationMatrix, scaleMatrix, matrix4Scratch);\n\n    Matrix4.multiply(fromENU, st, fromENU);\n    Matrix4.multiply(matrix, st, matrix);\n  }\n\n  /**\n   * How the vertices of the mesh were compressed.\n   * @type {TerrainQuantization}\n   */\n  this.quantization = quantization;\n\n  /**\n   * The minimum height of the tile including the skirts.\n   * @type {Number}\n   */\n  this.minimumHeight = minimumHeight;\n\n  /**\n   * The maximum height of the tile.\n   * @type {Number}\n   */\n  this.maximumHeight = maximumHeight;\n\n  /**\n   * The center of the tile.\n   * @type {Cartesian3}\n   */\n  this.center = Cartesian3.clone(center);\n\n  /**\n   * A matrix that takes a vertex from the tile, transforms it to east-north-up at the center and scales\n   * it so each component is in the [0, 1] range.\n   * @type {Matrix4}\n   */\n  this.toScaledENU = toENU;\n\n  /**\n   * A matrix that restores a vertex transformed with toScaledENU back to the earth fixed reference frame\n   * @type {Matrix4}\n   */\n  this.fromScaledENU = fromENU;\n\n  /**\n   * The matrix used to decompress the terrain vertices in the shader for RTE rendering.\n   * @type {Matrix4}\n   */\n  this.matrix = matrix;\n\n  /**\n   * The terrain mesh contains normals.\n   * @type {Boolean}\n   */\n  this.hasVertexNormals = hasVertexNormals;\n\n  /**\n   * The terrain mesh contains a vertical texture coordinate following the Web Mercator projection.\n   * @type {Boolean}\n   */\n  this.hasWebMercatorT = defaultValue(hasWebMercatorT, false);\n\n  /**\n   * The terrain mesh contains geodetic surface normals, used for terrain exaggeration.\n   * @type {Boolean}\n   */\n  this.hasGeodeticSurfaceNormals = defaultValue(\n    hasGeodeticSurfaceNormals,\n    false\n  );\n\n  /**\n   * A scalar used to exaggerate terrain.\n   * @type {Number}\n   */\n  this.exaggeration = defaultValue(exaggeration, 1.0);\n\n  /**\n   * The relative height from which terrain is exaggerated.\n   */\n  this.exaggerationRelativeHeight = defaultValue(\n    exaggerationRelativeHeight,\n    0.0\n  );\n\n  /**\n   * The number of components in each vertex. This value can differ with different quantizations.\n   * @type {Number}\n   */\n  this.stride = 0;\n\n  this._offsetGeodeticSurfaceNormal = 0;\n  this._offsetVertexNormal = 0;\n\n  // Calculate the stride and offsets declared above\n  this._calculateStrideAndOffsets();\n}\n\nTerrainEncoding.prototype.encode = function (\n  vertexBuffer,\n  bufferIndex,\n  position,\n  uv,\n  height,\n  normalToPack,\n  webMercatorT,\n  geodeticSurfaceNormal\n) {\n  var u = uv.x;\n  var v = uv.y;\n\n  if (this.quantization === TerrainQuantization.BITS12) {\n    position = Matrix4.multiplyByPoint(\n      this.toScaledENU,\n      position,\n      cartesian3Scratch\n    );\n\n    position.x = CesiumMath.clamp(position.x, 0.0, 1.0);\n    position.y = CesiumMath.clamp(position.y, 0.0, 1.0);\n    position.z = CesiumMath.clamp(position.z, 0.0, 1.0);\n\n    var hDim = this.maximumHeight - this.minimumHeight;\n    var h = CesiumMath.clamp((height - this.minimumHeight) / hDim, 0.0, 1.0);\n\n    Cartesian2.fromElements(position.x, position.y, cartesian2Scratch);\n    var compressed0 = AttributeCompression.compressTextureCoordinates(\n      cartesian2Scratch\n    );\n\n    Cartesian2.fromElements(position.z, h, cartesian2Scratch);\n    var compressed1 = AttributeCompression.compressTextureCoordinates(\n      cartesian2Scratch\n    );\n\n    Cartesian2.fromElements(u, v, cartesian2Scratch);\n    var compressed2 = AttributeCompression.compressTextureCoordinates(\n      cartesian2Scratch\n    );\n\n    vertexBuffer[bufferIndex++] = compressed0;\n    vertexBuffer[bufferIndex++] = compressed1;\n    vertexBuffer[bufferIndex++] = compressed2;\n\n    if (this.hasWebMercatorT) {\n      Cartesian2.fromElements(webMercatorT, 0.0, cartesian2Scratch);\n      var compressed3 = AttributeCompression.compressTextureCoordinates(\n        cartesian2Scratch\n      );\n      vertexBuffer[bufferIndex++] = compressed3;\n    }\n  } else {\n    Cartesian3.subtract(position, this.center, cartesian3Scratch);\n\n    vertexBuffer[bufferIndex++] = cartesian3Scratch.x;\n    vertexBuffer[bufferIndex++] = cartesian3Scratch.y;\n    vertexBuffer[bufferIndex++] = cartesian3Scratch.z;\n    vertexBuffer[bufferIndex++] = height;\n    vertexBuffer[bufferIndex++] = u;\n    vertexBuffer[bufferIndex++] = v;\n\n    if (this.hasWebMercatorT) {\n      vertexBuffer[bufferIndex++] = webMercatorT;\n    }\n  }\n\n  if (this.hasVertexNormals) {\n    vertexBuffer[bufferIndex++] = AttributeCompression.octPackFloat(\n      normalToPack\n    );\n  }\n\n  if (this.hasGeodeticSurfaceNormals) {\n    vertexBuffer[bufferIndex++] = geodeticSurfaceNormal.x;\n    vertexBuffer[bufferIndex++] = geodeticSurfaceNormal.y;\n    vertexBuffer[bufferIndex++] = geodeticSurfaceNormal.z;\n  }\n\n  return bufferIndex;\n};\n\nvar scratchPosition = new Cartesian3();\nvar scratchGeodeticSurfaceNormal = new Cartesian3();\n\nTerrainEncoding.prototype.addGeodeticSurfaceNormals = function (\n  oldBuffer,\n  newBuffer,\n  ellipsoid\n) {\n  if (this.hasGeodeticSurfaceNormals) {\n    return;\n  }\n\n  var oldStride = this.stride;\n  var vertexCount = oldBuffer.length / oldStride;\n  this.hasGeodeticSurfaceNormals = true;\n  this._calculateStrideAndOffsets();\n  var newStride = this.stride;\n\n  for (var index = 0; index < vertexCount; index++) {\n    for (var offset = 0; offset < oldStride; offset++) {\n      var oldIndex = index * oldStride + offset;\n      var newIndex = index * newStride + offset;\n      newBuffer[newIndex] = oldBuffer[oldIndex];\n    }\n    var position = this.decodePosition(newBuffer, index, scratchPosition);\n    var geodeticSurfaceNormal = ellipsoid.geodeticSurfaceNormal(\n      position,\n      scratchGeodeticSurfaceNormal\n    );\n\n    var bufferIndex = index * newStride + this._offsetGeodeticSurfaceNormal;\n    newBuffer[bufferIndex] = geodeticSurfaceNormal.x;\n    newBuffer[bufferIndex + 1] = geodeticSurfaceNormal.y;\n    newBuffer[bufferIndex + 2] = geodeticSurfaceNormal.z;\n  }\n};\n\nTerrainEncoding.prototype.removeGeodeticSurfaceNormals = function (\n  oldBuffer,\n  newBuffer\n) {\n  if (!this.hasGeodeticSurfaceNormals) {\n    return;\n  }\n\n  var oldStride = this.stride;\n  var vertexCount = oldBuffer.length / oldStride;\n  this.hasGeodeticSurfaceNormals = false;\n  this._calculateStrideAndOffsets();\n  var newStride = this.stride;\n\n  for (var index = 0; index < vertexCount; index++) {\n    for (var offset = 0; offset < newStride; offset++) {\n      var oldIndex = index * oldStride + offset;\n      var newIndex = index * newStride + offset;\n      newBuffer[newIndex] = oldBuffer[oldIndex];\n    }\n  }\n};\n\nTerrainEncoding.prototype.decodePosition = function (buffer, index, result) {\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n\n  index *= this.stride;\n\n  if (this.quantization === TerrainQuantization.BITS12) {\n    var xy = AttributeCompression.decompressTextureCoordinates(\n      buffer[index],\n      cartesian2Scratch\n    );\n    result.x = xy.x;\n    result.y = xy.y;\n\n    var zh = AttributeCompression.decompressTextureCoordinates(\n      buffer[index + 1],\n      cartesian2Scratch\n    );\n    result.z = zh.x;\n\n    return Matrix4.multiplyByPoint(this.fromScaledENU, result, result);\n  }\n\n  result.x = buffer[index];\n  result.y = buffer[index + 1];\n  result.z = buffer[index + 2];\n  return Cartesian3.add(result, this.center, result);\n};\n\nTerrainEncoding.prototype.getExaggeratedPosition = function (\n  buffer,\n  index,\n  result\n) {\n  result = this.decodePosition(buffer, index, result);\n\n  var exaggeration = this.exaggeration;\n  var exaggerationRelativeHeight = this.exaggerationRelativeHeight;\n  var hasExaggeration = exaggeration !== 1.0;\n  if (hasExaggeration && this.hasGeodeticSurfaceNormals) {\n    var geodeticSurfaceNormal = this.decodeGeodeticSurfaceNormal(\n      buffer,\n      index,\n      scratchGeodeticSurfaceNormal\n    );\n    var rawHeight = this.decodeHeight(buffer, index);\n    var heightDifference =\n      TerrainExaggeration.getHeight(\n        rawHeight,\n        exaggeration,\n        exaggerationRelativeHeight\n      ) - rawHeight;\n\n    // some math is unrolled for better performance\n    result.x += geodeticSurfaceNormal.x * heightDifference;\n    result.y += geodeticSurfaceNormal.y * heightDifference;\n    result.z += geodeticSurfaceNormal.z * heightDifference;\n  }\n\n  return result;\n};\n\nTerrainEncoding.prototype.decodeTextureCoordinates = function (\n  buffer,\n  index,\n  result\n) {\n  if (!defined(result)) {\n    result = new Cartesian2();\n  }\n\n  index *= this.stride;\n\n  if (this.quantization === TerrainQuantization.BITS12) {\n    return AttributeCompression.decompressTextureCoordinates(\n      buffer[index + 2],\n      result\n    );\n  }\n\n  return Cartesian2.fromElements(buffer[index + 4], buffer[index + 5], result);\n};\n\nTerrainEncoding.prototype.decodeHeight = function (buffer, index) {\n  index *= this.stride;\n\n  if (this.quantization === TerrainQuantization.BITS12) {\n    var zh = AttributeCompression.decompressTextureCoordinates(\n      buffer[index + 1],\n      cartesian2Scratch\n    );\n    return (\n      zh.y * (this.maximumHeight - this.minimumHeight) + this.minimumHeight\n    );\n  }\n\n  return buffer[index + 3];\n};\n\nTerrainEncoding.prototype.decodeWebMercatorT = function (buffer, index) {\n  index *= this.stride;\n\n  if (this.quantization === TerrainQuantization.BITS12) {\n    return AttributeCompression.decompressTextureCoordinates(\n      buffer[index + 3],\n      cartesian2Scratch\n    ).x;\n  }\n\n  return buffer[index + 6];\n};\n\nTerrainEncoding.prototype.getOctEncodedNormal = function (\n  buffer,\n  index,\n  result\n) {\n  index = index * this.stride + this._offsetVertexNormal;\n\n  var temp = buffer[index] / 256.0;\n  var x = Math.floor(temp);\n  var y = (temp - x) * 256.0;\n\n  return Cartesian2.fromElements(x, y, result);\n};\n\nTerrainEncoding.prototype.decodeGeodeticSurfaceNormal = function (\n  buffer,\n  index,\n  result\n) {\n  index = index * this.stride + this._offsetGeodeticSurfaceNormal;\n\n  result.x = buffer[index];\n  result.y = buffer[index + 1];\n  result.z = buffer[index + 2];\n  return result;\n};\n\nTerrainEncoding.prototype._calculateStrideAndOffsets = function () {\n  var vertexStride = 0;\n\n  switch (this.quantization) {\n    case TerrainQuantization.BITS12:\n      vertexStride += 3;\n      break;\n    default:\n      vertexStride += 6;\n  }\n  if (this.hasWebMercatorT) {\n    vertexStride += 1;\n  }\n  if (this.hasVertexNormals) {\n    this._offsetVertexNormal = vertexStride;\n    vertexStride += 1;\n  }\n  if (this.hasGeodeticSurfaceNormals) {\n    this._offsetGeodeticSurfaceNormal = vertexStride;\n    vertexStride += 3;\n  }\n\n  this.stride = vertexStride;\n};\n\nvar attributesIndicesNone = {\n  position3DAndHeight: 0,\n  textureCoordAndEncodedNormals: 1,\n  geodeticSurfaceNormal: 2,\n};\nvar attributesIndicesBits12 = {\n  compressed0: 0,\n  compressed1: 1,\n  geodeticSurfaceNormal: 2,\n};\n\nTerrainEncoding.prototype.getAttributes = function (buffer) {\n  var datatype = ComponentDatatype.FLOAT;\n  var sizeInBytes = ComponentDatatype.getSizeInBytes(datatype);\n  var strideInBytes = this.stride * sizeInBytes;\n  var offsetInBytes = 0;\n\n  var attributes = [];\n  function addAttribute(index, componentsPerAttribute) {\n    attributes.push({\n      index: index,\n      vertexBuffer: buffer,\n      componentDatatype: datatype,\n      componentsPerAttribute: componentsPerAttribute,\n      offsetInBytes: offsetInBytes,\n      strideInBytes: strideInBytes,\n    });\n    offsetInBytes += componentsPerAttribute * sizeInBytes;\n  }\n\n  if (this.quantization === TerrainQuantization.NONE) {\n    addAttribute(attributesIndicesNone.position3DAndHeight, 4);\n\n    var componentsTexCoordAndNormals = 2;\n    componentsTexCoordAndNormals += this.hasWebMercatorT ? 1 : 0;\n    componentsTexCoordAndNormals += this.hasVertexNormals ? 1 : 0;\n    addAttribute(\n      attributesIndicesNone.textureCoordAndEncodedNormals,\n      componentsTexCoordAndNormals\n    );\n\n    if (this.hasGeodeticSurfaceNormals) {\n      addAttribute(attributesIndicesNone.geodeticSurfaceNormal, 3);\n    }\n  } else {\n    // When there is no webMercatorT or vertex normals, the attribute only needs 3 components: x/y, z/h, u/v.\n    // WebMercatorT and vertex normals each take up one component, so if only one of them is present the first\n    // attribute gets a 4th component. If both are present, we need an additional attribute that has 1 component.\n    var usingAttribute0Component4 =\n      this.hasWebMercatorT || this.hasVertexNormals;\n    var usingAttribute1Component1 =\n      this.hasWebMercatorT && this.hasVertexNormals;\n    addAttribute(\n      attributesIndicesBits12.compressed0,\n      usingAttribute0Component4 ? 4 : 3\n    );\n\n    if (usingAttribute1Component1) {\n      addAttribute(attributesIndicesBits12.compressed1, 1);\n    }\n\n    if (this.hasGeodeticSurfaceNormals) {\n      addAttribute(attributesIndicesBits12.geodeticSurfaceNormal, 3);\n    }\n  }\n\n  return attributes;\n};\n\nTerrainEncoding.prototype.getAttributeLocations = function () {\n  if (this.quantization === TerrainQuantization.NONE) {\n    return attributesIndicesNone;\n  }\n  return attributesIndicesBits12;\n};\n\nTerrainEncoding.clone = function (encoding, result) {\n  if (!defined(encoding)) {\n    return undefined;\n  }\n  if (!defined(result)) {\n    result = new TerrainEncoding();\n  }\n\n  result.quantization = encoding.quantization;\n  result.minimumHeight = encoding.minimumHeight;\n  result.maximumHeight = encoding.maximumHeight;\n  result.center = Cartesian3.clone(encoding.center);\n  result.toScaledENU = Matrix4.clone(encoding.toScaledENU);\n  result.fromScaledENU = Matrix4.clone(encoding.fromScaledENU);\n  result.matrix = Matrix4.clone(encoding.matrix);\n  result.hasVertexNormals = encoding.hasVertexNormals;\n  result.hasWebMercatorT = encoding.hasWebMercatorT;\n  result.hasGeodeticSurfaceNormals = encoding.hasGeodeticSurfaceNormals;\n  result.exaggeration = encoding.exaggeration;\n  result.exaggerationRelativeHeight = encoding.exaggerationRelativeHeight;\n\n  result._calculateStrideAndOffsets();\n\n  return result;\n};\nexport default TerrainEncoding;\n"],"names":["EllipsoidalOccluder","ellipsoid","cameraPosition","Check","typeOf","object","this","_ellipsoid","_cameraPosition","Cartesian3","_cameraPositionInScaledSpace","_distanceToLimbInScaledSpaceSquared","defined","Object","defineProperties","prototype","get","set","cv","transformPositionToScaledSpace","vhMagnitudeSquared","magnitudeSquared","clone","scratchCartesian","isPointVisible","occludee","isScaledSpacePointVisible","occludeeScaledSpacePosition","scratchCameraPositionInScaledSpaceShrunk","isScaledSpacePointVisiblePossiblyUnderEllipsoid","minimumHeight","minimumRadius","x","radii","y","z","computeHorizonCullingPoint","directionToPoint","positions","result","computeHorizonCullingPointFromPositions","scratchEllipsoidShrunk","Ellipsoid","UNIT_SPHERE","computeHorizonCullingPointPossiblyUnderEllipsoid","getPossiblyShrunkEllipsoid","computeHorizonCullingPointFromVertices","vertices","stride","center","computeHorizonCullingPointFromVerticesPossiblyUnderEllipsoid","subsampleScratch","computeHorizonCullingPointFromRectangle","rectangle","Rectangle","subsample","bs","BoundingSphere","fromPoints","magnitude","scratchEllipsoidShrunkRadii","ellipsoidShrunkRadii","fromElements","fromCartesian3","scaledSpaceDirectionToPoint","computeScaledSpaceDirectionToPoint","resultMagnitude","i","len","length","candidateMagnitude","computeMagnitude","Math","max","magnitudeToPoint","positionScratch","number","defaultValue","ZERO","cameraPositionInScaledSpace","distanceToLimbInScaledSpaceSquared","vt","subtract","vtDotVc","dot","scaledSpaceScratch","directionScratch","position","scaledSpacePosition","sqrt","direction","divideByScalar","cosBeta","cross","multiplyByScalar","directionToPointScratch","equals","normalize","TerrainExaggeration","height","scale","relativeHeight","scratchCartographic","getPosition","terrainExaggeration","terrainExaggerationRelativeHeight","cartographic","cartesianToCartographic","newHeight","getHeight","fromRadians","longitude","latitude","freeze","NONE","BITS12","cartesian3Scratch","cartesian3DimScratch","cartesian2Scratch","Cartesian2","matrix4Scratch","Matrix4","matrix4Scratch2","SHIFT_LEFT_12","pow","TerrainEncoding","axisAlignedBoundingBox","maximumHeight","fromENU","hasVertexNormals","hasWebMercatorT","hasGeodeticSurfaceNormals","exaggeration","exaggerationRelativeHeight","toENU","matrix","quantization","TerrainQuantization","minimum","maximum","dimensions","hDim","maximumComponent","inverseTransformation","translation","negate","multiply","fromTranslation","fromScale","setTranslation","translationMatrix","scaleMatrix","st","toScaledENU","fromScaledENU","_offsetGeodeticSurfaceNormal","_offsetVertexNormal","_calculateStrideAndOffsets","encode","vertexBuffer","bufferIndex","uv","normalToPack","webMercatorT","geodeticSurfaceNormal","u","v","multiplyByPoint","CesiumMath","clamp","h","compressed0","AttributeCompression","compressTextureCoordinates","compressed1","compressed2","compressed3","octPackFloat","scratchPosition","scratchGeodeticSurfaceNormal","addGeodeticSurfaceNormals","oldBuffer","newBuffer","oldStride","vertexCount","newStride","index","offset","oldIndex","decodePosition","removeGeodeticSurfaceNormals","buffer","xy","decompressTextureCoordinates","zh","add","getExaggeratedPosition","decodeGeodeticSurfaceNormal","rawHeight","decodeHeight","heightDifference","decodeTextureCoordinates","decodeWebMercatorT","getOctEncodedNormal","temp","floor","vertexStride","attributesIndicesNone","position3DAndHeight","textureCoordAndEncodedNormals","attributesIndicesBits12","getAttributes","datatype","ComponentDatatype","FLOAT","sizeInBytes","getSizeInBytes","strideInBytes","offsetInBytes","attributes","addAttribute","componentsPerAttribute","push","componentDatatype","componentsTexCoordAndNormals","usingAttribute0Component4","usingAttribute1Component1","getAttributeLocations","encoding"],"mappings":"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"}