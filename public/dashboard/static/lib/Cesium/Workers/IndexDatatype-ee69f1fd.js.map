{"version":3,"file":"IndexDatatype-ee69f1fd.js","sources":["../../../../Source/Core/IndexDatatype.js"],"sourcesContent":["import defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport CesiumMath from \"./Math.js\";\nimport WebGLConstants from \"./WebGLConstants.js\";\n\n/**\n * Constants for WebGL index datatypes.  These corresponds to the\n * <code>type</code> parameter of {@link http://www.khronos.org/opengles/sdk/docs/man/xhtml/glDrawElements.xml|drawElements}.\n *\n * @enum {Number}\n */\nvar IndexDatatype = {\n  /**\n   * 8-bit unsigned byte corresponding to <code>UNSIGNED_BYTE</code> and the type\n   * of an element in <code>Uint8Array</code>.\n   *\n   * @type {Number}\n   * @constant\n   */\n  UNSIGNED_BYTE: WebGLConstants.UNSIGNED_BYTE,\n\n  /**\n   * 16-bit unsigned short corresponding to <code>UNSIGNED_SHORT</code> and the type\n   * of an element in <code>Uint16Array</code>.\n   *\n   * @type {Number}\n   * @constant\n   */\n  UNSIGNED_SHORT: WebGLConstants.UNSIGNED_SHORT,\n\n  /**\n   * 32-bit unsigned int corresponding to <code>UNSIGNED_INT</code> and the type\n   * of an element in <code>Uint32Array</code>.\n   *\n   * @type {Number}\n   * @constant\n   */\n  UNSIGNED_INT: WebGLConstants.UNSIGNED_INT,\n};\n\n/**\n * Returns the size, in bytes, of the corresponding datatype.\n *\n * @param {IndexDatatype} indexDatatype The index datatype to get the size of.\n * @returns {Number} The size in bytes.\n *\n * @example\n * // Returns 2\n * var size = Cesium.IndexDatatype.getSizeInBytes(Cesium.IndexDatatype.UNSIGNED_SHORT);\n */\nIndexDatatype.getSizeInBytes = function (indexDatatype) {\n  switch (indexDatatype) {\n    case IndexDatatype.UNSIGNED_BYTE:\n      return Uint8Array.BYTES_PER_ELEMENT;\n    case IndexDatatype.UNSIGNED_SHORT:\n      return Uint16Array.BYTES_PER_ELEMENT;\n    case IndexDatatype.UNSIGNED_INT:\n      return Uint32Array.BYTES_PER_ELEMENT;\n  }\n\n  //>>includeStart('debug', pragmas.debug);\n  throw new DeveloperError(\n    \"indexDatatype is required and must be a valid IndexDatatype constant.\"\n  );\n  //>>includeEnd('debug');\n};\n\n/**\n * Gets the datatype with a given size in bytes.\n *\n * @param {Number} sizeInBytes The size of a single index in bytes.\n * @returns {IndexDatatype} The index datatype with the given size.\n */\nIndexDatatype.fromSizeInBytes = function (sizeInBytes) {\n  switch (sizeInBytes) {\n    case 2:\n      return IndexDatatype.UNSIGNED_SHORT;\n    case 4:\n      return IndexDatatype.UNSIGNED_INT;\n    case 1:\n      return IndexDatatype.UNSIGNED_BYTE;\n    //>>includeStart('debug', pragmas.debug);\n    default:\n      throw new DeveloperError(\n        \"Size in bytes cannot be mapped to an IndexDatatype\"\n      );\n    //>>includeEnd('debug');\n  }\n};\n\n/**\n * Validates that the provided index datatype is a valid {@link IndexDatatype}.\n *\n * @param {IndexDatatype} indexDatatype The index datatype to validate.\n * @returns {Boolean} <code>true</code> if the provided index datatype is a valid value; otherwise, <code>false</code>.\n *\n * @example\n * if (!Cesium.IndexDatatype.validate(indexDatatype)) {\n *   throw new Cesium.DeveloperError('indexDatatype must be a valid value.');\n * }\n */\nIndexDatatype.validate = function (indexDatatype) {\n  return (\n    defined(indexDatatype) &&\n    (indexDatatype === IndexDatatype.UNSIGNED_BYTE ||\n      indexDatatype === IndexDatatype.UNSIGNED_SHORT ||\n      indexDatatype === IndexDatatype.UNSIGNED_INT)\n  );\n};\n\n/**\n * Creates a typed array that will store indices, using either <code><Uint16Array</code>\n * or <code>Uint32Array</code> depending on the number of vertices.\n *\n * @param {Number} numberOfVertices Number of vertices that the indices will reference.\n * @param {Number|Array} indicesLengthOrArray Passed through to the typed array constructor.\n * @returns {Uint16Array|Uint32Array} A <code>Uint16Array</code> or <code>Uint32Array</code> constructed with <code>indicesLengthOrArray</code>.\n *\n * @example\n * this.indices = Cesium.IndexDatatype.createTypedArray(positions.length / 3, numberOfIndices);\n */\nIndexDatatype.createTypedArray = function (\n  numberOfVertices,\n  indicesLengthOrArray\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(numberOfVertices)) {\n    throw new DeveloperError(\"numberOfVertices is required.\");\n  }\n  //>>includeEnd('debug');\n\n  if (numberOfVertices >= CesiumMath.SIXTY_FOUR_KILOBYTES) {\n    return new Uint32Array(indicesLengthOrArray);\n  }\n\n  return new Uint16Array(indicesLengthOrArray);\n};\n\n/**\n * Creates a typed array from a source array buffer.  The resulting typed array will store indices, using either <code><Uint16Array</code>\n * or <code>Uint32Array</code> depending on the number of vertices.\n *\n * @param {Number} numberOfVertices Number of vertices that the indices will reference.\n * @param {ArrayBuffer} sourceArray Passed through to the typed array constructor.\n * @param {Number} byteOffset Passed through to the typed array constructor.\n * @param {Number} length Passed through to the typed array constructor.\n * @returns {Uint16Array|Uint32Array} A <code>Uint16Array</code> or <code>Uint32Array</code> constructed with <code>sourceArray</code>, <code>byteOffset</code>, and <code>length</code>.\n *\n */\nIndexDatatype.createTypedArrayFromArrayBuffer = function (\n  numberOfVertices,\n  sourceArray,\n  byteOffset,\n  length\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(numberOfVertices)) {\n    throw new DeveloperError(\"numberOfVertices is required.\");\n  }\n  if (!defined(sourceArray)) {\n    throw new DeveloperError(\"sourceArray is required.\");\n  }\n  if (!defined(byteOffset)) {\n    throw new DeveloperError(\"byteOffset is required.\");\n  }\n  //>>includeEnd('debug');\n\n  if (numberOfVertices >= CesiumMath.SIXTY_FOUR_KILOBYTES) {\n    return new Uint32Array(sourceArray, byteOffset, length);\n  }\n\n  return new Uint16Array(sourceArray, byteOffset, length);\n};\nexport default Object.freeze(IndexDatatype);\n"],"names":["IndexDatatype","UNSIGNED_BYTE","WebGLConstants","UNSIGNED_SHORT","UNSIGNED_INT","indexDatatype","Uint8Array","BYTES_PER_ELEMENT","Uint16Array","Uint32Array","DeveloperError","sizeInBytes","defined","numberOfVertices","indicesLengthOrArray","CesiumMath","SIXTY_FOUR_KILOBYTES","sourceArray","byteOffset","length","Object","freeze"],"mappings":"4JAWA,IAAIA,EAAgB,CAQlBC,cAAeC,iBAAeD,cAS9BE,eAAgBD,iBAAeC,eAS/BC,aAAcF,iBAAeE,aAa/BJ,eAA+B,SAAUK,GACvC,OAAQA,GACN,KAAKL,EAAcC,cACjB,OAAOK,WAAWC,kBACpB,KAAKP,EAAcG,eACjB,OAAOK,YAAYD,kBACrB,KAAKP,EAAcI,aACjB,OAAOK,YAAYF,kBAIvB,MAAM,IAAIG,iBACR,0EAWJV,gBAAgC,SAAUW,GACxC,OAAQA,GACN,KAAK,EACH,OAAOX,EAAcG,eACvB,KAAK,EACH,OAAOH,EAAcI,aACvB,KAAK,EACH,OAAOJ,EAAcC,cAEvB,QACE,MAAM,IAAIS,iBACR,wDAiBRV,SAAyB,SAAUK,GACjC,OACEO,UAAQP,KACPA,IAAkBL,EAAcC,eAC/BI,IAAkBL,EAAcG,gBAChCE,IAAkBL,EAAcI,eAetCJ,iBAAiC,SAC/Ba,EACAC,GAGA,IAAKF,UAAQC,GACX,MAAM,IAAIH,iBAAe,iCAI3B,OAAIG,GAAoBE,aAAWC,qBAC1B,IAAIP,YAAYK,GAGlB,IAAIN,YAAYM,IAczBd,gCAAgD,SAC9Ca,EACAI,EACAC,EACAC,GAGA,IAAKP,UAAQC,GACX,MAAM,IAAIH,iBAAe,iCAE3B,IAAKE,UAAQK,GACX,MAAM,IAAIP,iBAAe,4BAE3B,IAAKE,UAAQM,GACX,MAAM,IAAIR,iBAAe,2BAI3B,OAAIG,GAAoBE,aAAWC,qBAC1B,IAAIP,YAAYQ,EAAaC,EAAYC,GAG3C,IAAIX,YAAYS,EAAaC,EAAYC,OAEnCC,OAAOC,OAAOrB"}