{"version":3,"file":"OrientedBoundingBox-79e3c3fe.js","sources":["../../../../Source/Core/OrientedBoundingBox.js"],"sourcesContent":["import BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian2 from \"./Cartesian2.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Cartographic from \"./Cartographic.js\";\nimport Check from \"./Check.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport EllipsoidTangentPlane from \"./EllipsoidTangentPlane.js\";\nimport Intersect from \"./Intersect.js\";\nimport Interval from \"./Interval.js\";\nimport CesiumMath from \"./Math.js\";\nimport Matrix3 from \"./Matrix3.js\";\nimport Plane from \"./Plane.js\";\nimport Rectangle from \"./Rectangle.js\";\n\n/**\n * Creates an instance of an OrientedBoundingBox.\n * An OrientedBoundingBox of some object is a closed and convex cuboid. It can provide a tighter bounding volume than {@link BoundingSphere} or {@link AxisAlignedBoundingBox} in many cases.\n * @alias OrientedBoundingBox\n * @constructor\n *\n * @param {Cartesian3} [center=Cartesian3.ZERO] The center of the box.\n * @param {Matrix3} [halfAxes=Matrix3.ZERO] The three orthogonal half-axes of the bounding box.\n *                                          Equivalently, the transformation matrix, to rotate and scale a 0x0x0\n *                                          cube centered at the origin.\n *\n *\n * @example\n * // Create an OrientedBoundingBox using a transformation matrix, a position where the box will be translated, and a scale.\n * var center = new Cesium.Cartesian3(1.0, 0.0, 0.0);\n * var halfAxes = Cesium.Matrix3.fromScale(new Cesium.Cartesian3(1.0, 3.0, 2.0), new Cesium.Matrix3());\n *\n * var obb = new Cesium.OrientedBoundingBox(center, halfAxes);\n *\n * @see BoundingSphere\n * @see BoundingRectangle\n */\nfunction OrientedBoundingBox(center, halfAxes) {\n  /**\n   * The center of the box.\n   * @type {Cartesian3}\n   * @default {@link Cartesian3.ZERO}\n   */\n  this.center = Cartesian3.clone(defaultValue(center, Cartesian3.ZERO));\n  /**\n   * The transformation matrix, to rotate the box to the right position.\n   * @type {Matrix3}\n   * @default {@link Matrix3.ZERO}\n   */\n  this.halfAxes = Matrix3.clone(defaultValue(halfAxes, Matrix3.ZERO));\n}\n\n/**\n * The number of elements used to pack the object into an array.\n * @type {Number}\n */\nOrientedBoundingBox.packedLength =\n  Cartesian3.packedLength + Matrix3.packedLength;\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {OrientedBoundingBox} value The value to pack.\n * @param {Number[]} array The array to pack into.\n * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {Number[]} The array that was packed into\n */\nOrientedBoundingBox.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"value\", value);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  Cartesian3.pack(value.center, array, startingIndex);\n  Matrix3.pack(value.halfAxes, array, startingIndex + Cartesian3.packedLength);\n\n  return array;\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {Number[]} array The packed array.\n * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {OrientedBoundingBox} [result] The object into which to store the result.\n * @returns {OrientedBoundingBox} The modified result parameter or a new OrientedBoundingBox instance if one was not provided.\n */\nOrientedBoundingBox.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  if (!defined(result)) {\n    result = new OrientedBoundingBox();\n  }\n\n  Cartesian3.unpack(array, startingIndex, result.center);\n  Matrix3.unpack(\n    array,\n    startingIndex + Cartesian3.packedLength,\n    result.halfAxes\n  );\n  return result;\n};\n\nvar scratchCartesian1 = new Cartesian3();\nvar scratchCartesian2 = new Cartesian3();\nvar scratchCartesian3 = new Cartesian3();\nvar scratchCartesian4 = new Cartesian3();\nvar scratchCartesian5 = new Cartesian3();\nvar scratchCartesian6 = new Cartesian3();\nvar scratchCovarianceResult = new Matrix3();\nvar scratchEigenResult = {\n  unitary: new Matrix3(),\n  diagonal: new Matrix3(),\n};\n\n/**\n * Computes an instance of an OrientedBoundingBox of the given positions.\n * This is an implementation of Stefan Gottschalk's Collision Queries using Oriented Bounding Boxes solution (PHD thesis).\n * Reference: http://gamma.cs.unc.edu/users/gottschalk/main.pdf\n *\n * @param {Cartesian3[]} [positions] List of {@link Cartesian3} points that the bounding box will enclose.\n * @param {OrientedBoundingBox} [result] The object onto which to store the result.\n * @returns {OrientedBoundingBox} The modified result parameter or a new OrientedBoundingBox instance if one was not provided.\n *\n * @example\n * // Compute an object oriented bounding box enclosing two points.\n * var box = Cesium.OrientedBoundingBox.fromPoints([new Cesium.Cartesian3(2, 0, 0), new Cesium.Cartesian3(-2, 0, 0)]);\n */\nOrientedBoundingBox.fromPoints = function (positions, result) {\n  if (!defined(result)) {\n    result = new OrientedBoundingBox();\n  }\n\n  if (!defined(positions) || positions.length === 0) {\n    result.halfAxes = Matrix3.ZERO;\n    result.center = Cartesian3.ZERO;\n    return result;\n  }\n\n  var i;\n  var length = positions.length;\n\n  var meanPoint = Cartesian3.clone(positions[0], scratchCartesian1);\n  for (i = 1; i < length; i++) {\n    Cartesian3.add(meanPoint, positions[i], meanPoint);\n  }\n  var invLength = 1.0 / length;\n  Cartesian3.multiplyByScalar(meanPoint, invLength, meanPoint);\n\n  var exx = 0.0;\n  var exy = 0.0;\n  var exz = 0.0;\n  var eyy = 0.0;\n  var eyz = 0.0;\n  var ezz = 0.0;\n  var p;\n\n  for (i = 0; i < length; i++) {\n    p = Cartesian3.subtract(positions[i], meanPoint, scratchCartesian2);\n    exx += p.x * p.x;\n    exy += p.x * p.y;\n    exz += p.x * p.z;\n    eyy += p.y * p.y;\n    eyz += p.y * p.z;\n    ezz += p.z * p.z;\n  }\n\n  exx *= invLength;\n  exy *= invLength;\n  exz *= invLength;\n  eyy *= invLength;\n  eyz *= invLength;\n  ezz *= invLength;\n\n  var covarianceMatrix = scratchCovarianceResult;\n  covarianceMatrix[0] = exx;\n  covarianceMatrix[1] = exy;\n  covarianceMatrix[2] = exz;\n  covarianceMatrix[3] = exy;\n  covarianceMatrix[4] = eyy;\n  covarianceMatrix[5] = eyz;\n  covarianceMatrix[6] = exz;\n  covarianceMatrix[7] = eyz;\n  covarianceMatrix[8] = ezz;\n\n  var eigenDecomposition = Matrix3.computeEigenDecomposition(\n    covarianceMatrix,\n    scratchEigenResult\n  );\n  var rotation = Matrix3.clone(eigenDecomposition.unitary, result.halfAxes);\n\n  var v1 = Matrix3.getColumn(rotation, 0, scratchCartesian4);\n  var v2 = Matrix3.getColumn(rotation, 1, scratchCartesian5);\n  var v3 = Matrix3.getColumn(rotation, 2, scratchCartesian6);\n\n  var u1 = -Number.MAX_VALUE;\n  var u2 = -Number.MAX_VALUE;\n  var u3 = -Number.MAX_VALUE;\n  var l1 = Number.MAX_VALUE;\n  var l2 = Number.MAX_VALUE;\n  var l3 = Number.MAX_VALUE;\n\n  for (i = 0; i < length; i++) {\n    p = positions[i];\n    u1 = Math.max(Cartesian3.dot(v1, p), u1);\n    u2 = Math.max(Cartesian3.dot(v2, p), u2);\n    u3 = Math.max(Cartesian3.dot(v3, p), u3);\n\n    l1 = Math.min(Cartesian3.dot(v1, p), l1);\n    l2 = Math.min(Cartesian3.dot(v2, p), l2);\n    l3 = Math.min(Cartesian3.dot(v3, p), l3);\n  }\n\n  v1 = Cartesian3.multiplyByScalar(v1, 0.5 * (l1 + u1), v1);\n  v2 = Cartesian3.multiplyByScalar(v2, 0.5 * (l2 + u2), v2);\n  v3 = Cartesian3.multiplyByScalar(v3, 0.5 * (l3 + u3), v3);\n\n  var center = Cartesian3.add(v1, v2, result.center);\n  Cartesian3.add(center, v3, center);\n\n  var scale = scratchCartesian3;\n  scale.x = u1 - l1;\n  scale.y = u2 - l2;\n  scale.z = u3 - l3;\n  Cartesian3.multiplyByScalar(scale, 0.5, scale);\n  Matrix3.multiplyByScale(result.halfAxes, scale, result.halfAxes);\n\n  return result;\n};\n\nvar scratchOffset = new Cartesian3();\nvar scratchScale = new Cartesian3();\nfunction fromPlaneExtents(\n  planeOrigin,\n  planeXAxis,\n  planeYAxis,\n  planeZAxis,\n  minimumX,\n  maximumX,\n  minimumY,\n  maximumY,\n  minimumZ,\n  maximumZ,\n  result\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (\n    !defined(minimumX) ||\n    !defined(maximumX) ||\n    !defined(minimumY) ||\n    !defined(maximumY) ||\n    !defined(minimumZ) ||\n    !defined(maximumZ)\n  ) {\n    throw new DeveloperError(\n      \"all extents (minimum/maximum X/Y/Z) are required.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new OrientedBoundingBox();\n  }\n\n  var halfAxes = result.halfAxes;\n  Matrix3.setColumn(halfAxes, 0, planeXAxis, halfAxes);\n  Matrix3.setColumn(halfAxes, 1, planeYAxis, halfAxes);\n  Matrix3.setColumn(halfAxes, 2, planeZAxis, halfAxes);\n\n  var centerOffset = scratchOffset;\n  centerOffset.x = (minimumX + maximumX) / 2.0;\n  centerOffset.y = (minimumY + maximumY) / 2.0;\n  centerOffset.z = (minimumZ + maximumZ) / 2.0;\n\n  var scale = scratchScale;\n  scale.x = (maximumX - minimumX) / 2.0;\n  scale.y = (maximumY - minimumY) / 2.0;\n  scale.z = (maximumZ - minimumZ) / 2.0;\n\n  var center = result.center;\n  centerOffset = Matrix3.multiplyByVector(halfAxes, centerOffset, centerOffset);\n  Cartesian3.add(planeOrigin, centerOffset, center);\n  Matrix3.multiplyByScale(halfAxes, scale, halfAxes);\n\n  return result;\n}\n\nvar scratchRectangleCenterCartographic = new Cartographic();\nvar scratchRectangleCenter = new Cartesian3();\nvar scratchPerimeterCartographicNC = new Cartographic();\nvar scratchPerimeterCartographicNW = new Cartographic();\nvar scratchPerimeterCartographicCW = new Cartographic();\nvar scratchPerimeterCartographicSW = new Cartographic();\nvar scratchPerimeterCartographicSC = new Cartographic();\nvar scratchPerimeterCartesianNC = new Cartesian3();\nvar scratchPerimeterCartesianNW = new Cartesian3();\nvar scratchPerimeterCartesianCW = new Cartesian3();\nvar scratchPerimeterCartesianSW = new Cartesian3();\nvar scratchPerimeterCartesianSC = new Cartesian3();\nvar scratchPerimeterProjectedNC = new Cartesian2();\nvar scratchPerimeterProjectedNW = new Cartesian2();\nvar scratchPerimeterProjectedCW = new Cartesian2();\nvar scratchPerimeterProjectedSW = new Cartesian2();\nvar scratchPerimeterProjectedSC = new Cartesian2();\n\nvar scratchPlaneOrigin = new Cartesian3();\nvar scratchPlaneNormal = new Cartesian3();\nvar scratchPlaneXAxis = new Cartesian3();\nvar scratchHorizonCartesian = new Cartesian3();\nvar scratchHorizonProjected = new Cartesian2();\nvar scratchMaxY = new Cartesian3();\nvar scratchMinY = new Cartesian3();\nvar scratchZ = new Cartesian3();\nvar scratchPlane = new Plane(Cartesian3.UNIT_X, 0.0);\n\n/**\n * Computes an OrientedBoundingBox that bounds a {@link Rectangle} on the surface of an {@link Ellipsoid}.\n * There are no guarantees about the orientation of the bounding box.\n *\n * @param {Rectangle} rectangle The cartographic rectangle on the surface of the ellipsoid.\n * @param {Number} [minimumHeight=0.0] The minimum height (elevation) within the tile.\n * @param {Number} [maximumHeight=0.0] The maximum height (elevation) within the tile.\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the rectangle is defined.\n * @param {OrientedBoundingBox} [result] The object onto which to store the result.\n * @returns {OrientedBoundingBox} The modified result parameter or a new OrientedBoundingBox instance if none was provided.\n *\n * @exception {DeveloperError} rectangle.width must be between 0 and pi.\n * @exception {DeveloperError} rectangle.height must be between 0 and pi.\n * @exception {DeveloperError} ellipsoid must be an ellipsoid of revolution (<code>radii.x == radii.y</code>)\n */\nOrientedBoundingBox.fromRectangle = function (\n  rectangle,\n  minimumHeight,\n  maximumHeight,\n  ellipsoid,\n  result\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(rectangle)) {\n    throw new DeveloperError(\"rectangle is required\");\n  }\n  if (rectangle.width < 0.0 || rectangle.width > CesiumMath.TWO_PI) {\n    throw new DeveloperError(\"Rectangle width must be between 0 and 2*pi\");\n  }\n  if (rectangle.height < 0.0 || rectangle.height > CesiumMath.PI) {\n    throw new DeveloperError(\"Rectangle height must be between 0 and pi\");\n  }\n  if (\n    defined(ellipsoid) &&\n    !CesiumMath.equalsEpsilon(\n      ellipsoid.radii.x,\n      ellipsoid.radii.y,\n      CesiumMath.EPSILON15\n    )\n  ) {\n    throw new DeveloperError(\n      \"Ellipsoid must be an ellipsoid of revolution (radii.x == radii.y)\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  minimumHeight = defaultValue(minimumHeight, 0.0);\n  maximumHeight = defaultValue(maximumHeight, 0.0);\n  ellipsoid = defaultValue(ellipsoid, Ellipsoid.WGS84);\n\n  var minX, maxX, minY, maxY, minZ, maxZ, plane;\n\n  if (rectangle.width <= CesiumMath.PI) {\n    // The bounding box will be aligned with the tangent plane at the center of the rectangle.\n    var tangentPointCartographic = Rectangle.center(\n      rectangle,\n      scratchRectangleCenterCartographic\n    );\n    var tangentPoint = ellipsoid.cartographicToCartesian(\n      tangentPointCartographic,\n      scratchRectangleCenter\n    );\n    var tangentPlane = new EllipsoidTangentPlane(tangentPoint, ellipsoid);\n    plane = tangentPlane.plane;\n\n    // If the rectangle spans the equator, CW is instead aligned with the equator (because it sticks out the farthest at the equator).\n    var lonCenter = tangentPointCartographic.longitude;\n    var latCenter =\n      rectangle.south < 0.0 && rectangle.north > 0.0\n        ? 0.0\n        : tangentPointCartographic.latitude;\n\n    // Compute XY extents using the rectangle at maximum height\n    var perimeterCartographicNC = Cartographic.fromRadians(\n      lonCenter,\n      rectangle.north,\n      maximumHeight,\n      scratchPerimeterCartographicNC\n    );\n    var perimeterCartographicNW = Cartographic.fromRadians(\n      rectangle.west,\n      rectangle.north,\n      maximumHeight,\n      scratchPerimeterCartographicNW\n    );\n    var perimeterCartographicCW = Cartographic.fromRadians(\n      rectangle.west,\n      latCenter,\n      maximumHeight,\n      scratchPerimeterCartographicCW\n    );\n    var perimeterCartographicSW = Cartographic.fromRadians(\n      rectangle.west,\n      rectangle.south,\n      maximumHeight,\n      scratchPerimeterCartographicSW\n    );\n    var perimeterCartographicSC = Cartographic.fromRadians(\n      lonCenter,\n      rectangle.south,\n      maximumHeight,\n      scratchPerimeterCartographicSC\n    );\n\n    var perimeterCartesianNC = ellipsoid.cartographicToCartesian(\n      perimeterCartographicNC,\n      scratchPerimeterCartesianNC\n    );\n    var perimeterCartesianNW = ellipsoid.cartographicToCartesian(\n      perimeterCartographicNW,\n      scratchPerimeterCartesianNW\n    );\n    var perimeterCartesianCW = ellipsoid.cartographicToCartesian(\n      perimeterCartographicCW,\n      scratchPerimeterCartesianCW\n    );\n    var perimeterCartesianSW = ellipsoid.cartographicToCartesian(\n      perimeterCartographicSW,\n      scratchPerimeterCartesianSW\n    );\n    var perimeterCartesianSC = ellipsoid.cartographicToCartesian(\n      perimeterCartographicSC,\n      scratchPerimeterCartesianSC\n    );\n\n    var perimeterProjectedNC = tangentPlane.projectPointToNearestOnPlane(\n      perimeterCartesianNC,\n      scratchPerimeterProjectedNC\n    );\n    var perimeterProjectedNW = tangentPlane.projectPointToNearestOnPlane(\n      perimeterCartesianNW,\n      scratchPerimeterProjectedNW\n    );\n    var perimeterProjectedCW = tangentPlane.projectPointToNearestOnPlane(\n      perimeterCartesianCW,\n      scratchPerimeterProjectedCW\n    );\n    var perimeterProjectedSW = tangentPlane.projectPointToNearestOnPlane(\n      perimeterCartesianSW,\n      scratchPerimeterProjectedSW\n    );\n    var perimeterProjectedSC = tangentPlane.projectPointToNearestOnPlane(\n      perimeterCartesianSC,\n      scratchPerimeterProjectedSC\n    );\n\n    minX = Math.min(\n      perimeterProjectedNW.x,\n      perimeterProjectedCW.x,\n      perimeterProjectedSW.x\n    );\n    maxX = -minX; // symmetrical\n\n    maxY = Math.max(perimeterProjectedNW.y, perimeterProjectedNC.y);\n    minY = Math.min(perimeterProjectedSW.y, perimeterProjectedSC.y);\n\n    // Compute minimum Z using the rectangle at minimum height, since it will be deeper than the maximum height\n    perimeterCartographicNW.height = perimeterCartographicSW.height = minimumHeight;\n    perimeterCartesianNW = ellipsoid.cartographicToCartesian(\n      perimeterCartographicNW,\n      scratchPerimeterCartesianNW\n    );\n    perimeterCartesianSW = ellipsoid.cartographicToCartesian(\n      perimeterCartographicSW,\n      scratchPerimeterCartesianSW\n    );\n\n    minZ = Math.min(\n      Plane.getPointDistance(plane, perimeterCartesianNW),\n      Plane.getPointDistance(plane, perimeterCartesianSW)\n    );\n    maxZ = maximumHeight; // Since the tangent plane touches the surface at height = 0, this is okay\n\n    return fromPlaneExtents(\n      tangentPlane.origin,\n      tangentPlane.xAxis,\n      tangentPlane.yAxis,\n      tangentPlane.zAxis,\n      minX,\n      maxX,\n      minY,\n      maxY,\n      minZ,\n      maxZ,\n      result\n    );\n  }\n\n  // Handle the case where rectangle width is greater than PI (wraps around more than half the ellipsoid).\n  var fullyAboveEquator = rectangle.south > 0.0;\n  var fullyBelowEquator = rectangle.north < 0.0;\n  var latitudeNearestToEquator = fullyAboveEquator\n    ? rectangle.south\n    : fullyBelowEquator\n    ? rectangle.north\n    : 0.0;\n  var centerLongitude = Rectangle.center(\n    rectangle,\n    scratchRectangleCenterCartographic\n  ).longitude;\n\n  // Plane is located at the rectangle's center longitude and the rectangle's latitude that is closest to the equator. It rotates around the Z axis.\n  // This results in a better fit than the obb approach for smaller rectangles, which orients with the rectangle's center normal.\n  var planeOrigin = Cartesian3.fromRadians(\n    centerLongitude,\n    latitudeNearestToEquator,\n    maximumHeight,\n    ellipsoid,\n    scratchPlaneOrigin\n  );\n  planeOrigin.z = 0.0; // center the plane on the equator to simpify plane normal calculation\n  var isPole =\n    Math.abs(planeOrigin.x) < CesiumMath.EPSILON10 &&\n    Math.abs(planeOrigin.y) < CesiumMath.EPSILON10;\n  var planeNormal = !isPole\n    ? Cartesian3.normalize(planeOrigin, scratchPlaneNormal)\n    : Cartesian3.UNIT_X;\n  var planeYAxis = Cartesian3.UNIT_Z;\n  var planeXAxis = Cartesian3.cross(planeNormal, planeYAxis, scratchPlaneXAxis);\n  plane = Plane.fromPointNormal(planeOrigin, planeNormal, scratchPlane);\n\n  // Get the horizon point relative to the center. This will be the farthest extent in the plane's X dimension.\n  var horizonCartesian = Cartesian3.fromRadians(\n    centerLongitude + CesiumMath.PI_OVER_TWO,\n    latitudeNearestToEquator,\n    maximumHeight,\n    ellipsoid,\n    scratchHorizonCartesian\n  );\n  maxX = Cartesian3.dot(\n    Plane.projectPointOntoPlane(\n      plane,\n      horizonCartesian,\n      scratchHorizonProjected\n    ),\n    planeXAxis\n  );\n  minX = -maxX; // symmetrical\n\n  // Get the min and max Y, using the height that will give the largest extent\n  maxY = Cartesian3.fromRadians(\n    0.0,\n    rectangle.north,\n    fullyBelowEquator ? minimumHeight : maximumHeight,\n    ellipsoid,\n    scratchMaxY\n  ).z;\n  minY = Cartesian3.fromRadians(\n    0.0,\n    rectangle.south,\n    fullyAboveEquator ? minimumHeight : maximumHeight,\n    ellipsoid,\n    scratchMinY\n  ).z;\n\n  var farZ = Cartesian3.fromRadians(\n    rectangle.east,\n    latitudeNearestToEquator,\n    maximumHeight,\n    ellipsoid,\n    scratchZ\n  );\n  minZ = Plane.getPointDistance(plane, farZ);\n  maxZ = 0.0; // plane origin starts at maxZ already\n\n  // min and max are local to the plane axes\n  return fromPlaneExtents(\n    planeOrigin,\n    planeXAxis,\n    planeYAxis,\n    planeNormal,\n    minX,\n    maxX,\n    minY,\n    maxY,\n    minZ,\n    maxZ,\n    result\n  );\n};\n\n/**\n * Duplicates a OrientedBoundingBox instance.\n *\n * @param {OrientedBoundingBox} box The bounding box to duplicate.\n * @param {OrientedBoundingBox} [result] The object onto which to store the result.\n * @returns {OrientedBoundingBox} The modified result parameter or a new OrientedBoundingBox instance if none was provided. (Returns undefined if box is undefined)\n */\nOrientedBoundingBox.clone = function (box, result) {\n  if (!defined(box)) {\n    return undefined;\n  }\n\n  if (!defined(result)) {\n    return new OrientedBoundingBox(box.center, box.halfAxes);\n  }\n\n  Cartesian3.clone(box.center, result.center);\n  Matrix3.clone(box.halfAxes, result.halfAxes);\n\n  return result;\n};\n\n/**\n * Determines which side of a plane the oriented bounding box is located.\n *\n * @param {OrientedBoundingBox} box The oriented bounding box to test.\n * @param {Plane} plane The plane to test against.\n * @returns {Intersect} {@link Intersect.INSIDE} if the entire box is on the side of the plane\n *                      the normal is pointing, {@link Intersect.OUTSIDE} if the entire box is\n *                      on the opposite side, and {@link Intersect.INTERSECTING} if the box\n *                      intersects the plane.\n */\nOrientedBoundingBox.intersectPlane = function (box, plane) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(box)) {\n    throw new DeveloperError(\"box is required.\");\n  }\n\n  if (!defined(plane)) {\n    throw new DeveloperError(\"plane is required.\");\n  }\n  //>>includeEnd('debug');\n\n  var center = box.center;\n  var normal = plane.normal;\n  var halfAxes = box.halfAxes;\n  var normalX = normal.x,\n    normalY = normal.y,\n    normalZ = normal.z;\n  // plane is used as if it is its normal; the first three components are assumed to be normalized\n  var radEffective =\n    Math.abs(\n      normalX * halfAxes[Matrix3.COLUMN0ROW0] +\n        normalY * halfAxes[Matrix3.COLUMN0ROW1] +\n        normalZ * halfAxes[Matrix3.COLUMN0ROW2]\n    ) +\n    Math.abs(\n      normalX * halfAxes[Matrix3.COLUMN1ROW0] +\n        normalY * halfAxes[Matrix3.COLUMN1ROW1] +\n        normalZ * halfAxes[Matrix3.COLUMN1ROW2]\n    ) +\n    Math.abs(\n      normalX * halfAxes[Matrix3.COLUMN2ROW0] +\n        normalY * halfAxes[Matrix3.COLUMN2ROW1] +\n        normalZ * halfAxes[Matrix3.COLUMN2ROW2]\n    );\n  var distanceToPlane = Cartesian3.dot(normal, center) + plane.distance;\n\n  if (distanceToPlane <= -radEffective) {\n    // The entire box is on the negative side of the plane normal\n    return Intersect.OUTSIDE;\n  } else if (distanceToPlane >= radEffective) {\n    // The entire box is on the positive side of the plane normal\n    return Intersect.INSIDE;\n  }\n  return Intersect.INTERSECTING;\n};\n\nvar scratchCartesianU = new Cartesian3();\nvar scratchCartesianV = new Cartesian3();\nvar scratchCartesianW = new Cartesian3();\nvar scratchValidAxis2 = new Cartesian3();\nvar scratchValidAxis3 = new Cartesian3();\nvar scratchPPrime = new Cartesian3();\n\n/**\n * Computes the estimated distance squared from the closest point on a bounding box to a point.\n *\n * @param {OrientedBoundingBox} box The box.\n * @param {Cartesian3} cartesian The point\n * @returns {Number} The distance squared from the oriented bounding box to the point. Returns 0 if the point is inside the box.\n *\n * @example\n * // Sort bounding boxes from back to front\n * boxes.sort(function(a, b) {\n *     return Cesium.OrientedBoundingBox.distanceSquaredTo(b, camera.positionWC) - Cesium.OrientedBoundingBox.distanceSquaredTo(a, camera.positionWC);\n * });\n */\nOrientedBoundingBox.distanceSquaredTo = function (box, cartesian) {\n  // See Geometric Tools for Computer Graphics 10.4.2\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(box)) {\n    throw new DeveloperError(\"box is required.\");\n  }\n  if (!defined(cartesian)) {\n    throw new DeveloperError(\"cartesian is required.\");\n  }\n  //>>includeEnd('debug');\n\n  var offset = Cartesian3.subtract(cartesian, box.center, scratchOffset);\n\n  var halfAxes = box.halfAxes;\n  var u = Matrix3.getColumn(halfAxes, 0, scratchCartesianU);\n  var v = Matrix3.getColumn(halfAxes, 1, scratchCartesianV);\n  var w = Matrix3.getColumn(halfAxes, 2, scratchCartesianW);\n\n  var uHalf = Cartesian3.magnitude(u);\n  var vHalf = Cartesian3.magnitude(v);\n  var wHalf = Cartesian3.magnitude(w);\n\n  var uValid = true;\n  var vValid = true;\n  var wValid = true;\n\n  if (uHalf > 0) {\n    Cartesian3.divideByScalar(u, uHalf, u);\n  } else {\n    uValid = false;\n  }\n\n  if (vHalf > 0) {\n    Cartesian3.divideByScalar(v, vHalf, v);\n  } else {\n    vValid = false;\n  }\n\n  if (wHalf > 0) {\n    Cartesian3.divideByScalar(w, wHalf, w);\n  } else {\n    wValid = false;\n  }\n\n  var numberOfDegenerateAxes = !uValid + !vValid + !wValid;\n  var validAxis1;\n  var validAxis2;\n  var validAxis3;\n\n  if (numberOfDegenerateAxes === 1) {\n    var degenerateAxis = u;\n    validAxis1 = v;\n    validAxis2 = w;\n    if (!vValid) {\n      degenerateAxis = v;\n      validAxis1 = u;\n    } else if (!wValid) {\n      degenerateAxis = w;\n      validAxis2 = u;\n    }\n\n    validAxis3 = Cartesian3.cross(validAxis1, validAxis2, scratchValidAxis3);\n\n    if (degenerateAxis === u) {\n      u = validAxis3;\n    } else if (degenerateAxis === v) {\n      v = validAxis3;\n    } else if (degenerateAxis === w) {\n      w = validAxis3;\n    }\n  } else if (numberOfDegenerateAxes === 2) {\n    validAxis1 = u;\n    if (vValid) {\n      validAxis1 = v;\n    } else if (wValid) {\n      validAxis1 = w;\n    }\n\n    var crossVector = Cartesian3.UNIT_Y;\n    if (crossVector.equalsEpsilon(validAxis1, CesiumMath.EPSILON3)) {\n      crossVector = Cartesian3.UNIT_X;\n    }\n\n    validAxis2 = Cartesian3.cross(validAxis1, crossVector, scratchValidAxis2);\n    Cartesian3.normalize(validAxis2, validAxis2);\n    validAxis3 = Cartesian3.cross(validAxis1, validAxis2, scratchValidAxis3);\n    Cartesian3.normalize(validAxis3, validAxis3);\n\n    if (validAxis1 === u) {\n      v = validAxis2;\n      w = validAxis3;\n    } else if (validAxis1 === v) {\n      w = validAxis2;\n      u = validAxis3;\n    } else if (validAxis1 === w) {\n      u = validAxis2;\n      v = validAxis3;\n    }\n  } else if (numberOfDegenerateAxes === 3) {\n    u = Cartesian3.UNIT_X;\n    v = Cartesian3.UNIT_Y;\n    w = Cartesian3.UNIT_Z;\n  }\n\n  var pPrime = scratchPPrime;\n  pPrime.x = Cartesian3.dot(offset, u);\n  pPrime.y = Cartesian3.dot(offset, v);\n  pPrime.z = Cartesian3.dot(offset, w);\n\n  var distanceSquared = 0.0;\n  var d;\n\n  if (pPrime.x < -uHalf) {\n    d = pPrime.x + uHalf;\n    distanceSquared += d * d;\n  } else if (pPrime.x > uHalf) {\n    d = pPrime.x - uHalf;\n    distanceSquared += d * d;\n  }\n\n  if (pPrime.y < -vHalf) {\n    d = pPrime.y + vHalf;\n    distanceSquared += d * d;\n  } else if (pPrime.y > vHalf) {\n    d = pPrime.y - vHalf;\n    distanceSquared += d * d;\n  }\n\n  if (pPrime.z < -wHalf) {\n    d = pPrime.z + wHalf;\n    distanceSquared += d * d;\n  } else if (pPrime.z > wHalf) {\n    d = pPrime.z - wHalf;\n    distanceSquared += d * d;\n  }\n\n  return distanceSquared;\n};\n\nvar scratchCorner = new Cartesian3();\nvar scratchToCenter = new Cartesian3();\n\n/**\n * The distances calculated by the vector from the center of the bounding box to position projected onto direction.\n * <br>\n * If you imagine the infinite number of planes with normal direction, this computes the smallest distance to the\n * closest and farthest planes from position that intersect the bounding box.\n *\n * @param {OrientedBoundingBox} box The bounding box to calculate the distance to.\n * @param {Cartesian3} position The position to calculate the distance from.\n * @param {Cartesian3} direction The direction from position.\n * @param {Interval} [result] A Interval to store the nearest and farthest distances.\n * @returns {Interval} The nearest and farthest distances on the bounding box from position in direction.\n */\nOrientedBoundingBox.computePlaneDistances = function (\n  box,\n  position,\n  direction,\n  result\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(box)) {\n    throw new DeveloperError(\"box is required.\");\n  }\n\n  if (!defined(position)) {\n    throw new DeveloperError(\"position is required.\");\n  }\n\n  if (!defined(direction)) {\n    throw new DeveloperError(\"direction is required.\");\n  }\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Interval();\n  }\n\n  var minDist = Number.POSITIVE_INFINITY;\n  var maxDist = Number.NEGATIVE_INFINITY;\n\n  var center = box.center;\n  var halfAxes = box.halfAxes;\n\n  var u = Matrix3.getColumn(halfAxes, 0, scratchCartesianU);\n  var v = Matrix3.getColumn(halfAxes, 1, scratchCartesianV);\n  var w = Matrix3.getColumn(halfAxes, 2, scratchCartesianW);\n\n  // project first corner\n  var corner = Cartesian3.add(u, v, scratchCorner);\n  Cartesian3.add(corner, w, corner);\n  Cartesian3.add(corner, center, corner);\n\n  var toCenter = Cartesian3.subtract(corner, position, scratchToCenter);\n  var mag = Cartesian3.dot(direction, toCenter);\n\n  minDist = Math.min(mag, minDist);\n  maxDist = Math.max(mag, maxDist);\n\n  // project second corner\n  Cartesian3.add(center, u, corner);\n  Cartesian3.add(corner, v, corner);\n  Cartesian3.subtract(corner, w, corner);\n\n  Cartesian3.subtract(corner, position, toCenter);\n  mag = Cartesian3.dot(direction, toCenter);\n\n  minDist = Math.min(mag, minDist);\n  maxDist = Math.max(mag, maxDist);\n\n  // project third corner\n  Cartesian3.add(center, u, corner);\n  Cartesian3.subtract(corner, v, corner);\n  Cartesian3.add(corner, w, corner);\n\n  Cartesian3.subtract(corner, position, toCenter);\n  mag = Cartesian3.dot(direction, toCenter);\n\n  minDist = Math.min(mag, minDist);\n  maxDist = Math.max(mag, maxDist);\n\n  // project fourth corner\n  Cartesian3.add(center, u, corner);\n  Cartesian3.subtract(corner, v, corner);\n  Cartesian3.subtract(corner, w, corner);\n\n  Cartesian3.subtract(corner, position, toCenter);\n  mag = Cartesian3.dot(direction, toCenter);\n\n  minDist = Math.min(mag, minDist);\n  maxDist = Math.max(mag, maxDist);\n\n  // project fifth corner\n  Cartesian3.subtract(center, u, corner);\n  Cartesian3.add(corner, v, corner);\n  Cartesian3.add(corner, w, corner);\n\n  Cartesian3.subtract(corner, position, toCenter);\n  mag = Cartesian3.dot(direction, toCenter);\n\n  minDist = Math.min(mag, minDist);\n  maxDist = Math.max(mag, maxDist);\n\n  // project sixth corner\n  Cartesian3.subtract(center, u, corner);\n  Cartesian3.add(corner, v, corner);\n  Cartesian3.subtract(corner, w, corner);\n\n  Cartesian3.subtract(corner, position, toCenter);\n  mag = Cartesian3.dot(direction, toCenter);\n\n  minDist = Math.min(mag, minDist);\n  maxDist = Math.max(mag, maxDist);\n\n  // project seventh corner\n  Cartesian3.subtract(center, u, corner);\n  Cartesian3.subtract(corner, v, corner);\n  Cartesian3.add(corner, w, corner);\n\n  Cartesian3.subtract(corner, position, toCenter);\n  mag = Cartesian3.dot(direction, toCenter);\n\n  minDist = Math.min(mag, minDist);\n  maxDist = Math.max(mag, maxDist);\n\n  // project eighth corner\n  Cartesian3.subtract(center, u, corner);\n  Cartesian3.subtract(corner, v, corner);\n  Cartesian3.subtract(corner, w, corner);\n\n  Cartesian3.subtract(corner, position, toCenter);\n  mag = Cartesian3.dot(direction, toCenter);\n\n  minDist = Math.min(mag, minDist);\n  maxDist = Math.max(mag, maxDist);\n\n  result.start = minDist;\n  result.stop = maxDist;\n  return result;\n};\n\nvar scratchBoundingSphere = new BoundingSphere();\n\n/**\n * Determines whether or not a bounding box is hidden from view by the occluder.\n *\n * @param {OrientedBoundingBox} box The bounding box surrounding the occludee object.\n * @param {Occluder} occluder The occluder.\n * @returns {Boolean} <code>true</code> if the box is not visible; otherwise <code>false</code>.\n */\nOrientedBoundingBox.isOccluded = function (box, occluder) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(box)) {\n    throw new DeveloperError(\"box is required.\");\n  }\n  if (!defined(occluder)) {\n    throw new DeveloperError(\"occluder is required.\");\n  }\n  //>>includeEnd('debug');\n\n  var sphere = BoundingSphere.fromOrientedBoundingBox(\n    box,\n    scratchBoundingSphere\n  );\n\n  return !occluder.isBoundingSphereVisible(sphere);\n};\n\n/**\n * Determines which side of a plane the oriented bounding box is located.\n *\n * @param {Plane} plane The plane to test against.\n * @returns {Intersect} {@link Intersect.INSIDE} if the entire box is on the side of the plane\n *                      the normal is pointing, {@link Intersect.OUTSIDE} if the entire box is\n *                      on the opposite side, and {@link Intersect.INTERSECTING} if the box\n *                      intersects the plane.\n */\nOrientedBoundingBox.prototype.intersectPlane = function (plane) {\n  return OrientedBoundingBox.intersectPlane(this, plane);\n};\n\n/**\n * Computes the estimated distance squared from the closest point on a bounding box to a point.\n *\n * @param {Cartesian3} cartesian The point\n * @returns {Number} The estimated distance squared from the bounding sphere to the point.\n *\n * @example\n * // Sort bounding boxes from back to front\n * boxes.sort(function(a, b) {\n *     return b.distanceSquaredTo(camera.positionWC) - a.distanceSquaredTo(camera.positionWC);\n * });\n */\nOrientedBoundingBox.prototype.distanceSquaredTo = function (cartesian) {\n  return OrientedBoundingBox.distanceSquaredTo(this, cartesian);\n};\n\n/**\n * The distances calculated by the vector from the center of the bounding box to position projected onto direction.\n * <br>\n * If you imagine the infinite number of planes with normal direction, this computes the smallest distance to the\n * closest and farthest planes from position that intersect the bounding box.\n *\n * @param {Cartesian3} position The position to calculate the distance from.\n * @param {Cartesian3} direction The direction from position.\n * @param {Interval} [result] A Interval to store the nearest and farthest distances.\n * @returns {Interval} The nearest and farthest distances on the bounding box from position in direction.\n */\nOrientedBoundingBox.prototype.computePlaneDistances = function (\n  position,\n  direction,\n  result\n) {\n  return OrientedBoundingBox.computePlaneDistances(\n    this,\n    position,\n    direction,\n    result\n  );\n};\n\n/**\n * Determines whether or not a bounding box is hidden from view by the occluder.\n *\n * @param {Occluder} occluder The occluder.\n * @returns {Boolean} <code>true</code> if the sphere is not visible; otherwise <code>false</code>.\n */\nOrientedBoundingBox.prototype.isOccluded = function (occluder) {\n  return OrientedBoundingBox.isOccluded(this, occluder);\n};\n\n/**\n * Compares the provided OrientedBoundingBox componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {OrientedBoundingBox} left The first OrientedBoundingBox.\n * @param {OrientedBoundingBox} right The second OrientedBoundingBox.\n * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n */\nOrientedBoundingBox.equals = function (left, right) {\n  return (\n    left === right ||\n    (defined(left) &&\n      defined(right) &&\n      Cartesian3.equals(left.center, right.center) &&\n      Matrix3.equals(left.halfAxes, right.halfAxes))\n  );\n};\n\n/**\n * Duplicates this OrientedBoundingBox instance.\n *\n * @param {OrientedBoundingBox} [result] The object onto which to store the result.\n * @returns {OrientedBoundingBox} The modified result parameter or a new OrientedBoundingBox instance if one was not provided.\n */\nOrientedBoundingBox.prototype.clone = function (result) {\n  return OrientedBoundingBox.clone(this, result);\n};\n\n/**\n * Compares this OrientedBoundingBox against the provided OrientedBoundingBox componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {OrientedBoundingBox} [right] The right hand side OrientedBoundingBox.\n * @returns {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.\n */\nOrientedBoundingBox.prototype.equals = function (right) {\n  return OrientedBoundingBox.equals(this, right);\n};\nexport default OrientedBoundingBox;\n"],"names":["OrientedBoundingBox","center","halfAxes","this","Cartesian3","clone","defaultValue","ZERO","Matrix3","packedLength","pack","value","array","startingIndex","Check","typeOf","object","defined","unpack","result","scratchCartesian1","scratchCartesian2","scratchCartesian3","scratchCartesian4","scratchCartesian5","scratchCartesian6","scratchCovarianceResult","scratchEigenResult","unitary","diagonal","fromPoints","positions","length","i","meanPoint","add","invLength","multiplyByScalar","p","exx","exy","exz","eyy","eyz","ezz","subtract","x","y","z","covarianceMatrix","eigenDecomposition","computeEigenDecomposition","rotation","v1","getColumn","v2","v3","u1","Number","MAX_VALUE","u2","u3","l1","l2","l3","Math","max","dot","min","scale","multiplyByScale","scratchOffset","scratchScale","fromPlaneExtents","planeOrigin","planeXAxis","planeYAxis","planeZAxis","minimumX","maximumX","minimumY","maximumY","minimumZ","maximumZ","DeveloperError","setColumn","centerOffset","multiplyByVector","scratchRectangleCenterCartographic","Cartographic","scratchRectangleCenter","scratchPerimeterCartographicNC","scratchPerimeterCartographicNW","scratchPerimeterCartographicCW","scratchPerimeterCartographicSW","scratchPerimeterCartographicSC","scratchPerimeterCartesianNC","scratchPerimeterCartesianNW","scratchPerimeterCartesianCW","scratchPerimeterCartesianSW","scratchPerimeterCartesianSC","scratchPerimeterProjectedNC","Cartesian2","scratchPerimeterProjectedNW","scratchPerimeterProjectedCW","scratchPerimeterProjectedSW","scratchPerimeterProjectedSC","scratchPlaneOrigin","scratchPlaneNormal","scratchPlaneXAxis","scratchHorizonCartesian","scratchHorizonProjected","scratchMaxY","scratchMinY","scratchZ","scratchPlane","Plane","UNIT_X","fromRectangle","rectangle","minimumHeight","maximumHeight","ellipsoid","width","CesiumMath","TWO_PI","height","PI","equalsEpsilon","radii","EPSILON15","minX","maxX","minY","maxY","minZ","maxZ","plane","Ellipsoid","WGS84","tangentPointCartographic","Rectangle","tangentPoint","cartographicToCartesian","tangentPlane","EllipsoidTangentPlane","lonCenter","longitude","latCenter","south","north","latitude","perimeterCartographicNC","fromRadians","perimeterCartographicNW","west","perimeterCartographicCW","perimeterCartographicSW","perimeterCartographicSC","perimeterCartesianNC","perimeterCartesianNW","perimeterCartesianCW","perimeterCartesianSW","perimeterCartesianSC","perimeterProjectedNC","projectPointToNearestOnPlane","perimeterProjectedNW","perimeterProjectedCW","perimeterProjectedSW","perimeterProjectedSC","getPointDistance","origin","xAxis","yAxis","zAxis","fullyAboveEquator","fullyBelowEquator","latitudeNearestToEquator","centerLongitude","planeNormal","abs","EPSILON10","normalize","UNIT_Z","cross","fromPointNormal","horizonCartesian","PI_OVER_TWO","projectPointOntoPlane","farZ","east","box","intersectPlane","normal","normalX","normalY","normalZ","radEffective","COLUMN0ROW0","COLUMN0ROW1","COLUMN0ROW2","COLUMN1ROW0","COLUMN1ROW1","COLUMN1ROW2","COLUMN2ROW0","COLUMN2ROW1","COLUMN2ROW2","distanceToPlane","distance","Intersect","OUTSIDE","INSIDE","INTERSECTING","scratchCartesianU","scratchCartesianV","scratchCartesianW","scratchValidAxis2","scratchValidAxis3","scratchPPrime","distanceSquaredTo","cartesian","offset","u","v","w","uHalf","magnitude","vHalf","wHalf","uValid","vValid","wValid","divideByScalar","validAxis1","validAxis2","validAxis3","numberOfDegenerateAxes","degenerateAxis","crossVector","UNIT_Y","EPSILON3","pPrime","d","distanceSquared","scratchCorner","scratchToCenter","computePlaneDistances","position","direction","Interval","minDist","POSITIVE_INFINITY","maxDist","NEGATIVE_INFINITY","corner","toCenter","mag","start","stop","scratchBoundingSphere","BoundingSphere","isOccluded","occluder","sphere","fromOrientedBoundingBox","isBoundingSphereVisible","prototype","equals","left","right"],"mappings":"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"}