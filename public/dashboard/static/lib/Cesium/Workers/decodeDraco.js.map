{"version":3,"file":"decodeDraco.js","sources":["../../../../Source/WorkersES6/decodeDraco.js"],"sourcesContent":["/* global require */\nimport ComponentDatatype from \"../Core/ComponentDatatype.js\";\nimport defined from \"../Core/defined.js\";\nimport IndexDatatype from \"../Core/IndexDatatype.js\";\nimport RuntimeError from \"../Core/RuntimeError.js\";\nimport createTaskProcessorWorker from \"./createTaskProcessorWorker.js\";\n\nvar draco;\n\nfunction decodeIndexArray(dracoGeometry, dracoDecoder) {\n  var numPoints = dracoGeometry.num_points();\n  var numFaces = dracoGeometry.num_faces();\n  var faceIndices = new draco.DracoInt32Array();\n  var numIndices = numFaces * 3;\n  var indexArray = IndexDatatype.createTypedArray(numPoints, numIndices);\n\n  var offset = 0;\n  for (var i = 0; i < numFaces; ++i) {\n    dracoDecoder.GetFaceFromMesh(dracoGeometry, i, faceIndices);\n\n    indexArray[offset + 0] = faceIndices.GetValue(0);\n    indexArray[offset + 1] = faceIndices.GetValue(1);\n    indexArray[offset + 2] = faceIndices.GetValue(2);\n    offset += 3;\n  }\n\n  draco.destroy(faceIndices);\n\n  return {\n    typedArray: indexArray,\n    numberOfIndices: numIndices,\n  };\n}\n\nfunction decodeQuantizedDracoTypedArray(\n  dracoGeometry,\n  dracoDecoder,\n  dracoAttribute,\n  quantization,\n  vertexArrayLength\n) {\n  var vertexArray;\n  var attributeData;\n  if (quantization.quantizationBits <= 8) {\n    attributeData = new draco.DracoUInt8Array();\n    vertexArray = new Uint8Array(vertexArrayLength);\n    dracoDecoder.GetAttributeUInt8ForAllPoints(\n      dracoGeometry,\n      dracoAttribute,\n      attributeData\n    );\n  } else {\n    attributeData = new draco.DracoUInt16Array();\n    vertexArray = new Uint16Array(vertexArrayLength);\n    dracoDecoder.GetAttributeUInt16ForAllPoints(\n      dracoGeometry,\n      dracoAttribute,\n      attributeData\n    );\n  }\n\n  for (var i = 0; i < vertexArrayLength; ++i) {\n    vertexArray[i] = attributeData.GetValue(i);\n  }\n\n  draco.destroy(attributeData);\n  return vertexArray;\n}\n\nfunction decodeDracoTypedArray(\n  dracoGeometry,\n  dracoDecoder,\n  dracoAttribute,\n  vertexArrayLength\n) {\n  var vertexArray;\n  var attributeData;\n\n  // Some attribute types are casted down to 32 bit since Draco only returns 32 bit values\n  switch (dracoAttribute.data_type()) {\n    case 1:\n    case 11: // DT_INT8 or DT_BOOL\n      attributeData = new draco.DracoInt8Array();\n      vertexArray = new Int8Array(vertexArrayLength);\n      dracoDecoder.GetAttributeInt8ForAllPoints(\n        dracoGeometry,\n        dracoAttribute,\n        attributeData\n      );\n      break;\n    case 2: // DT_UINT8\n      attributeData = new draco.DracoUInt8Array();\n      vertexArray = new Uint8Array(vertexArrayLength);\n      dracoDecoder.GetAttributeUInt8ForAllPoints(\n        dracoGeometry,\n        dracoAttribute,\n        attributeData\n      );\n      break;\n    case 3: // DT_INT16\n      attributeData = new draco.DracoInt16Array();\n      vertexArray = new Int16Array(vertexArrayLength);\n      dracoDecoder.GetAttributeInt16ForAllPoints(\n        dracoGeometry,\n        dracoAttribute,\n        attributeData\n      );\n      break;\n    case 4: // DT_UINT16\n      attributeData = new draco.DracoUInt16Array();\n      vertexArray = new Uint16Array(vertexArrayLength);\n      dracoDecoder.GetAttributeUInt16ForAllPoints(\n        dracoGeometry,\n        dracoAttribute,\n        attributeData\n      );\n      break;\n    case 5:\n    case 7: // DT_INT32 or DT_INT64\n      attributeData = new draco.DracoInt32Array();\n      vertexArray = new Int32Array(vertexArrayLength);\n      dracoDecoder.GetAttributeInt32ForAllPoints(\n        dracoGeometry,\n        dracoAttribute,\n        attributeData\n      );\n      break;\n    case 6:\n    case 8: // DT_UINT32 or DT_UINT64\n      attributeData = new draco.DracoUInt32Array();\n      vertexArray = new Uint32Array(vertexArrayLength);\n      dracoDecoder.GetAttributeUInt32ForAllPoints(\n        dracoGeometry,\n        dracoAttribute,\n        attributeData\n      );\n      break;\n    case 9:\n    case 10: // DT_FLOAT32 or DT_FLOAT64\n      attributeData = new draco.DracoFloat32Array();\n      vertexArray = new Float32Array(vertexArrayLength);\n      dracoDecoder.GetAttributeFloatForAllPoints(\n        dracoGeometry,\n        dracoAttribute,\n        attributeData\n      );\n      break;\n  }\n\n  for (var i = 0; i < vertexArrayLength; ++i) {\n    vertexArray[i] = attributeData.GetValue(i);\n  }\n\n  draco.destroy(attributeData);\n  return vertexArray;\n}\n\nfunction decodeAttribute(dracoGeometry, dracoDecoder, dracoAttribute) {\n  var numPoints = dracoGeometry.num_points();\n  var numComponents = dracoAttribute.num_components();\n\n  var quantization;\n  var transform = new draco.AttributeQuantizationTransform();\n  if (transform.InitFromAttribute(dracoAttribute)) {\n    var minValues = new Array(numComponents);\n    for (var i = 0; i < numComponents; ++i) {\n      minValues[i] = transform.min_value(i);\n    }\n    quantization = {\n      quantizationBits: transform.quantization_bits(),\n      minValues: minValues,\n      range: transform.range(),\n      octEncoded: false,\n    };\n  }\n  draco.destroy(transform);\n\n  transform = new draco.AttributeOctahedronTransform();\n  if (transform.InitFromAttribute(dracoAttribute)) {\n    quantization = {\n      quantizationBits: transform.quantization_bits(),\n      octEncoded: true,\n    };\n  }\n  draco.destroy(transform);\n\n  var vertexArrayLength = numPoints * numComponents;\n  var vertexArray;\n  if (defined(quantization)) {\n    vertexArray = decodeQuantizedDracoTypedArray(\n      dracoGeometry,\n      dracoDecoder,\n      dracoAttribute,\n      quantization,\n      vertexArrayLength\n    );\n  } else {\n    vertexArray = decodeDracoTypedArray(\n      dracoGeometry,\n      dracoDecoder,\n      dracoAttribute,\n      vertexArrayLength\n    );\n  }\n\n  var componentDatatype = ComponentDatatype.fromTypedArray(vertexArray);\n\n  return {\n    array: vertexArray,\n    data: {\n      componentsPerAttribute: numComponents,\n      componentDatatype: componentDatatype,\n      byteOffset: dracoAttribute.byte_offset(),\n      byteStride:\n        ComponentDatatype.getSizeInBytes(componentDatatype) * numComponents,\n      normalized: dracoAttribute.normalized(),\n      quantization: quantization,\n    },\n  };\n}\n\nfunction decodePointCloud(parameters) {\n  var dracoDecoder = new draco.Decoder();\n\n  if (parameters.dequantizeInShader) {\n    dracoDecoder.SkipAttributeTransform(draco.POSITION);\n    dracoDecoder.SkipAttributeTransform(draco.NORMAL);\n  }\n\n  var buffer = new draco.DecoderBuffer();\n  buffer.Init(parameters.buffer, parameters.buffer.length);\n\n  var geometryType = dracoDecoder.GetEncodedGeometryType(buffer);\n  if (geometryType !== draco.POINT_CLOUD) {\n    throw new RuntimeError(\"Draco geometry type must be POINT_CLOUD.\");\n  }\n\n  var dracoPointCloud = new draco.PointCloud();\n  var decodingStatus = dracoDecoder.DecodeBufferToPointCloud(\n    buffer,\n    dracoPointCloud\n  );\n  if (!decodingStatus.ok() || dracoPointCloud.ptr === 0) {\n    throw new RuntimeError(\n      \"Error decoding draco point cloud: \" + decodingStatus.error_msg()\n    );\n  }\n\n  draco.destroy(buffer);\n\n  var result = {};\n\n  var properties = parameters.properties;\n  for (var propertyName in properties) {\n    if (properties.hasOwnProperty(propertyName)) {\n      var dracoAttribute;\n      if (propertyName === \"POSITION\" || propertyName === \"NORMAL\") {\n        var dracoAttributeId = dracoDecoder.GetAttributeId(\n          dracoPointCloud,\n          draco[propertyName]\n        );\n        dracoAttribute = dracoDecoder.GetAttribute(\n          dracoPointCloud,\n          dracoAttributeId\n        );\n      } else {\n        var attributeId = properties[propertyName];\n        dracoAttribute = dracoDecoder.GetAttributeByUniqueId(\n          dracoPointCloud,\n          attributeId\n        );\n      }\n      result[propertyName] = decodeAttribute(\n        dracoPointCloud,\n        dracoDecoder,\n        dracoAttribute\n      );\n    }\n  }\n\n  draco.destroy(dracoPointCloud);\n  draco.destroy(dracoDecoder);\n\n  return result;\n}\n\nfunction decodePrimitive(parameters) {\n  var dracoDecoder = new draco.Decoder();\n\n  // Skip all parameter types except generic\n  // Note: As a temporary work-around until GetAttributeByUniqueId() works after\n  // calling SkipAttributeTransform(), we will not skip attributes with multiple\n  // sets of data in the glTF.\n  var attributesToSkip = [\"POSITION\", \"NORMAL\"];\n  var compressedAttributes = parameters.compressedAttributes;\n  if (!defined(compressedAttributes[\"COLOR_1\"])) {\n    attributesToSkip.push(\"COLOR\");\n  }\n  if (!defined(compressedAttributes[\"TEXCOORD_1\"])) {\n    attributesToSkip.push(\"TEX_COORD\");\n  }\n  if (parameters.dequantizeInShader) {\n    for (var i = 0; i < attributesToSkip.length; ++i) {\n      dracoDecoder.SkipAttributeTransform(draco[attributesToSkip[i]]);\n    }\n  }\n\n  var bufferView = parameters.bufferView;\n  var buffer = new draco.DecoderBuffer();\n  buffer.Init(parameters.array, bufferView.byteLength);\n\n  var geometryType = dracoDecoder.GetEncodedGeometryType(buffer);\n  if (geometryType !== draco.TRIANGULAR_MESH) {\n    throw new RuntimeError(\"Unsupported draco mesh geometry type.\");\n  }\n\n  var dracoGeometry = new draco.Mesh();\n  var decodingStatus = dracoDecoder.DecodeBufferToMesh(buffer, dracoGeometry);\n  if (!decodingStatus.ok() || dracoGeometry.ptr === 0) {\n    throw new RuntimeError(\n      \"Error decoding draco mesh geometry: \" + decodingStatus.error_msg()\n    );\n  }\n\n  draco.destroy(buffer);\n\n  var attributeData = {};\n  for (var attributeName in compressedAttributes) {\n    if (compressedAttributes.hasOwnProperty(attributeName)) {\n      // Since GetAttributeByUniqueId() only works on attributes that we have not called\n      // SkipAttributeTransform() on, we must first store a `dracoAttributeName` in case\n      // we call GetAttributeId() instead.\n      var dracoAttributeName = attributeName;\n      if (attributeName === \"TEXCOORD_0\") {\n        dracoAttributeName = \"TEX_COORD\";\n      }\n      if (attributeName === \"COLOR_0\") {\n        dracoAttributeName = \"COLOR\";\n      }\n\n      var dracoAttribute;\n      if (attributesToSkip.includes(dracoAttributeName)) {\n        var dracoAttributeId = dracoDecoder.GetAttributeId(\n          dracoGeometry,\n          draco[dracoAttributeName]\n        );\n        dracoAttribute = dracoDecoder.GetAttribute(\n          dracoGeometry,\n          dracoAttributeId\n        );\n      } else {\n        var compressedAttribute = compressedAttributes[attributeName];\n        dracoAttribute = dracoDecoder.GetAttributeByUniqueId(\n          dracoGeometry,\n          compressedAttribute\n        );\n      }\n\n      attributeData[attributeName] = decodeAttribute(\n        dracoGeometry,\n        dracoDecoder,\n        dracoAttribute\n      );\n    }\n  }\n\n  var result = {\n    indexArray: decodeIndexArray(dracoGeometry, dracoDecoder),\n    attributeData: attributeData,\n  };\n\n  draco.destroy(dracoGeometry);\n  draco.destroy(dracoDecoder);\n\n  return result;\n}\n\nfunction decode(parameters) {\n  if (defined(parameters.bufferView)) {\n    return decodePrimitive(parameters);\n  }\n  return decodePointCloud(parameters);\n}\n\nfunction initWorker(dracoModule) {\n  draco = dracoModule;\n  self.onmessage = createTaskProcessorWorker(decode);\n  self.postMessage(true);\n}\n\nfunction decodeDraco(event) {\n  var data = event.data;\n\n  // Expect the first message to be to load a web assembly module\n  var wasmConfig = data.webAssemblyConfig;\n  if (defined(wasmConfig)) {\n    // Require and compile WebAssembly module, or use fallback if not supported\n    return require([wasmConfig.modulePath], function (dracoModule) {\n      if (defined(wasmConfig.wasmBinaryFile)) {\n        if (!defined(dracoModule)) {\n          dracoModule = self.DracoDecoderModule;\n        }\n\n        dracoModule(wasmConfig).then(function (compiledModule) {\n          initWorker(compiledModule);\n        });\n      } else {\n        initWorker(dracoModule());\n      }\n    });\n  }\n}\nexport default decodeDraco;\n"],"names":["draco","decodeIndexArray","dracoGeometry","dracoDecoder","numPoints","num_points","numFaces","num_faces","faceIndices","DracoInt32Array","numIndices","indexArray","IndexDatatype","createTypedArray","offset","i","GetFaceFromMesh","GetValue","destroy","typedArray","numberOfIndices","decodeAttribute","dracoAttribute","quantization","numComponents","num_components","transform","AttributeQuantizationTransform","InitFromAttribute","minValues","Array","min_value","quantizationBits","quantization_bits","range","octEncoded","AttributeOctahedronTransform","vertexArray","vertexArrayLength","defined","attributeData","DracoUInt8Array","Uint8Array","GetAttributeUInt8ForAllPoints","DracoUInt16Array","Uint16Array","GetAttributeUInt16ForAllPoints","decodeQuantizedDracoTypedArray","data_type","DracoInt8Array","Int8Array","GetAttributeInt8ForAllPoints","DracoInt16Array","Int16Array","GetAttributeInt16ForAllPoints","Int32Array","GetAttributeInt32ForAllPoints","DracoUInt32Array","Uint32Array","GetAttributeUInt32ForAllPoints","DracoFloat32Array","Float32Array","GetAttributeFloatForAllPoints","decodeDracoTypedArray","componentDatatype","ComponentDatatype","fromTypedArray","array","data","componentsPerAttribute","byteOffset","byte_offset","byteStride","getSizeInBytes","normalized","decode","parameters","bufferView","Decoder","attributesToSkip","compressedAttributes","push","dequantizeInShader","length","SkipAttributeTransform","buffer","DecoderBuffer","Init","byteLength","GetEncodedGeometryType","TRIANGULAR_MESH","RuntimeError","Mesh","decodingStatus","DecodeBufferToMesh","ok","ptr","error_msg","attributeName","hasOwnProperty","dracoAttributeName","includes","dracoAttributeId","GetAttributeId","GetAttribute","compressedAttribute","GetAttributeByUniqueId","result","decodePrimitive","POSITION","NORMAL","POINT_CLOUD","dracoPointCloud","PointCloud","DecodeBufferToPointCloud","properties","propertyName","attributeId","decodePointCloud","initWorker","dracoModule","self","onmessage","createTaskProcessorWorker","postMessage","event","wasmConfig","webAssemblyConfig","require","modulePath","wasmBinaryFile","DracoDecoderModule","then","compiledModule"],"mappings":"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"}