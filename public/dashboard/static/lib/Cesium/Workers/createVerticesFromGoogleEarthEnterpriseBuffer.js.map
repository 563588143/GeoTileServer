{"version":3,"file":"createVerticesFromGoogleEarthEnterpriseBuffer.js","sources":["../../../../Source/WorkersES6/createVerticesFromGoogleEarthEnterpriseBuffer.js"],"sourcesContent":["import AxisAlignedBoundingBox from \"../Core/AxisAlignedBoundingBox.js\";\nimport BoundingSphere from \"../Core/BoundingSphere.js\";\nimport Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartographic from \"../Core/Cartographic.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport Ellipsoid from \"../Core/Ellipsoid.js\";\nimport EllipsoidalOccluder from \"../Core/EllipsoidalOccluder.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport OrientedBoundingBox from \"../Core/OrientedBoundingBox.js\";\nimport Rectangle from \"../Core/Rectangle.js\";\nimport RuntimeError from \"../Core/RuntimeError.js\";\nimport TerrainEncoding from \"../Core/TerrainEncoding.js\";\nimport Transforms from \"../Core/Transforms.js\";\nimport WebMercatorProjection from \"../Core/WebMercatorProjection.js\";\nimport createTaskProcessorWorker from \"./createTaskProcessorWorker.js\";\n\nvar sizeOfUint16 = Uint16Array.BYTES_PER_ELEMENT;\nvar sizeOfInt32 = Int32Array.BYTES_PER_ELEMENT;\nvar sizeOfUint32 = Uint32Array.BYTES_PER_ELEMENT;\nvar sizeOfFloat = Float32Array.BYTES_PER_ELEMENT;\nvar sizeOfDouble = Float64Array.BYTES_PER_ELEMENT;\n\nfunction indexOfEpsilon(arr, elem, elemType) {\n  elemType = defaultValue(elemType, CesiumMath);\n  var count = arr.length;\n  for (var i = 0; i < count; ++i) {\n    if (elemType.equalsEpsilon(arr[i], elem, CesiumMath.EPSILON12)) {\n      return i;\n    }\n  }\n\n  return -1;\n}\n\nfunction createVerticesFromGoogleEarthEnterpriseBuffer(\n  parameters,\n  transferableObjects\n) {\n  parameters.ellipsoid = Ellipsoid.clone(parameters.ellipsoid);\n  parameters.rectangle = Rectangle.clone(parameters.rectangle);\n\n  var statistics = processBuffer(\n    parameters.buffer,\n    parameters.relativeToCenter,\n    parameters.ellipsoid,\n    parameters.rectangle,\n    parameters.nativeRectangle,\n    parameters.exaggeration,\n    parameters.exaggerationRelativeHeight,\n    parameters.skirtHeight,\n    parameters.includeWebMercatorT,\n    parameters.negativeAltitudeExponentBias,\n    parameters.negativeElevationThreshold\n  );\n  var vertices = statistics.vertices;\n  transferableObjects.push(vertices.buffer);\n  var indices = statistics.indices;\n  transferableObjects.push(indices.buffer);\n\n  return {\n    vertices: vertices.buffer,\n    indices: indices.buffer,\n    numberOfAttributes: statistics.encoding.stride,\n    minimumHeight: statistics.minimumHeight,\n    maximumHeight: statistics.maximumHeight,\n    boundingSphere3D: statistics.boundingSphere3D,\n    orientedBoundingBox: statistics.orientedBoundingBox,\n    occludeePointInScaledSpace: statistics.occludeePointInScaledSpace,\n    encoding: statistics.encoding,\n    vertexCountWithoutSkirts: statistics.vertexCountWithoutSkirts,\n    indexCountWithoutSkirts: statistics.indexCountWithoutSkirts,\n    westIndicesSouthToNorth: statistics.westIndicesSouthToNorth,\n    southIndicesEastToWest: statistics.southIndicesEastToWest,\n    eastIndicesNorthToSouth: statistics.eastIndicesNorthToSouth,\n    northIndicesWestToEast: statistics.northIndicesWestToEast,\n  };\n}\n\nvar scratchCartographic = new Cartographic();\nvar scratchCartesian = new Cartesian3();\nvar minimumScratch = new Cartesian3();\nvar maximumScratch = new Cartesian3();\nvar matrix4Scratch = new Matrix4();\n\nfunction processBuffer(\n  buffer,\n  relativeToCenter,\n  ellipsoid,\n  rectangle,\n  nativeRectangle,\n  exaggeration,\n  exaggerationRelativeHeight,\n  skirtHeight,\n  includeWebMercatorT,\n  negativeAltitudeExponentBias,\n  negativeElevationThreshold\n) {\n  var geographicWest;\n  var geographicSouth;\n  var geographicEast;\n  var geographicNorth;\n  var rectangleWidth, rectangleHeight;\n\n  if (!defined(rectangle)) {\n    geographicWest = CesiumMath.toRadians(nativeRectangle.west);\n    geographicSouth = CesiumMath.toRadians(nativeRectangle.south);\n    geographicEast = CesiumMath.toRadians(nativeRectangle.east);\n    geographicNorth = CesiumMath.toRadians(nativeRectangle.north);\n    rectangleWidth = CesiumMath.toRadians(rectangle.width);\n    rectangleHeight = CesiumMath.toRadians(rectangle.height);\n  } else {\n    geographicWest = rectangle.west;\n    geographicSouth = rectangle.south;\n    geographicEast = rectangle.east;\n    geographicNorth = rectangle.north;\n    rectangleWidth = rectangle.width;\n    rectangleHeight = rectangle.height;\n  }\n\n  // Keep track of quad borders so we can remove duplicates around the borders\n  var quadBorderLatitudes = [geographicSouth, geographicNorth];\n  var quadBorderLongitudes = [geographicWest, geographicEast];\n\n  var fromENU = Transforms.eastNorthUpToFixedFrame(relativeToCenter, ellipsoid);\n  var toENU = Matrix4.inverseTransformation(fromENU, matrix4Scratch);\n\n  var southMercatorY;\n  var oneOverMercatorHeight;\n  if (includeWebMercatorT) {\n    southMercatorY = WebMercatorProjection.geodeticLatitudeToMercatorAngle(\n      geographicSouth\n    );\n    oneOverMercatorHeight =\n      1.0 /\n      (WebMercatorProjection.geodeticLatitudeToMercatorAngle(geographicNorth) -\n        southMercatorY);\n  }\n\n  var hasExaggeration = exaggeration !== 1.0;\n  var includeGeodeticSurfaceNormals = hasExaggeration;\n\n  var dv = new DataView(buffer);\n\n  var minHeight = Number.POSITIVE_INFINITY;\n  var maxHeight = Number.NEGATIVE_INFINITY;\n\n  var minimum = minimumScratch;\n  minimum.x = Number.POSITIVE_INFINITY;\n  minimum.y = Number.POSITIVE_INFINITY;\n  minimum.z = Number.POSITIVE_INFINITY;\n\n  var maximum = maximumScratch;\n  maximum.x = Number.NEGATIVE_INFINITY;\n  maximum.y = Number.NEGATIVE_INFINITY;\n  maximum.z = Number.NEGATIVE_INFINITY;\n\n  // Compute sizes\n  var offset = 0;\n  var size = 0;\n  var indicesSize = 0;\n  var quadSize;\n  var quad;\n  for (quad = 0; quad < 4; ++quad) {\n    var o = offset;\n    quadSize = dv.getUint32(o, true);\n    o += sizeOfUint32;\n\n    var x = CesiumMath.toRadians(dv.getFloat64(o, true) * 180.0);\n    o += sizeOfDouble;\n    if (indexOfEpsilon(quadBorderLongitudes, x) === -1) {\n      quadBorderLongitudes.push(x);\n    }\n\n    var y = CesiumMath.toRadians(dv.getFloat64(o, true) * 180.0);\n    o += sizeOfDouble;\n    if (indexOfEpsilon(quadBorderLatitudes, y) === -1) {\n      quadBorderLatitudes.push(y);\n    }\n\n    o += 2 * sizeOfDouble; // stepX + stepY\n\n    var c = dv.getInt32(o, true); // Read point count\n    o += sizeOfInt32;\n    size += c;\n\n    c = dv.getInt32(o, true); // Read index count\n    indicesSize += c * 3;\n\n    offset += quadSize + sizeOfUint32; // Jump to next quad\n  }\n\n  // Quad Border points to remove duplicates\n  var quadBorderPoints = [];\n  var quadBorderIndices = [];\n\n  // Create arrays\n  var positions = new Array(size);\n  var uvs = new Array(size);\n  var heights = new Array(size);\n  var webMercatorTs = includeWebMercatorT ? new Array(size) : [];\n  var geodeticSurfaceNormals = includeGeodeticSurfaceNormals\n    ? new Array(size)\n    : [];\n  var indices = new Array(indicesSize);\n\n  // Points are laid out in rows starting at SW, so storing border points as we\n  //  come across them all points will be adjacent.\n  var westBorder = [];\n  var southBorder = [];\n  var eastBorder = [];\n  var northBorder = [];\n\n  // Each tile is split into 4 parts\n  var pointOffset = 0;\n  var indicesOffset = 0;\n  offset = 0;\n  for (quad = 0; quad < 4; ++quad) {\n    quadSize = dv.getUint32(offset, true);\n    offset += sizeOfUint32;\n    var startQuad = offset;\n\n    var originX = CesiumMath.toRadians(dv.getFloat64(offset, true) * 180.0);\n    offset += sizeOfDouble;\n\n    var originY = CesiumMath.toRadians(dv.getFloat64(offset, true) * 180.0);\n    offset += sizeOfDouble;\n\n    var stepX = CesiumMath.toRadians(dv.getFloat64(offset, true) * 180.0);\n    var halfStepX = stepX * 0.5;\n    offset += sizeOfDouble;\n\n    var stepY = CesiumMath.toRadians(dv.getFloat64(offset, true) * 180.0);\n    var halfStepY = stepY * 0.5;\n    offset += sizeOfDouble;\n\n    var numPoints = dv.getInt32(offset, true);\n    offset += sizeOfInt32;\n\n    var numFaces = dv.getInt32(offset, true);\n    offset += sizeOfInt32;\n\n    //var level = dv.getInt32(offset, true);\n    offset += sizeOfInt32;\n\n    // Keep track of quad indices to overall tile indices\n    var indicesMapping = new Array(numPoints);\n    for (var i = 0; i < numPoints; ++i) {\n      var longitude = originX + dv.getUint8(offset++) * stepX;\n      scratchCartographic.longitude = longitude;\n      var latitude = originY + dv.getUint8(offset++) * stepY;\n      scratchCartographic.latitude = latitude;\n\n      var height = dv.getFloat32(offset, true);\n      offset += sizeOfFloat;\n\n      // In order to support old clients, negative altitude values are stored as\n      // height/-2^32. Old clients see the value as really close to 0 but new clients multiply\n      // by -2^32 to get the real negative altitude value.\n      if (height !== 0 && height < negativeElevationThreshold) {\n        height *= -Math.pow(2, negativeAltitudeExponentBias);\n      }\n\n      // Height is stored in units of (1/EarthRadius) or (1/6371010.0)\n      height *= 6371010.0;\n\n      scratchCartographic.height = height;\n\n      // Is it along a quad border - if so check if already exists and use that index\n      if (\n        indexOfEpsilon(quadBorderLongitudes, longitude) !== -1 ||\n        indexOfEpsilon(quadBorderLatitudes, latitude) !== -1\n      ) {\n        var index = indexOfEpsilon(\n          quadBorderPoints,\n          scratchCartographic,\n          Cartographic\n        );\n        if (index === -1) {\n          quadBorderPoints.push(Cartographic.clone(scratchCartographic));\n          quadBorderIndices.push(pointOffset);\n        } else {\n          indicesMapping[i] = quadBorderIndices[index];\n          continue;\n        }\n      }\n      indicesMapping[i] = pointOffset;\n\n      if (Math.abs(longitude - geographicWest) < halfStepX) {\n        westBorder.push({\n          index: pointOffset,\n          cartographic: Cartographic.clone(scratchCartographic),\n        });\n      } else if (Math.abs(longitude - geographicEast) < halfStepX) {\n        eastBorder.push({\n          index: pointOffset,\n          cartographic: Cartographic.clone(scratchCartographic),\n        });\n      } else if (Math.abs(latitude - geographicSouth) < halfStepY) {\n        southBorder.push({\n          index: pointOffset,\n          cartographic: Cartographic.clone(scratchCartographic),\n        });\n      } else if (Math.abs(latitude - geographicNorth) < halfStepY) {\n        northBorder.push({\n          index: pointOffset,\n          cartographic: Cartographic.clone(scratchCartographic),\n        });\n      }\n\n      minHeight = Math.min(height, minHeight);\n      maxHeight = Math.max(height, maxHeight);\n      heights[pointOffset] = height;\n\n      var pos = ellipsoid.cartographicToCartesian(scratchCartographic);\n      positions[pointOffset] = pos;\n\n      if (includeWebMercatorT) {\n        webMercatorTs[pointOffset] =\n          (WebMercatorProjection.geodeticLatitudeToMercatorAngle(latitude) -\n            southMercatorY) *\n          oneOverMercatorHeight;\n      }\n\n      if (includeGeodeticSurfaceNormals) {\n        var normal = ellipsoid.geodeticSurfaceNormal(pos);\n        geodeticSurfaceNormals[pointOffset] = normal;\n      }\n\n      Matrix4.multiplyByPoint(toENU, pos, scratchCartesian);\n\n      Cartesian3.minimumByComponent(scratchCartesian, minimum, minimum);\n      Cartesian3.maximumByComponent(scratchCartesian, maximum, maximum);\n\n      var u = (longitude - geographicWest) / (geographicEast - geographicWest);\n      u = CesiumMath.clamp(u, 0.0, 1.0);\n      var v =\n        (latitude - geographicSouth) / (geographicNorth - geographicSouth);\n      v = CesiumMath.clamp(v, 0.0, 1.0);\n\n      uvs[pointOffset] = new Cartesian2(u, v);\n      ++pointOffset;\n    }\n\n    var facesElementCount = numFaces * 3;\n    for (var j = 0; j < facesElementCount; ++j, ++indicesOffset) {\n      indices[indicesOffset] = indicesMapping[dv.getUint16(offset, true)];\n      offset += sizeOfUint16;\n    }\n\n    if (quadSize !== offset - startQuad) {\n      throw new RuntimeError(\"Invalid terrain tile.\");\n    }\n  }\n\n  positions.length = pointOffset;\n  uvs.length = pointOffset;\n  heights.length = pointOffset;\n  if (includeWebMercatorT) {\n    webMercatorTs.length = pointOffset;\n  }\n  if (includeGeodeticSurfaceNormals) {\n    geodeticSurfaceNormals.length = pointOffset;\n  }\n\n  var vertexCountWithoutSkirts = pointOffset;\n  var indexCountWithoutSkirts = indicesOffset;\n\n  // Add skirt points\n  var skirtOptions = {\n    hMin: minHeight,\n    lastBorderPoint: undefined,\n    skirtHeight: skirtHeight,\n    toENU: toENU,\n    ellipsoid: ellipsoid,\n    minimum: minimum,\n    maximum: maximum,\n  };\n\n  // Sort counter clockwise from NW corner\n  // Corner points are in the east/west arrays\n  westBorder.sort(function (a, b) {\n    return b.cartographic.latitude - a.cartographic.latitude;\n  });\n  southBorder.sort(function (a, b) {\n    return a.cartographic.longitude - b.cartographic.longitude;\n  });\n  eastBorder.sort(function (a, b) {\n    return a.cartographic.latitude - b.cartographic.latitude;\n  });\n  northBorder.sort(function (a, b) {\n    return b.cartographic.longitude - a.cartographic.longitude;\n  });\n\n  var percentage = 0.00001;\n  addSkirt(\n    positions,\n    heights,\n    uvs,\n    webMercatorTs,\n    geodeticSurfaceNormals,\n    indices,\n    skirtOptions,\n    westBorder,\n    -percentage * rectangleWidth,\n    true,\n    -percentage * rectangleHeight\n  );\n  addSkirt(\n    positions,\n    heights,\n    uvs,\n    webMercatorTs,\n    geodeticSurfaceNormals,\n    indices,\n    skirtOptions,\n    southBorder,\n    -percentage * rectangleHeight,\n    false\n  );\n  addSkirt(\n    positions,\n    heights,\n    uvs,\n    webMercatorTs,\n    geodeticSurfaceNormals,\n    indices,\n    skirtOptions,\n    eastBorder,\n    percentage * rectangleWidth,\n    true,\n    percentage * rectangleHeight\n  );\n  addSkirt(\n    positions,\n    heights,\n    uvs,\n    webMercatorTs,\n    geodeticSurfaceNormals,\n    indices,\n    skirtOptions,\n    northBorder,\n    percentage * rectangleHeight,\n    false\n  );\n\n  // Since the corner between the north and west sides is in the west array, generate the last\n  //  two triangles between the last north vertex and the first west vertex\n  if (westBorder.length > 0 && northBorder.length > 0) {\n    var firstBorderIndex = westBorder[0].index;\n    var firstSkirtIndex = vertexCountWithoutSkirts;\n    var lastBorderIndex = northBorder[northBorder.length - 1].index;\n    var lastSkirtIndex = positions.length - 1;\n\n    indices.push(\n      lastBorderIndex,\n      lastSkirtIndex,\n      firstSkirtIndex,\n      firstSkirtIndex,\n      firstBorderIndex,\n      lastBorderIndex\n    );\n  }\n\n  size = positions.length; // Get new size with skirt vertices\n\n  var boundingSphere3D = BoundingSphere.fromPoints(positions);\n  var orientedBoundingBox;\n  if (defined(rectangle)) {\n    orientedBoundingBox = OrientedBoundingBox.fromRectangle(\n      rectangle,\n      minHeight,\n      maxHeight,\n      ellipsoid\n    );\n  }\n\n  var occluder = new EllipsoidalOccluder(ellipsoid);\n  var occludeePointInScaledSpace = occluder.computeHorizonCullingPointPossiblyUnderEllipsoid(\n    relativeToCenter,\n    positions,\n    minHeight\n  );\n\n  var aaBox = new AxisAlignedBoundingBox(minimum, maximum, relativeToCenter);\n  var encoding = new TerrainEncoding(\n    relativeToCenter,\n    aaBox,\n    skirtOptions.hMin,\n    maxHeight,\n    fromENU,\n    false,\n    includeWebMercatorT,\n    includeGeodeticSurfaceNormals,\n    exaggeration,\n    exaggerationRelativeHeight\n  );\n  var vertices = new Float32Array(size * encoding.stride);\n\n  var bufferIndex = 0;\n  for (var k = 0; k < size; ++k) {\n    bufferIndex = encoding.encode(\n      vertices,\n      bufferIndex,\n      positions[k],\n      uvs[k],\n      heights[k],\n      undefined,\n      webMercatorTs[k],\n      geodeticSurfaceNormals[k]\n    );\n  }\n\n  var westIndicesSouthToNorth = westBorder\n    .map(function (vertex) {\n      return vertex.index;\n    })\n    .reverse();\n  var southIndicesEastToWest = southBorder\n    .map(function (vertex) {\n      return vertex.index;\n    })\n    .reverse();\n  var eastIndicesNorthToSouth = eastBorder\n    .map(function (vertex) {\n      return vertex.index;\n    })\n    .reverse();\n  var northIndicesWestToEast = northBorder\n    .map(function (vertex) {\n      return vertex.index;\n    })\n    .reverse();\n\n  southIndicesEastToWest.unshift(\n    eastIndicesNorthToSouth[eastIndicesNorthToSouth.length - 1]\n  );\n  southIndicesEastToWest.push(westIndicesSouthToNorth[0]);\n\n  northIndicesWestToEast.unshift(\n    westIndicesSouthToNorth[westIndicesSouthToNorth.length - 1]\n  );\n  northIndicesWestToEast.push(eastIndicesNorthToSouth[0]);\n\n  return {\n    vertices: vertices,\n    indices: new Uint16Array(indices),\n    maximumHeight: maxHeight,\n    minimumHeight: minHeight,\n    encoding: encoding,\n    boundingSphere3D: boundingSphere3D,\n    orientedBoundingBox: orientedBoundingBox,\n    occludeePointInScaledSpace: occludeePointInScaledSpace,\n    vertexCountWithoutSkirts: vertexCountWithoutSkirts,\n    indexCountWithoutSkirts: indexCountWithoutSkirts,\n    westIndicesSouthToNorth: westIndicesSouthToNorth,\n    southIndicesEastToWest: southIndicesEastToWest,\n    eastIndicesNorthToSouth: eastIndicesNorthToSouth,\n    northIndicesWestToEast: northIndicesWestToEast,\n  };\n}\n\nfunction addSkirt(\n  positions,\n  heights,\n  uvs,\n  webMercatorTs,\n  geodeticSurfaceNormals,\n  indices,\n  skirtOptions,\n  borderPoints,\n  fudgeFactor,\n  eastOrWest,\n  cornerFudge\n) {\n  var count = borderPoints.length;\n  for (var j = 0; j < count; ++j) {\n    var borderPoint = borderPoints[j];\n    var borderCartographic = borderPoint.cartographic;\n    var borderIndex = borderPoint.index;\n    var currentIndex = positions.length;\n\n    var longitude = borderCartographic.longitude;\n    var latitude = borderCartographic.latitude;\n    latitude = CesiumMath.clamp(\n      latitude,\n      -CesiumMath.PI_OVER_TWO,\n      CesiumMath.PI_OVER_TWO\n    ); // Don't go over the poles\n    var height = borderCartographic.height - skirtOptions.skirtHeight;\n    skirtOptions.hMin = Math.min(skirtOptions.hMin, height);\n\n    Cartographic.fromRadians(longitude, latitude, height, scratchCartographic);\n\n    // Adjust sides to angle out\n    if (eastOrWest) {\n      scratchCartographic.longitude += fudgeFactor;\n    }\n\n    // Adjust top or bottom to angle out\n    // Since corners are in the east/west arrays angle the first and last points as well\n    if (!eastOrWest) {\n      scratchCartographic.latitude += fudgeFactor;\n    } else if (j === count - 1) {\n      scratchCartographic.latitude += cornerFudge;\n    } else if (j === 0) {\n      scratchCartographic.latitude -= cornerFudge;\n    }\n\n    var pos = skirtOptions.ellipsoid.cartographicToCartesian(\n      scratchCartographic\n    );\n    positions.push(pos);\n    heights.push(height);\n    uvs.push(Cartesian2.clone(uvs[borderIndex])); // Copy UVs from border point\n    if (webMercatorTs.length > 0) {\n      webMercatorTs.push(webMercatorTs[borderIndex]);\n    }\n    if (geodeticSurfaceNormals.length > 0) {\n      geodeticSurfaceNormals.push(geodeticSurfaceNormals[borderIndex]);\n    }\n\n    Matrix4.multiplyByPoint(skirtOptions.toENU, pos, scratchCartesian);\n\n    var minimum = skirtOptions.minimum;\n    var maximum = skirtOptions.maximum;\n    Cartesian3.minimumByComponent(scratchCartesian, minimum, minimum);\n    Cartesian3.maximumByComponent(scratchCartesian, maximum, maximum);\n\n    var lastBorderPoint = skirtOptions.lastBorderPoint;\n    if (defined(lastBorderPoint)) {\n      var lastBorderIndex = lastBorderPoint.index;\n      indices.push(\n        lastBorderIndex,\n        currentIndex - 1,\n        currentIndex,\n        currentIndex,\n        borderIndex,\n        lastBorderIndex\n      );\n    }\n\n    skirtOptions.lastBorderPoint = borderPoint;\n  }\n}\nexport default createTaskProcessorWorker(\n  createVerticesFromGoogleEarthEnterpriseBuffer\n);\n"],"names":["sizeOfUint16","Uint16Array","BYTES_PER_ELEMENT","sizeOfInt32","Int32Array","sizeOfUint32","Uint32Array","sizeOfFloat","Float32Array","sizeOfDouble","Float64Array","indexOfEpsilon","arr","elem","elemType","defaultValue","CesiumMath","count","length","i","equalsEpsilon","EPSILON12","scratchCartographic","Cartographic","scratchCartesian","Cartesian3","minimumScratch","maximumScratch","matrix4Scratch","Matrix4","addSkirt","positions","heights","uvs","webMercatorTs","geodeticSurfaceNormals","indices","skirtOptions","borderPoints","fudgeFactor","eastOrWest","cornerFudge","j","borderPoint","borderCartographic","cartographic","borderIndex","index","currentIndex","longitude","latitude","clamp","PI_OVER_TWO","height","skirtHeight","hMin","Math","min","fromRadians","pos","ellipsoid","cartographicToCartesian","push","Cartesian2","clone","multiplyByPoint","toENU","minimum","maximum","minimumByComponent","maximumByComponent","lastBorderPoint","defined","lastBorderIndex","createTaskProcessorWorker","parameters","transferableObjects","Ellipsoid","rectangle","Rectangle","statistics","buffer","relativeToCenter","nativeRectangle","exaggeration","exaggerationRelativeHeight","includeWebMercatorT","negativeAltitudeExponentBias","negativeElevationThreshold","geographicWest","geographicSouth","geographicEast","geographicNorth","rectangleWidth","rectangleHeight","west","south","east","north","width","toRadians","southMercatorY","oneOverMercatorHeight","quadBorderLatitudes","quadBorderLongitudes","fromENU","Transforms","eastNorthUpToFixedFrame","inverseTransformation","WebMercatorProjection","geodeticLatitudeToMercatorAngle","includeGeodeticSurfaceNormals","dv","DataView","minHeight","Number","POSITIVE_INFINITY","maxHeight","NEGATIVE_INFINITY","x","y","z","quadSize","quad","offset","size","indicesSize","o","getUint32","getFloat64","c","getInt32","quadBorderPoints","quadBorderIndices","Array","westBorder","southBorder","eastBorder","northBorder","pointOffset","indicesOffset","startQuad","originX","originY","stepX","halfStepX","stepY","halfStepY","numPoints","numFaces","indicesMapping","getUint8","getFloat32","pow","abs","max","normal","geodeticSurfaceNormal","u","v","facesElementCount","getUint16","RuntimeError","vertexCountWithoutSkirts","indexCountWithoutSkirts","undefined","sort","a","b","percentage","firstBorderIndex","firstSkirtIndex","lastSkirtIndex","orientedBoundingBox","boundingSphere3D","BoundingSphere","fromPoints","OrientedBoundingBox","fromRectangle","occludeePointInScaledSpace","EllipsoidalOccluder","computeHorizonCullingPointPossiblyUnderEllipsoid","aaBox","AxisAlignedBoundingBox","encoding","TerrainEncoding","vertices","stride","bufferIndex","k","encode","westIndicesSouthToNorth","map","vertex","reverse","southIndicesEastToWest","eastIndicesNorthToSouth","northIndicesWestToEast","unshift","maximumHeight","minimumHeight","processBuffer","numberOfAttributes"],"mappings":"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"}