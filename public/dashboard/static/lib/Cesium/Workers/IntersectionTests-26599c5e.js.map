{"version":3,"file":"IntersectionTests-26599c5e.js","sources":["../../../../Source/Core/QuadraticRealPolynomial.js","../../../../Source/Core/CubicRealPolynomial.js","../../../../Source/Core/QuarticRealPolynomial.js","../../../../Source/Core/Ray.js","../../../../Source/Core/IntersectionTests.js"],"sourcesContent":["import DeveloperError from \"./DeveloperError.js\";\nimport CesiumMath from \"./Math.js\";\n\n/**\n * Defines functions for 2nd order polynomial functions of one variable with only real coefficients.\n *\n * @namespace QuadraticRealPolynomial\n */\nvar QuadraticRealPolynomial = {};\n\n/**\n * Provides the discriminant of the quadratic equation from the supplied coefficients.\n *\n * @param {Number} a The coefficient of the 2nd order monomial.\n * @param {Number} b The coefficient of the 1st order monomial.\n * @param {Number} c The coefficient of the 0th order monomial.\n * @returns {Number} The value of the discriminant.\n */\nQuadraticRealPolynomial.computeDiscriminant = function (a, b, c) {\n  //>>includeStart('debug', pragmas.debug);\n  if (typeof a !== \"number\") {\n    throw new DeveloperError(\"a is a required number.\");\n  }\n  if (typeof b !== \"number\") {\n    throw new DeveloperError(\"b is a required number.\");\n  }\n  if (typeof c !== \"number\") {\n    throw new DeveloperError(\"c is a required number.\");\n  }\n  //>>includeEnd('debug');\n\n  var discriminant = b * b - 4.0 * a * c;\n  return discriminant;\n};\n\nfunction addWithCancellationCheck(left, right, tolerance) {\n  var difference = left + right;\n  if (\n    CesiumMath.sign(left) !== CesiumMath.sign(right) &&\n    Math.abs(difference / Math.max(Math.abs(left), Math.abs(right))) < tolerance\n  ) {\n    return 0.0;\n  }\n\n  return difference;\n}\n\n/**\n * Provides the real valued roots of the quadratic polynomial with the provided coefficients.\n *\n * @param {Number} a The coefficient of the 2nd order monomial.\n * @param {Number} b The coefficient of the 1st order monomial.\n * @param {Number} c The coefficient of the 0th order monomial.\n * @returns {Number[]} The real valued roots.\n */\nQuadraticRealPolynomial.computeRealRoots = function (a, b, c) {\n  //>>includeStart('debug', pragmas.debug);\n  if (typeof a !== \"number\") {\n    throw new DeveloperError(\"a is a required number.\");\n  }\n  if (typeof b !== \"number\") {\n    throw new DeveloperError(\"b is a required number.\");\n  }\n  if (typeof c !== \"number\") {\n    throw new DeveloperError(\"c is a required number.\");\n  }\n  //>>includeEnd('debug');\n\n  var ratio;\n  if (a === 0.0) {\n    if (b === 0.0) {\n      // Constant function: c = 0.\n      return [];\n    }\n\n    // Linear function: b * x + c = 0.\n    return [-c / b];\n  } else if (b === 0.0) {\n    if (c === 0.0) {\n      // 2nd order monomial: a * x^2 = 0.\n      return [0.0, 0.0];\n    }\n\n    var cMagnitude = Math.abs(c);\n    var aMagnitude = Math.abs(a);\n\n    if (\n      cMagnitude < aMagnitude &&\n      cMagnitude / aMagnitude < CesiumMath.EPSILON14\n    ) {\n      // c ~= 0.0.\n      // 2nd order monomial: a * x^2 = 0.\n      return [0.0, 0.0];\n    } else if (\n      cMagnitude > aMagnitude &&\n      aMagnitude / cMagnitude < CesiumMath.EPSILON14\n    ) {\n      // a ~= 0.0.\n      // Constant function: c = 0.\n      return [];\n    }\n\n    // a * x^2 + c = 0\n    ratio = -c / a;\n\n    if (ratio < 0.0) {\n      // Both roots are complex.\n      return [];\n    }\n\n    // Both roots are real.\n    var root = Math.sqrt(ratio);\n    return [-root, root];\n  } else if (c === 0.0) {\n    // a * x^2 + b * x = 0\n    ratio = -b / a;\n    if (ratio < 0.0) {\n      return [ratio, 0.0];\n    }\n\n    return [0.0, ratio];\n  }\n\n  // a * x^2 + b * x + c = 0\n  var b2 = b * b;\n  var four_ac = 4.0 * a * c;\n  var radicand = addWithCancellationCheck(b2, -four_ac, CesiumMath.EPSILON14);\n\n  if (radicand < 0.0) {\n    // Both roots are complex.\n    return [];\n  }\n\n  var q =\n    -0.5 *\n    addWithCancellationCheck(\n      b,\n      CesiumMath.sign(b) * Math.sqrt(radicand),\n      CesiumMath.EPSILON14\n    );\n  if (b > 0.0) {\n    return [q / a, c / q];\n  }\n\n  return [c / q, q / a];\n};\nexport default QuadraticRealPolynomial;\n","import DeveloperError from \"./DeveloperError.js\";\nimport QuadraticRealPolynomial from \"./QuadraticRealPolynomial.js\";\n\n/**\n * Defines functions for 3rd order polynomial functions of one variable with only real coefficients.\n *\n * @namespace CubicRealPolynomial\n */\nvar CubicRealPolynomial = {};\n\n/**\n * Provides the discriminant of the cubic equation from the supplied coefficients.\n *\n * @param {Number} a The coefficient of the 3rd order monomial.\n * @param {Number} b The coefficient of the 2nd order monomial.\n * @param {Number} c The coefficient of the 1st order monomial.\n * @param {Number} d The coefficient of the 0th order monomial.\n * @returns {Number} The value of the discriminant.\n */\nCubicRealPolynomial.computeDiscriminant = function (a, b, c, d) {\n  //>>includeStart('debug', pragmas.debug);\n  if (typeof a !== \"number\") {\n    throw new DeveloperError(\"a is a required number.\");\n  }\n  if (typeof b !== \"number\") {\n    throw new DeveloperError(\"b is a required number.\");\n  }\n  if (typeof c !== \"number\") {\n    throw new DeveloperError(\"c is a required number.\");\n  }\n  if (typeof d !== \"number\") {\n    throw new DeveloperError(\"d is a required number.\");\n  }\n  //>>includeEnd('debug');\n\n  var a2 = a * a;\n  var b2 = b * b;\n  var c2 = c * c;\n  var d2 = d * d;\n\n  var discriminant =\n    18.0 * a * b * c * d +\n    b2 * c2 -\n    27.0 * a2 * d2 -\n    4.0 * (a * c2 * c + b2 * b * d);\n  return discriminant;\n};\n\nfunction computeRealRoots(a, b, c, d) {\n  var A = a;\n  var B = b / 3.0;\n  var C = c / 3.0;\n  var D = d;\n\n  var AC = A * C;\n  var BD = B * D;\n  var B2 = B * B;\n  var C2 = C * C;\n  var delta1 = A * C - B2;\n  var delta2 = A * D - B * C;\n  var delta3 = B * D - C2;\n\n  var discriminant = 4.0 * delta1 * delta3 - delta2 * delta2;\n  var temp;\n  var temp1;\n\n  if (discriminant < 0.0) {\n    var ABar;\n    var CBar;\n    var DBar;\n\n    if (B2 * BD >= AC * C2) {\n      ABar = A;\n      CBar = delta1;\n      DBar = -2.0 * B * delta1 + A * delta2;\n    } else {\n      ABar = D;\n      CBar = delta3;\n      DBar = -D * delta2 + 2.0 * C * delta3;\n    }\n\n    var s = DBar < 0.0 ? -1.0 : 1.0; // This is not Math.Sign()!\n    var temp0 = -s * Math.abs(ABar) * Math.sqrt(-discriminant);\n    temp1 = -DBar + temp0;\n\n    var x = temp1 / 2.0;\n    var p = x < 0.0 ? -Math.pow(-x, 1.0 / 3.0) : Math.pow(x, 1.0 / 3.0);\n    var q = temp1 === temp0 ? -p : -CBar / p;\n\n    temp = CBar <= 0.0 ? p + q : -DBar / (p * p + q * q + CBar);\n\n    if (B2 * BD >= AC * C2) {\n      return [(temp - B) / A];\n    }\n\n    return [-D / (temp + C)];\n  }\n\n  var CBarA = delta1;\n  var DBarA = -2.0 * B * delta1 + A * delta2;\n\n  var CBarD = delta3;\n  var DBarD = -D * delta2 + 2.0 * C * delta3;\n\n  var squareRootOfDiscriminant = Math.sqrt(discriminant);\n  var halfSquareRootOf3 = Math.sqrt(3.0) / 2.0;\n\n  var theta = Math.abs(Math.atan2(A * squareRootOfDiscriminant, -DBarA) / 3.0);\n  temp = 2.0 * Math.sqrt(-CBarA);\n  var cosine = Math.cos(theta);\n  temp1 = temp * cosine;\n  var temp3 = temp * (-cosine / 2.0 - halfSquareRootOf3 * Math.sin(theta));\n\n  var numeratorLarge = temp1 + temp3 > 2.0 * B ? temp1 - B : temp3 - B;\n  var denominatorLarge = A;\n\n  var root1 = numeratorLarge / denominatorLarge;\n\n  theta = Math.abs(Math.atan2(D * squareRootOfDiscriminant, -DBarD) / 3.0);\n  temp = 2.0 * Math.sqrt(-CBarD);\n  cosine = Math.cos(theta);\n  temp1 = temp * cosine;\n  temp3 = temp * (-cosine / 2.0 - halfSquareRootOf3 * Math.sin(theta));\n\n  var numeratorSmall = -D;\n  var denominatorSmall = temp1 + temp3 < 2.0 * C ? temp1 + C : temp3 + C;\n\n  var root3 = numeratorSmall / denominatorSmall;\n\n  var E = denominatorLarge * denominatorSmall;\n  var F =\n    -numeratorLarge * denominatorSmall - denominatorLarge * numeratorSmall;\n  var G = numeratorLarge * numeratorSmall;\n\n  var root2 = (C * F - B * G) / (-B * F + C * E);\n\n  if (root1 <= root2) {\n    if (root1 <= root3) {\n      if (root2 <= root3) {\n        return [root1, root2, root3];\n      }\n      return [root1, root3, root2];\n    }\n    return [root3, root1, root2];\n  }\n  if (root1 <= root3) {\n    return [root2, root1, root3];\n  }\n  if (root2 <= root3) {\n    return [root2, root3, root1];\n  }\n  return [root3, root2, root1];\n}\n\n/**\n * Provides the real valued roots of the cubic polynomial with the provided coefficients.\n *\n * @param {Number} a The coefficient of the 3rd order monomial.\n * @param {Number} b The coefficient of the 2nd order monomial.\n * @param {Number} c The coefficient of the 1st order monomial.\n * @param {Number} d The coefficient of the 0th order monomial.\n * @returns {Number[]} The real valued roots.\n */\nCubicRealPolynomial.computeRealRoots = function (a, b, c, d) {\n  //>>includeStart('debug', pragmas.debug);\n  if (typeof a !== \"number\") {\n    throw new DeveloperError(\"a is a required number.\");\n  }\n  if (typeof b !== \"number\") {\n    throw new DeveloperError(\"b is a required number.\");\n  }\n  if (typeof c !== \"number\") {\n    throw new DeveloperError(\"c is a required number.\");\n  }\n  if (typeof d !== \"number\") {\n    throw new DeveloperError(\"d is a required number.\");\n  }\n  //>>includeEnd('debug');\n\n  var roots;\n  var ratio;\n  if (a === 0.0) {\n    // Quadratic function: b * x^2 + c * x + d = 0.\n    return QuadraticRealPolynomial.computeRealRoots(b, c, d);\n  } else if (b === 0.0) {\n    if (c === 0.0) {\n      if (d === 0.0) {\n        // 3rd order monomial: a * x^3 = 0.\n        return [0.0, 0.0, 0.0];\n      }\n\n      // a * x^3 + d = 0\n      ratio = -d / a;\n      var root =\n        ratio < 0.0 ? -Math.pow(-ratio, 1.0 / 3.0) : Math.pow(ratio, 1.0 / 3.0);\n      return [root, root, root];\n    } else if (d === 0.0) {\n      // x * (a * x^2 + c) = 0.\n      roots = QuadraticRealPolynomial.computeRealRoots(a, 0, c);\n\n      // Return the roots in ascending order.\n      if (roots.Length === 0) {\n        return [0.0];\n      }\n      return [roots[0], 0.0, roots[1]];\n    }\n\n    // Deflated cubic polynomial: a * x^3 + c * x + d= 0.\n    return computeRealRoots(a, 0, c, d);\n  } else if (c === 0.0) {\n    if (d === 0.0) {\n      // x^2 * (a * x + b) = 0.\n      ratio = -b / a;\n      if (ratio < 0.0) {\n        return [ratio, 0.0, 0.0];\n      }\n      return [0.0, 0.0, ratio];\n    }\n    // a * x^3 + b * x^2 + d = 0.\n    return computeRealRoots(a, b, 0, d);\n  } else if (d === 0.0) {\n    // x * (a * x^2 + b * x + c) = 0\n    roots = QuadraticRealPolynomial.computeRealRoots(a, b, c);\n\n    // Return the roots in ascending order.\n    if (roots.length === 0) {\n      return [0.0];\n    } else if (roots[1] <= 0.0) {\n      return [roots[0], roots[1], 0.0];\n    } else if (roots[0] >= 0.0) {\n      return [0.0, roots[0], roots[1]];\n    }\n    return [roots[0], 0.0, roots[1]];\n  }\n\n  return computeRealRoots(a, b, c, d);\n};\nexport default CubicRealPolynomial;\n","import CubicRealPolynomial from \"./CubicRealPolynomial.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport CesiumMath from \"./Math.js\";\nimport QuadraticRealPolynomial from \"./QuadraticRealPolynomial.js\";\n\n/**\n * Defines functions for 4th order polynomial functions of one variable with only real coefficients.\n *\n * @namespace QuarticRealPolynomial\n */\nvar QuarticRealPolynomial = {};\n\n/**\n * Provides the discriminant of the quartic equation from the supplied coefficients.\n *\n * @param {Number} a The coefficient of the 4th order monomial.\n * @param {Number} b The coefficient of the 3rd order monomial.\n * @param {Number} c The coefficient of the 2nd order monomial.\n * @param {Number} d The coefficient of the 1st order monomial.\n * @param {Number} e The coefficient of the 0th order monomial.\n * @returns {Number} The value of the discriminant.\n */\nQuarticRealPolynomial.computeDiscriminant = function (a, b, c, d, e) {\n  //>>includeStart('debug', pragmas.debug);\n  if (typeof a !== \"number\") {\n    throw new DeveloperError(\"a is a required number.\");\n  }\n  if (typeof b !== \"number\") {\n    throw new DeveloperError(\"b is a required number.\");\n  }\n  if (typeof c !== \"number\") {\n    throw new DeveloperError(\"c is a required number.\");\n  }\n  if (typeof d !== \"number\") {\n    throw new DeveloperError(\"d is a required number.\");\n  }\n  if (typeof e !== \"number\") {\n    throw new DeveloperError(\"e is a required number.\");\n  }\n  //>>includeEnd('debug');\n\n  var a2 = a * a;\n  var a3 = a2 * a;\n  var b2 = b * b;\n  var b3 = b2 * b;\n  var c2 = c * c;\n  var c3 = c2 * c;\n  var d2 = d * d;\n  var d3 = d2 * d;\n  var e2 = e * e;\n  var e3 = e2 * e;\n\n  var discriminant =\n    b2 * c2 * d2 -\n    4.0 * b3 * d3 -\n    4.0 * a * c3 * d2 +\n    18 * a * b * c * d3 -\n    27.0 * a2 * d2 * d2 +\n    256.0 * a3 * e3 +\n    e *\n      (18.0 * b3 * c * d -\n        4.0 * b2 * c3 +\n        16.0 * a * c2 * c2 -\n        80.0 * a * b * c2 * d -\n        6.0 * a * b2 * d2 +\n        144.0 * a2 * c * d2) +\n    e2 *\n      (144.0 * a * b2 * c -\n        27.0 * b2 * b2 -\n        128.0 * a2 * c2 -\n        192.0 * a2 * b * d);\n  return discriminant;\n};\n\nfunction original(a3, a2, a1, a0) {\n  var a3Squared = a3 * a3;\n\n  var p = a2 - (3.0 * a3Squared) / 8.0;\n  var q = a1 - (a2 * a3) / 2.0 + (a3Squared * a3) / 8.0;\n  var r =\n    a0 -\n    (a1 * a3) / 4.0 +\n    (a2 * a3Squared) / 16.0 -\n    (3.0 * a3Squared * a3Squared) / 256.0;\n\n  // Find the roots of the cubic equations:  h^6 + 2 p h^4 + (p^2 - 4 r) h^2 - q^2 = 0.\n  var cubicRoots = CubicRealPolynomial.computeRealRoots(\n    1.0,\n    2.0 * p,\n    p * p - 4.0 * r,\n    -q * q\n  );\n\n  if (cubicRoots.length > 0) {\n    var temp = -a3 / 4.0;\n\n    // Use the largest positive root.\n    var hSquared = cubicRoots[cubicRoots.length - 1];\n\n    if (Math.abs(hSquared) < CesiumMath.EPSILON14) {\n      // y^4 + p y^2 + r = 0.\n      var roots = QuadraticRealPolynomial.computeRealRoots(1.0, p, r);\n\n      if (roots.length === 2) {\n        var root0 = roots[0];\n        var root1 = roots[1];\n\n        var y;\n        if (root0 >= 0.0 && root1 >= 0.0) {\n          var y0 = Math.sqrt(root0);\n          var y1 = Math.sqrt(root1);\n\n          return [temp - y1, temp - y0, temp + y0, temp + y1];\n        } else if (root0 >= 0.0 && root1 < 0.0) {\n          y = Math.sqrt(root0);\n          return [temp - y, temp + y];\n        } else if (root0 < 0.0 && root1 >= 0.0) {\n          y = Math.sqrt(root1);\n          return [temp - y, temp + y];\n        }\n      }\n      return [];\n    } else if (hSquared > 0.0) {\n      var h = Math.sqrt(hSquared);\n\n      var m = (p + hSquared - q / h) / 2.0;\n      var n = (p + hSquared + q / h) / 2.0;\n\n      // Now solve the two quadratic factors:  (y^2 + h y + m)(y^2 - h y + n);\n      var roots1 = QuadraticRealPolynomial.computeRealRoots(1.0, h, m);\n      var roots2 = QuadraticRealPolynomial.computeRealRoots(1.0, -h, n);\n\n      if (roots1.length !== 0) {\n        roots1[0] += temp;\n        roots1[1] += temp;\n\n        if (roots2.length !== 0) {\n          roots2[0] += temp;\n          roots2[1] += temp;\n\n          if (roots1[1] <= roots2[0]) {\n            return [roots1[0], roots1[1], roots2[0], roots2[1]];\n          } else if (roots2[1] <= roots1[0]) {\n            return [roots2[0], roots2[1], roots1[0], roots1[1]];\n          } else if (roots1[0] >= roots2[0] && roots1[1] <= roots2[1]) {\n            return [roots2[0], roots1[0], roots1[1], roots2[1]];\n          } else if (roots2[0] >= roots1[0] && roots2[1] <= roots1[1]) {\n            return [roots1[0], roots2[0], roots2[1], roots1[1]];\n          } else if (roots1[0] > roots2[0] && roots1[0] < roots2[1]) {\n            return [roots2[0], roots1[0], roots2[1], roots1[1]];\n          }\n          return [roots1[0], roots2[0], roots1[1], roots2[1]];\n        }\n        return roots1;\n      }\n\n      if (roots2.length !== 0) {\n        roots2[0] += temp;\n        roots2[1] += temp;\n\n        return roots2;\n      }\n      return [];\n    }\n  }\n  return [];\n}\n\nfunction neumark(a3, a2, a1, a0) {\n  var a1Squared = a1 * a1;\n  var a2Squared = a2 * a2;\n  var a3Squared = a3 * a3;\n\n  var p = -2.0 * a2;\n  var q = a1 * a3 + a2Squared - 4.0 * a0;\n  var r = a3Squared * a0 - a1 * a2 * a3 + a1Squared;\n\n  var cubicRoots = CubicRealPolynomial.computeRealRoots(1.0, p, q, r);\n\n  if (cubicRoots.length > 0) {\n    // Use the most positive root\n    var y = cubicRoots[0];\n\n    var temp = a2 - y;\n    var tempSquared = temp * temp;\n\n    var g1 = a3 / 2.0;\n    var h1 = temp / 2.0;\n\n    var m = tempSquared - 4.0 * a0;\n    var mError = tempSquared + 4.0 * Math.abs(a0);\n\n    var n = a3Squared - 4.0 * y;\n    var nError = a3Squared + 4.0 * Math.abs(y);\n\n    var g2;\n    var h2;\n\n    if (y < 0.0 || m * nError < n * mError) {\n      var squareRootOfN = Math.sqrt(n);\n      g2 = squareRootOfN / 2.0;\n      h2 = squareRootOfN === 0.0 ? 0.0 : (a3 * h1 - a1) / squareRootOfN;\n    } else {\n      var squareRootOfM = Math.sqrt(m);\n      g2 = squareRootOfM === 0.0 ? 0.0 : (a3 * h1 - a1) / squareRootOfM;\n      h2 = squareRootOfM / 2.0;\n    }\n\n    var G;\n    var g;\n    if (g1 === 0.0 && g2 === 0.0) {\n      G = 0.0;\n      g = 0.0;\n    } else if (CesiumMath.sign(g1) === CesiumMath.sign(g2)) {\n      G = g1 + g2;\n      g = y / G;\n    } else {\n      g = g1 - g2;\n      G = y / g;\n    }\n\n    var H;\n    var h;\n    if (h1 === 0.0 && h2 === 0.0) {\n      H = 0.0;\n      h = 0.0;\n    } else if (CesiumMath.sign(h1) === CesiumMath.sign(h2)) {\n      H = h1 + h2;\n      h = a0 / H;\n    } else {\n      h = h1 - h2;\n      H = a0 / h;\n    }\n\n    // Now solve the two quadratic factors:  (y^2 + G y + H)(y^2 + g y + h);\n    var roots1 = QuadraticRealPolynomial.computeRealRoots(1.0, G, H);\n    var roots2 = QuadraticRealPolynomial.computeRealRoots(1.0, g, h);\n\n    if (roots1.length !== 0) {\n      if (roots2.length !== 0) {\n        if (roots1[1] <= roots2[0]) {\n          return [roots1[0], roots1[1], roots2[0], roots2[1]];\n        } else if (roots2[1] <= roots1[0]) {\n          return [roots2[0], roots2[1], roots1[0], roots1[1]];\n        } else if (roots1[0] >= roots2[0] && roots1[1] <= roots2[1]) {\n          return [roots2[0], roots1[0], roots1[1], roots2[1]];\n        } else if (roots2[0] >= roots1[0] && roots2[1] <= roots1[1]) {\n          return [roots1[0], roots2[0], roots2[1], roots1[1]];\n        } else if (roots1[0] > roots2[0] && roots1[0] < roots2[1]) {\n          return [roots2[0], roots1[0], roots2[1], roots1[1]];\n        }\n        return [roots1[0], roots2[0], roots1[1], roots2[1]];\n      }\n      return roots1;\n    }\n    if (roots2.length !== 0) {\n      return roots2;\n    }\n  }\n  return [];\n}\n\n/**\n * Provides the real valued roots of the quartic polynomial with the provided coefficients.\n *\n * @param {Number} a The coefficient of the 4th order monomial.\n * @param {Number} b The coefficient of the 3rd order monomial.\n * @param {Number} c The coefficient of the 2nd order monomial.\n * @param {Number} d The coefficient of the 1st order monomial.\n * @param {Number} e The coefficient of the 0th order monomial.\n * @returns {Number[]} The real valued roots.\n */\nQuarticRealPolynomial.computeRealRoots = function (a, b, c, d, e) {\n  //>>includeStart('debug', pragmas.debug);\n  if (typeof a !== \"number\") {\n    throw new DeveloperError(\"a is a required number.\");\n  }\n  if (typeof b !== \"number\") {\n    throw new DeveloperError(\"b is a required number.\");\n  }\n  if (typeof c !== \"number\") {\n    throw new DeveloperError(\"c is a required number.\");\n  }\n  if (typeof d !== \"number\") {\n    throw new DeveloperError(\"d is a required number.\");\n  }\n  if (typeof e !== \"number\") {\n    throw new DeveloperError(\"e is a required number.\");\n  }\n  //>>includeEnd('debug');\n\n  if (Math.abs(a) < CesiumMath.EPSILON15) {\n    return CubicRealPolynomial.computeRealRoots(b, c, d, e);\n  }\n  var a3 = b / a;\n  var a2 = c / a;\n  var a1 = d / a;\n  var a0 = e / a;\n\n  var k = a3 < 0.0 ? 1 : 0;\n  k += a2 < 0.0 ? k + 1 : k;\n  k += a1 < 0.0 ? k + 1 : k;\n  k += a0 < 0.0 ? k + 1 : k;\n\n  switch (k) {\n    case 0:\n      return original(a3, a2, a1, a0);\n    case 1:\n      return neumark(a3, a2, a1, a0);\n    case 2:\n      return neumark(a3, a2, a1, a0);\n    case 3:\n      return original(a3, a2, a1, a0);\n    case 4:\n      return original(a3, a2, a1, a0);\n    case 5:\n      return neumark(a3, a2, a1, a0);\n    case 6:\n      return original(a3, a2, a1, a0);\n    case 7:\n      return original(a3, a2, a1, a0);\n    case 8:\n      return neumark(a3, a2, a1, a0);\n    case 9:\n      return original(a3, a2, a1, a0);\n    case 10:\n      return original(a3, a2, a1, a0);\n    case 11:\n      return neumark(a3, a2, a1, a0);\n    case 12:\n      return original(a3, a2, a1, a0);\n    case 13:\n      return original(a3, a2, a1, a0);\n    case 14:\n      return original(a3, a2, a1, a0);\n    case 15:\n      return original(a3, a2, a1, a0);\n    default:\n      return undefined;\n  }\n};\nexport default QuarticRealPolynomial;\n","import Cartesian3 from \"./Cartesian3.js\";\nimport Check from \"./Check.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\n\n/**\n * Represents a ray that extends infinitely from the provided origin in the provided direction.\n * @alias Ray\n * @constructor\n *\n * @param {Cartesian3} [origin=Cartesian3.ZERO] The origin of the ray.\n * @param {Cartesian3} [direction=Cartesian3.ZERO] The direction of the ray.\n */\nfunction Ray(origin, direction) {\n  direction = Cartesian3.clone(defaultValue(direction, Cartesian3.ZERO));\n  if (!Cartesian3.equals(direction, Cartesian3.ZERO)) {\n    Cartesian3.normalize(direction, direction);\n  }\n\n  /**\n   * The origin of the ray.\n   * @type {Cartesian3}\n   * @default {@link Cartesian3.ZERO}\n   */\n  this.origin = Cartesian3.clone(defaultValue(origin, Cartesian3.ZERO));\n\n  /**\n   * The direction of the ray.\n   * @type {Cartesian3}\n   */\n  this.direction = direction;\n}\n\n/**\n * Duplicates a Ray instance.\n *\n * @param {Ray} ray The ray to duplicate.\n * @param {Ray} [result] The object onto which to store the result.\n * @returns {Ray} The modified result parameter or a new Ray instance if one was not provided. (Returns undefined if ray is undefined)\n */\nRay.clone = function (ray, result) {\n  if (!defined(ray)) {\n    return undefined;\n  }\n  if (!defined(result)) {\n    return new Ray(ray.origin, ray.direction);\n  }\n  result.origin = Cartesian3.clone(ray.origin);\n  result.direction = Cartesian3.clone(ray.direction);\n  return result;\n};\n\n/**\n * Computes the point along the ray given by r(t) = o + t*d,\n * where o is the origin of the ray and d is the direction.\n *\n * @param {Ray} ray The ray.\n * @param {Number} t A scalar value.\n * @param {Cartesian3} [result] The object in which the result will be stored.\n * @returns {Cartesian3} The modified result parameter, or a new instance if none was provided.\n *\n * @example\n * //Get the first intersection point of a ray and an ellipsoid.\n * var intersection = Cesium.IntersectionTests.rayEllipsoid(ray, ellipsoid);\n * var point = Cesium.Ray.getPoint(ray, intersection.start);\n */\nRay.getPoint = function (ray, t, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"ray\", ray);\n  Check.typeOf.number(\"t\", t);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n\n  result = Cartesian3.multiplyByScalar(ray.direction, t, result);\n  return Cartesian3.add(ray.origin, result, result);\n};\nexport default Ray;\n","import Cartesian3 from \"./Cartesian3.js\";\nimport Cartographic from \"./Cartographic.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Interval from \"./Interval.js\";\nimport CesiumMath from \"./Math.js\";\nimport Matrix3 from \"./Matrix3.js\";\nimport QuadraticRealPolynomial from \"./QuadraticRealPolynomial.js\";\nimport QuarticRealPolynomial from \"./QuarticRealPolynomial.js\";\nimport Ray from \"./Ray.js\";\n\n/**\n * Functions for computing the intersection between geometries such as rays, planes, triangles, and ellipsoids.\n *\n * @namespace IntersectionTests\n */\nvar IntersectionTests = {};\n\n/**\n * Computes the intersection of a ray and a plane.\n *\n * @param {Ray} ray The ray.\n * @param {Plane} plane The plane.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The intersection point or undefined if there is no intersections.\n */\nIntersectionTests.rayPlane = function (ray, plane, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(ray)) {\n    throw new DeveloperError(\"ray is required.\");\n  }\n  if (!defined(plane)) {\n    throw new DeveloperError(\"plane is required.\");\n  }\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n\n  var origin = ray.origin;\n  var direction = ray.direction;\n  var normal = plane.normal;\n  var denominator = Cartesian3.dot(normal, direction);\n\n  if (Math.abs(denominator) < CesiumMath.EPSILON15) {\n    // Ray is parallel to plane.  The ray may be in the polygon's plane.\n    return undefined;\n  }\n\n  var t = (-plane.distance - Cartesian3.dot(normal, origin)) / denominator;\n\n  if (t < 0) {\n    return undefined;\n  }\n\n  result = Cartesian3.multiplyByScalar(direction, t, result);\n  return Cartesian3.add(origin, result, result);\n};\n\nvar scratchEdge0 = new Cartesian3();\nvar scratchEdge1 = new Cartesian3();\nvar scratchPVec = new Cartesian3();\nvar scratchTVec = new Cartesian3();\nvar scratchQVec = new Cartesian3();\n\n/**\n * Computes the intersection of a ray and a triangle as a parametric distance along the input ray. The result is negative when the triangle is behind the ray.\n *\n * Implements {@link https://cadxfem.org/inf/Fast%20MinimumStorage%20RayTriangle%20Intersection.pdf|\n * Fast Minimum Storage Ray/Triangle Intersection} by Tomas Moller and Ben Trumbore.\n *\n * @memberof IntersectionTests\n *\n * @param {Ray} ray The ray.\n * @param {Cartesian3} p0 The first vertex of the triangle.\n * @param {Cartesian3} p1 The second vertex of the triangle.\n * @param {Cartesian3} p2 The third vertex of the triangle.\n * @param {Boolean} [cullBackFaces=false] If <code>true</code>, will only compute an intersection with the front face of the triangle\n *                  and return undefined for intersections with the back face.\n * @returns {Number} The intersection as a parametric distance along the ray, or undefined if there is no intersection.\n */\nIntersectionTests.rayTriangleParametric = function (\n  ray,\n  p0,\n  p1,\n  p2,\n  cullBackFaces\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(ray)) {\n    throw new DeveloperError(\"ray is required.\");\n  }\n  if (!defined(p0)) {\n    throw new DeveloperError(\"p0 is required.\");\n  }\n  if (!defined(p1)) {\n    throw new DeveloperError(\"p1 is required.\");\n  }\n  if (!defined(p2)) {\n    throw new DeveloperError(\"p2 is required.\");\n  }\n  //>>includeEnd('debug');\n\n  cullBackFaces = defaultValue(cullBackFaces, false);\n\n  var origin = ray.origin;\n  var direction = ray.direction;\n\n  var edge0 = Cartesian3.subtract(p1, p0, scratchEdge0);\n  var edge1 = Cartesian3.subtract(p2, p0, scratchEdge1);\n\n  var p = Cartesian3.cross(direction, edge1, scratchPVec);\n  var det = Cartesian3.dot(edge0, p);\n\n  var tvec;\n  var q;\n\n  var u;\n  var v;\n  var t;\n\n  if (cullBackFaces) {\n    if (det < CesiumMath.EPSILON6) {\n      return undefined;\n    }\n\n    tvec = Cartesian3.subtract(origin, p0, scratchTVec);\n    u = Cartesian3.dot(tvec, p);\n    if (u < 0.0 || u > det) {\n      return undefined;\n    }\n\n    q = Cartesian3.cross(tvec, edge0, scratchQVec);\n\n    v = Cartesian3.dot(direction, q);\n    if (v < 0.0 || u + v > det) {\n      return undefined;\n    }\n\n    t = Cartesian3.dot(edge1, q) / det;\n  } else {\n    if (Math.abs(det) < CesiumMath.EPSILON6) {\n      return undefined;\n    }\n    var invDet = 1.0 / det;\n\n    tvec = Cartesian3.subtract(origin, p0, scratchTVec);\n    u = Cartesian3.dot(tvec, p) * invDet;\n    if (u < 0.0 || u > 1.0) {\n      return undefined;\n    }\n\n    q = Cartesian3.cross(tvec, edge0, scratchQVec);\n\n    v = Cartesian3.dot(direction, q) * invDet;\n    if (v < 0.0 || u + v > 1.0) {\n      return undefined;\n    }\n\n    t = Cartesian3.dot(edge1, q) * invDet;\n  }\n\n  return t;\n};\n\n/**\n * Computes the intersection of a ray and a triangle as a Cartesian3 coordinate.\n *\n * Implements {@link https://cadxfem.org/inf/Fast%20MinimumStorage%20RayTriangle%20Intersection.pdf|\n * Fast Minimum Storage Ray/Triangle Intersection} by Tomas Moller and Ben Trumbore.\n *\n * @memberof IntersectionTests\n *\n * @param {Ray} ray The ray.\n * @param {Cartesian3} p0 The first vertex of the triangle.\n * @param {Cartesian3} p1 The second vertex of the triangle.\n * @param {Cartesian3} p2 The third vertex of the triangle.\n * @param {Boolean} [cullBackFaces=false] If <code>true</code>, will only compute an intersection with the front face of the triangle\n *                  and return undefined for intersections with the back face.\n * @param {Cartesian3} [result] The <code>Cartesian3</code> onto which to store the result.\n * @returns {Cartesian3} The intersection point or undefined if there is no intersections.\n */\nIntersectionTests.rayTriangle = function (\n  ray,\n  p0,\n  p1,\n  p2,\n  cullBackFaces,\n  result\n) {\n  var t = IntersectionTests.rayTriangleParametric(\n    ray,\n    p0,\n    p1,\n    p2,\n    cullBackFaces\n  );\n  if (!defined(t) || t < 0.0) {\n    return undefined;\n  }\n\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n\n  Cartesian3.multiplyByScalar(ray.direction, t, result);\n  return Cartesian3.add(ray.origin, result, result);\n};\n\nvar scratchLineSegmentTriangleRay = new Ray();\n\n/**\n * Computes the intersection of a line segment and a triangle.\n * @memberof IntersectionTests\n *\n * @param {Cartesian3} v0 The an end point of the line segment.\n * @param {Cartesian3} v1 The other end point of the line segment.\n * @param {Cartesian3} p0 The first vertex of the triangle.\n * @param {Cartesian3} p1 The second vertex of the triangle.\n * @param {Cartesian3} p2 The third vertex of the triangle.\n * @param {Boolean} [cullBackFaces=false] If <code>true</code>, will only compute an intersection with the front face of the triangle\n *                  and return undefined for intersections with the back face.\n * @param {Cartesian3} [result] The <code>Cartesian3</code> onto which to store the result.\n * @returns {Cartesian3} The intersection point or undefined if there is no intersections.\n */\nIntersectionTests.lineSegmentTriangle = function (\n  v0,\n  v1,\n  p0,\n  p1,\n  p2,\n  cullBackFaces,\n  result\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(v0)) {\n    throw new DeveloperError(\"v0 is required.\");\n  }\n  if (!defined(v1)) {\n    throw new DeveloperError(\"v1 is required.\");\n  }\n  if (!defined(p0)) {\n    throw new DeveloperError(\"p0 is required.\");\n  }\n  if (!defined(p1)) {\n    throw new DeveloperError(\"p1 is required.\");\n  }\n  if (!defined(p2)) {\n    throw new DeveloperError(\"p2 is required.\");\n  }\n  //>>includeEnd('debug');\n\n  var ray = scratchLineSegmentTriangleRay;\n  Cartesian3.clone(v0, ray.origin);\n  Cartesian3.subtract(v1, v0, ray.direction);\n  Cartesian3.normalize(ray.direction, ray.direction);\n\n  var t = IntersectionTests.rayTriangleParametric(\n    ray,\n    p0,\n    p1,\n    p2,\n    cullBackFaces\n  );\n  if (!defined(t) || t < 0.0 || t > Cartesian3.distance(v0, v1)) {\n    return undefined;\n  }\n\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n\n  Cartesian3.multiplyByScalar(ray.direction, t, result);\n  return Cartesian3.add(ray.origin, result, result);\n};\n\nfunction solveQuadratic(a, b, c, result) {\n  var det = b * b - 4.0 * a * c;\n  if (det < 0.0) {\n    return undefined;\n  } else if (det > 0.0) {\n    var denom = 1.0 / (2.0 * a);\n    var disc = Math.sqrt(det);\n    var root0 = (-b + disc) * denom;\n    var root1 = (-b - disc) * denom;\n\n    if (root0 < root1) {\n      result.root0 = root0;\n      result.root1 = root1;\n    } else {\n      result.root0 = root1;\n      result.root1 = root0;\n    }\n\n    return result;\n  }\n\n  var root = -b / (2.0 * a);\n  if (root === 0.0) {\n    return undefined;\n  }\n\n  result.root0 = result.root1 = root;\n  return result;\n}\n\nvar raySphereRoots = {\n  root0: 0.0,\n  root1: 0.0,\n};\n\nfunction raySphere(ray, sphere, result) {\n  if (!defined(result)) {\n    result = new Interval();\n  }\n\n  var origin = ray.origin;\n  var direction = ray.direction;\n\n  var center = sphere.center;\n  var radiusSquared = sphere.radius * sphere.radius;\n\n  var diff = Cartesian3.subtract(origin, center, scratchPVec);\n\n  var a = Cartesian3.dot(direction, direction);\n  var b = 2.0 * Cartesian3.dot(direction, diff);\n  var c = Cartesian3.magnitudeSquared(diff) - radiusSquared;\n\n  var roots = solveQuadratic(a, b, c, raySphereRoots);\n  if (!defined(roots)) {\n    return undefined;\n  }\n\n  result.start = roots.root0;\n  result.stop = roots.root1;\n  return result;\n}\n\n/**\n * Computes the intersection points of a ray with a sphere.\n * @memberof IntersectionTests\n *\n * @param {Ray} ray The ray.\n * @param {BoundingSphere} sphere The sphere.\n * @param {Interval} [result] The result onto which to store the result.\n * @returns {Interval} The interval containing scalar points along the ray or undefined if there are no intersections.\n */\nIntersectionTests.raySphere = function (ray, sphere, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(ray)) {\n    throw new DeveloperError(\"ray is required.\");\n  }\n  if (!defined(sphere)) {\n    throw new DeveloperError(\"sphere is required.\");\n  }\n  //>>includeEnd('debug');\n\n  result = raySphere(ray, sphere, result);\n  if (!defined(result) || result.stop < 0.0) {\n    return undefined;\n  }\n\n  result.start = Math.max(result.start, 0.0);\n  return result;\n};\n\nvar scratchLineSegmentRay = new Ray();\n\n/**\n * Computes the intersection points of a line segment with a sphere.\n * @memberof IntersectionTests\n *\n * @param {Cartesian3} p0 An end point of the line segment.\n * @param {Cartesian3} p1 The other end point of the line segment.\n * @param {BoundingSphere} sphere The sphere.\n * @param {Interval} [result] The result onto which to store the result.\n * @returns {Interval} The interval containing scalar points along the ray or undefined if there are no intersections.\n */\nIntersectionTests.lineSegmentSphere = function (p0, p1, sphere, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(p0)) {\n    throw new DeveloperError(\"p0 is required.\");\n  }\n  if (!defined(p1)) {\n    throw new DeveloperError(\"p1 is required.\");\n  }\n  if (!defined(sphere)) {\n    throw new DeveloperError(\"sphere is required.\");\n  }\n  //>>includeEnd('debug');\n\n  var ray = scratchLineSegmentRay;\n  Cartesian3.clone(p0, ray.origin);\n  var direction = Cartesian3.subtract(p1, p0, ray.direction);\n\n  var maxT = Cartesian3.magnitude(direction);\n  Cartesian3.normalize(direction, direction);\n\n  result = raySphere(ray, sphere, result);\n  if (!defined(result) || result.stop < 0.0 || result.start > maxT) {\n    return undefined;\n  }\n\n  result.start = Math.max(result.start, 0.0);\n  result.stop = Math.min(result.stop, maxT);\n  return result;\n};\n\nvar scratchQ = new Cartesian3();\nvar scratchW = new Cartesian3();\n\n/**\n * Computes the intersection points of a ray with an ellipsoid.\n *\n * @param {Ray} ray The ray.\n * @param {Ellipsoid} ellipsoid The ellipsoid.\n * @returns {Interval} The interval containing scalar points along the ray or undefined if there are no intersections.\n */\nIntersectionTests.rayEllipsoid = function (ray, ellipsoid) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(ray)) {\n    throw new DeveloperError(\"ray is required.\");\n  }\n  if (!defined(ellipsoid)) {\n    throw new DeveloperError(\"ellipsoid is required.\");\n  }\n  //>>includeEnd('debug');\n\n  var inverseRadii = ellipsoid.oneOverRadii;\n  var q = Cartesian3.multiplyComponents(inverseRadii, ray.origin, scratchQ);\n  var w = Cartesian3.multiplyComponents(inverseRadii, ray.direction, scratchW);\n\n  var q2 = Cartesian3.magnitudeSquared(q);\n  var qw = Cartesian3.dot(q, w);\n\n  var difference, w2, product, discriminant, temp;\n\n  if (q2 > 1.0) {\n    // Outside ellipsoid.\n    if (qw >= 0.0) {\n      // Looking outward or tangent (0 intersections).\n      return undefined;\n    }\n\n    // qw < 0.0.\n    var qw2 = qw * qw;\n    difference = q2 - 1.0; // Positively valued.\n    w2 = Cartesian3.magnitudeSquared(w);\n    product = w2 * difference;\n\n    if (qw2 < product) {\n      // Imaginary roots (0 intersections).\n      return undefined;\n    } else if (qw2 > product) {\n      // Distinct roots (2 intersections).\n      discriminant = qw * qw - product;\n      temp = -qw + Math.sqrt(discriminant); // Avoid cancellation.\n      var root0 = temp / w2;\n      var root1 = difference / temp;\n      if (root0 < root1) {\n        return new Interval(root0, root1);\n      }\n\n      return {\n        start: root1,\n        stop: root0,\n      };\n    }\n    // qw2 == product.  Repeated roots (2 intersections).\n    var root = Math.sqrt(difference / w2);\n    return new Interval(root, root);\n  } else if (q2 < 1.0) {\n    // Inside ellipsoid (2 intersections).\n    difference = q2 - 1.0; // Negatively valued.\n    w2 = Cartesian3.magnitudeSquared(w);\n    product = w2 * difference; // Negatively valued.\n\n    discriminant = qw * qw - product;\n    temp = -qw + Math.sqrt(discriminant); // Positively valued.\n    return new Interval(0.0, temp / w2);\n  }\n  // q2 == 1.0. On ellipsoid.\n  if (qw < 0.0) {\n    // Looking inward.\n    w2 = Cartesian3.magnitudeSquared(w);\n    return new Interval(0.0, -qw / w2);\n  }\n\n  // qw >= 0.0.  Looking outward or tangent.\n  return undefined;\n};\n\nfunction addWithCancellationCheck(left, right, tolerance) {\n  var difference = left + right;\n  if (\n    CesiumMath.sign(left) !== CesiumMath.sign(right) &&\n    Math.abs(difference / Math.max(Math.abs(left), Math.abs(right))) < tolerance\n  ) {\n    return 0.0;\n  }\n\n  return difference;\n}\n\nfunction quadraticVectorExpression(A, b, c, x, w) {\n  var xSquared = x * x;\n  var wSquared = w * w;\n\n  var l2 = (A[Matrix3.COLUMN1ROW1] - A[Matrix3.COLUMN2ROW2]) * wSquared;\n  var l1 =\n    w *\n    (x *\n      addWithCancellationCheck(\n        A[Matrix3.COLUMN1ROW0],\n        A[Matrix3.COLUMN0ROW1],\n        CesiumMath.EPSILON15\n      ) +\n      b.y);\n  var l0 =\n    A[Matrix3.COLUMN0ROW0] * xSquared +\n    A[Matrix3.COLUMN2ROW2] * wSquared +\n    x * b.x +\n    c;\n\n  var r1 =\n    wSquared *\n    addWithCancellationCheck(\n      A[Matrix3.COLUMN2ROW1],\n      A[Matrix3.COLUMN1ROW2],\n      CesiumMath.EPSILON15\n    );\n  var r0 =\n    w *\n    (x *\n      addWithCancellationCheck(A[Matrix3.COLUMN2ROW0], A[Matrix3.COLUMN0ROW2]) +\n      b.z);\n\n  var cosines;\n  var solutions = [];\n  if (r0 === 0.0 && r1 === 0.0) {\n    cosines = QuadraticRealPolynomial.computeRealRoots(l2, l1, l0);\n    if (cosines.length === 0) {\n      return solutions;\n    }\n\n    var cosine0 = cosines[0];\n    var sine0 = Math.sqrt(Math.max(1.0 - cosine0 * cosine0, 0.0));\n    solutions.push(new Cartesian3(x, w * cosine0, w * -sine0));\n    solutions.push(new Cartesian3(x, w * cosine0, w * sine0));\n\n    if (cosines.length === 2) {\n      var cosine1 = cosines[1];\n      var sine1 = Math.sqrt(Math.max(1.0 - cosine1 * cosine1, 0.0));\n      solutions.push(new Cartesian3(x, w * cosine1, w * -sine1));\n      solutions.push(new Cartesian3(x, w * cosine1, w * sine1));\n    }\n\n    return solutions;\n  }\n\n  var r0Squared = r0 * r0;\n  var r1Squared = r1 * r1;\n  var l2Squared = l2 * l2;\n  var r0r1 = r0 * r1;\n\n  var c4 = l2Squared + r1Squared;\n  var c3 = 2.0 * (l1 * l2 + r0r1);\n  var c2 = 2.0 * l0 * l2 + l1 * l1 - r1Squared + r0Squared;\n  var c1 = 2.0 * (l0 * l1 - r0r1);\n  var c0 = l0 * l0 - r0Squared;\n\n  if (c4 === 0.0 && c3 === 0.0 && c2 === 0.0 && c1 === 0.0) {\n    return solutions;\n  }\n\n  cosines = QuarticRealPolynomial.computeRealRoots(c4, c3, c2, c1, c0);\n  var length = cosines.length;\n  if (length === 0) {\n    return solutions;\n  }\n\n  for (var i = 0; i < length; ++i) {\n    var cosine = cosines[i];\n    var cosineSquared = cosine * cosine;\n    var sineSquared = Math.max(1.0 - cosineSquared, 0.0);\n    var sine = Math.sqrt(sineSquared);\n\n    //var left = l2 * cosineSquared + l1 * cosine + l0;\n    var left;\n    if (CesiumMath.sign(l2) === CesiumMath.sign(l0)) {\n      left = addWithCancellationCheck(\n        l2 * cosineSquared + l0,\n        l1 * cosine,\n        CesiumMath.EPSILON12\n      );\n    } else if (CesiumMath.sign(l0) === CesiumMath.sign(l1 * cosine)) {\n      left = addWithCancellationCheck(\n        l2 * cosineSquared,\n        l1 * cosine + l0,\n        CesiumMath.EPSILON12\n      );\n    } else {\n      left = addWithCancellationCheck(\n        l2 * cosineSquared + l1 * cosine,\n        l0,\n        CesiumMath.EPSILON12\n      );\n    }\n\n    var right = addWithCancellationCheck(r1 * cosine, r0, CesiumMath.EPSILON15);\n    var product = left * right;\n\n    if (product < 0.0) {\n      solutions.push(new Cartesian3(x, w * cosine, w * sine));\n    } else if (product > 0.0) {\n      solutions.push(new Cartesian3(x, w * cosine, w * -sine));\n    } else if (sine !== 0.0) {\n      solutions.push(new Cartesian3(x, w * cosine, w * -sine));\n      solutions.push(new Cartesian3(x, w * cosine, w * sine));\n      ++i;\n    } else {\n      solutions.push(new Cartesian3(x, w * cosine, w * sine));\n    }\n  }\n\n  return solutions;\n}\n\nvar firstAxisScratch = new Cartesian3();\nvar secondAxisScratch = new Cartesian3();\nvar thirdAxisScratch = new Cartesian3();\nvar referenceScratch = new Cartesian3();\nvar bCart = new Cartesian3();\nvar bScratch = new Matrix3();\nvar btScratch = new Matrix3();\nvar diScratch = new Matrix3();\nvar dScratch = new Matrix3();\nvar cScratch = new Matrix3();\nvar tempMatrix = new Matrix3();\nvar aScratch = new Matrix3();\nvar sScratch = new Cartesian3();\nvar closestScratch = new Cartesian3();\nvar surfPointScratch = new Cartographic();\n\n/**\n * Provides the point along the ray which is nearest to the ellipsoid.\n *\n * @param {Ray} ray The ray.\n * @param {Ellipsoid} ellipsoid The ellipsoid.\n * @returns {Cartesian3} The nearest planetodetic point on the ray.\n */\nIntersectionTests.grazingAltitudeLocation = function (ray, ellipsoid) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(ray)) {\n    throw new DeveloperError(\"ray is required.\");\n  }\n  if (!defined(ellipsoid)) {\n    throw new DeveloperError(\"ellipsoid is required.\");\n  }\n  //>>includeEnd('debug');\n\n  var position = ray.origin;\n  var direction = ray.direction;\n\n  if (!Cartesian3.equals(position, Cartesian3.ZERO)) {\n    var normal = ellipsoid.geodeticSurfaceNormal(position, firstAxisScratch);\n    if (Cartesian3.dot(direction, normal) >= 0.0) {\n      // The location provided is the closest point in altitude\n      return position;\n    }\n  }\n\n  var intersects = defined(this.rayEllipsoid(ray, ellipsoid));\n\n  // Compute the scaled direction vector.\n  var f = ellipsoid.transformPositionToScaledSpace(direction, firstAxisScratch);\n\n  // Constructs a basis from the unit scaled direction vector. Construct its rotation and transpose.\n  var firstAxis = Cartesian3.normalize(f, f);\n  var reference = Cartesian3.mostOrthogonalAxis(f, referenceScratch);\n  var secondAxis = Cartesian3.normalize(\n    Cartesian3.cross(reference, firstAxis, secondAxisScratch),\n    secondAxisScratch\n  );\n  var thirdAxis = Cartesian3.normalize(\n    Cartesian3.cross(firstAxis, secondAxis, thirdAxisScratch),\n    thirdAxisScratch\n  );\n  var B = bScratch;\n  B[0] = firstAxis.x;\n  B[1] = firstAxis.y;\n  B[2] = firstAxis.z;\n  B[3] = secondAxis.x;\n  B[4] = secondAxis.y;\n  B[5] = secondAxis.z;\n  B[6] = thirdAxis.x;\n  B[7] = thirdAxis.y;\n  B[8] = thirdAxis.z;\n\n  var B_T = Matrix3.transpose(B, btScratch);\n\n  // Get the scaling matrix and its inverse.\n  var D_I = Matrix3.fromScale(ellipsoid.radii, diScratch);\n  var D = Matrix3.fromScale(ellipsoid.oneOverRadii, dScratch);\n\n  var C = cScratch;\n  C[0] = 0.0;\n  C[1] = -direction.z;\n  C[2] = direction.y;\n  C[3] = direction.z;\n  C[4] = 0.0;\n  C[5] = -direction.x;\n  C[6] = -direction.y;\n  C[7] = direction.x;\n  C[8] = 0.0;\n\n  var temp = Matrix3.multiply(\n    Matrix3.multiply(B_T, D, tempMatrix),\n    C,\n    tempMatrix\n  );\n  var A = Matrix3.multiply(Matrix3.multiply(temp, D_I, aScratch), B, aScratch);\n  var b = Matrix3.multiplyByVector(temp, position, bCart);\n\n  // Solve for the solutions to the expression in standard form:\n  var solutions = quadraticVectorExpression(\n    A,\n    Cartesian3.negate(b, firstAxisScratch),\n    0.0,\n    0.0,\n    1.0\n  );\n\n  var s;\n  var altitude;\n  var length = solutions.length;\n  if (length > 0) {\n    var closest = Cartesian3.clone(Cartesian3.ZERO, closestScratch);\n    var maximumValue = Number.NEGATIVE_INFINITY;\n\n    for (var i = 0; i < length; ++i) {\n      s = Matrix3.multiplyByVector(\n        D_I,\n        Matrix3.multiplyByVector(B, solutions[i], sScratch),\n        sScratch\n      );\n      var v = Cartesian3.normalize(\n        Cartesian3.subtract(s, position, referenceScratch),\n        referenceScratch\n      );\n      var dotProduct = Cartesian3.dot(v, direction);\n\n      if (dotProduct > maximumValue) {\n        maximumValue = dotProduct;\n        closest = Cartesian3.clone(s, closest);\n      }\n    }\n\n    var surfacePoint = ellipsoid.cartesianToCartographic(\n      closest,\n      surfPointScratch\n    );\n    maximumValue = CesiumMath.clamp(maximumValue, 0.0, 1.0);\n    altitude =\n      Cartesian3.magnitude(\n        Cartesian3.subtract(closest, position, referenceScratch)\n      ) * Math.sqrt(1.0 - maximumValue * maximumValue);\n    altitude = intersects ? -altitude : altitude;\n    surfacePoint.height = altitude;\n    return ellipsoid.cartographicToCartesian(surfacePoint, new Cartesian3());\n  }\n\n  return undefined;\n};\n\nvar lineSegmentPlaneDifference = new Cartesian3();\n\n/**\n * Computes the intersection of a line segment and a plane.\n *\n * @param {Cartesian3} endPoint0 An end point of the line segment.\n * @param {Cartesian3} endPoint1 The other end point of the line segment.\n * @param {Plane} plane The plane.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The intersection point or undefined if there is no intersection.\n *\n * @example\n * var origin = Cesium.Cartesian3.fromDegrees(-75.59777, 40.03883);\n * var normal = ellipsoid.geodeticSurfaceNormal(origin);\n * var plane = Cesium.Plane.fromPointNormal(origin, normal);\n *\n * var p0 = new Cesium.Cartesian3(...);\n * var p1 = new Cesium.Cartesian3(...);\n *\n * // find the intersection of the line segment from p0 to p1 and the tangent plane at origin.\n * var intersection = Cesium.IntersectionTests.lineSegmentPlane(p0, p1, plane);\n */\nIntersectionTests.lineSegmentPlane = function (\n  endPoint0,\n  endPoint1,\n  plane,\n  result\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(endPoint0)) {\n    throw new DeveloperError(\"endPoint0 is required.\");\n  }\n  if (!defined(endPoint1)) {\n    throw new DeveloperError(\"endPoint1 is required.\");\n  }\n  if (!defined(plane)) {\n    throw new DeveloperError(\"plane is required.\");\n  }\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n\n  var difference = Cartesian3.subtract(\n    endPoint1,\n    endPoint0,\n    lineSegmentPlaneDifference\n  );\n  var normal = plane.normal;\n  var nDotDiff = Cartesian3.dot(normal, difference);\n\n  // check if the segment and plane are parallel\n  if (Math.abs(nDotDiff) < CesiumMath.EPSILON6) {\n    return undefined;\n  }\n\n  var nDotP0 = Cartesian3.dot(normal, endPoint0);\n  var t = -(plane.distance + nDotP0) / nDotDiff;\n\n  // intersection only if t is in [0, 1]\n  if (t < 0.0 || t > 1.0) {\n    return undefined;\n  }\n\n  // intersection is endPoint0 + t * (endPoint1 - endPoint0)\n  Cartesian3.multiplyByScalar(difference, t, result);\n  Cartesian3.add(endPoint0, result, result);\n  return result;\n};\n\n/**\n * Computes the intersection of a triangle and a plane\n *\n * @param {Cartesian3} p0 First point of the triangle\n * @param {Cartesian3} p1 Second point of the triangle\n * @param {Cartesian3} p2 Third point of the triangle\n * @param {Plane} plane Intersection plane\n * @returns {Object} An object with properties <code>positions</code> and <code>indices</code>, which are arrays that represent three triangles that do not cross the plane. (Undefined if no intersection exists)\n *\n * @example\n * var origin = Cesium.Cartesian3.fromDegrees(-75.59777, 40.03883);\n * var normal = ellipsoid.geodeticSurfaceNormal(origin);\n * var plane = Cesium.Plane.fromPointNormal(origin, normal);\n *\n * var p0 = new Cesium.Cartesian3(...);\n * var p1 = new Cesium.Cartesian3(...);\n * var p2 = new Cesium.Cartesian3(...);\n *\n * // convert the triangle composed of points (p0, p1, p2) to three triangles that don't cross the plane\n * var triangles = Cesium.IntersectionTests.trianglePlaneIntersection(p0, p1, p2, plane);\n */\nIntersectionTests.trianglePlaneIntersection = function (p0, p1, p2, plane) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(p0) || !defined(p1) || !defined(p2) || !defined(plane)) {\n    throw new DeveloperError(\"p0, p1, p2, and plane are required.\");\n  }\n  //>>includeEnd('debug');\n\n  var planeNormal = plane.normal;\n  var planeD = plane.distance;\n  var p0Behind = Cartesian3.dot(planeNormal, p0) + planeD < 0.0;\n  var p1Behind = Cartesian3.dot(planeNormal, p1) + planeD < 0.0;\n  var p2Behind = Cartesian3.dot(planeNormal, p2) + planeD < 0.0;\n  // Given these dots products, the calls to lineSegmentPlaneIntersection\n  // always have defined results.\n\n  var numBehind = 0;\n  numBehind += p0Behind ? 1 : 0;\n  numBehind += p1Behind ? 1 : 0;\n  numBehind += p2Behind ? 1 : 0;\n\n  var u1, u2;\n  if (numBehind === 1 || numBehind === 2) {\n    u1 = new Cartesian3();\n    u2 = new Cartesian3();\n  }\n\n  if (numBehind === 1) {\n    if (p0Behind) {\n      IntersectionTests.lineSegmentPlane(p0, p1, plane, u1);\n      IntersectionTests.lineSegmentPlane(p0, p2, plane, u2);\n\n      return {\n        positions: [p0, p1, p2, u1, u2],\n        indices: [\n          // Behind\n          0,\n          3,\n          4,\n\n          // In front\n          1,\n          2,\n          4,\n          1,\n          4,\n          3,\n        ],\n      };\n    } else if (p1Behind) {\n      IntersectionTests.lineSegmentPlane(p1, p2, plane, u1);\n      IntersectionTests.lineSegmentPlane(p1, p0, plane, u2);\n\n      return {\n        positions: [p0, p1, p2, u1, u2],\n        indices: [\n          // Behind\n          1,\n          3,\n          4,\n\n          // In front\n          2,\n          0,\n          4,\n          2,\n          4,\n          3,\n        ],\n      };\n    } else if (p2Behind) {\n      IntersectionTests.lineSegmentPlane(p2, p0, plane, u1);\n      IntersectionTests.lineSegmentPlane(p2, p1, plane, u2);\n\n      return {\n        positions: [p0, p1, p2, u1, u2],\n        indices: [\n          // Behind\n          2,\n          3,\n          4,\n\n          // In front\n          0,\n          1,\n          4,\n          0,\n          4,\n          3,\n        ],\n      };\n    }\n  } else if (numBehind === 2) {\n    if (!p0Behind) {\n      IntersectionTests.lineSegmentPlane(p1, p0, plane, u1);\n      IntersectionTests.lineSegmentPlane(p2, p0, plane, u2);\n\n      return {\n        positions: [p0, p1, p2, u1, u2],\n        indices: [\n          // Behind\n          1,\n          2,\n          4,\n          1,\n          4,\n          3,\n\n          // In front\n          0,\n          3,\n          4,\n        ],\n      };\n    } else if (!p1Behind) {\n      IntersectionTests.lineSegmentPlane(p2, p1, plane, u1);\n      IntersectionTests.lineSegmentPlane(p0, p1, plane, u2);\n\n      return {\n        positions: [p0, p1, p2, u1, u2],\n        indices: [\n          // Behind\n          2,\n          0,\n          4,\n          2,\n          4,\n          3,\n\n          // In front\n          1,\n          3,\n          4,\n        ],\n      };\n    } else if (!p2Behind) {\n      IntersectionTests.lineSegmentPlane(p0, p2, plane, u1);\n      IntersectionTests.lineSegmentPlane(p1, p2, plane, u2);\n\n      return {\n        positions: [p0, p1, p2, u1, u2],\n        indices: [\n          // Behind\n          0,\n          1,\n          4,\n          0,\n          4,\n          3,\n\n          // In front\n          2,\n          3,\n          4,\n        ],\n      };\n    }\n  }\n\n  // if numBehind is 3, the triangle is completely behind the plane;\n  // otherwise, it is completely in front (numBehind is 0).\n  return undefined;\n};\nexport default IntersectionTests;\n"],"names":["QuadraticRealPolynomial","addWithCancellationCheck","left","right","tolerance","difference","CesiumMath","sign","Math","abs","max","computeDiscriminant","a","b","c","DeveloperError","computeRealRoots","ratio","cMagnitude","aMagnitude","EPSILON14","root","sqrt","radicand","q","CubicRealPolynomial","d","temp","temp1","A","B","C","D","AC","BD","B2","C2","delta1","delta2","delta3","discriminant","ABar","CBar","DBar","temp0","x","p","pow","CBarA","DBarA","CBarD","DBarD","squareRootOfDiscriminant","halfSquareRootOf3","theta","atan2","cosine","cos","temp3","sin","numeratorLarge","denominatorLarge","root1","numeratorSmall","denominatorSmall","root3","F","root2","b2","c2","roots","Length","length","QuarticRealPolynomial","original","a3","a2","a1","a0","a3Squared","r","cubicRoots","hSquared","y","root0","y0","y1","h","m","n","roots1","roots2","neumark","g2","h2","G","g","H","tempSquared","g1","h1","mError","nError","squareRootOfN","squareRootOfM","Ray","origin","direction","Cartesian3","clone","defaultValue","ZERO","equals","normalize","this","e","b3","c3","d2","d3","e2","EPSILON15","k","ray","result","defined","getPoint","t","Check","typeOf","object","number","multiplyByScalar","add","IntersectionTests","plane","normal","denominator","dot","distance","scratchEdge0","scratchEdge1","scratchPVec","scratchTVec","scratchQVec","rayTriangleParametric","p0","p1","p2","cullBackFaces","tvec","u","v","edge0","subtract","edge1","cross","det","EPSILON6","invDet","rayTriangle","scratchLineSegmentTriangleRay","lineSegmentTriangle","v0","v1","raySphereRoots","raySphere","sphere","Interval","center","radiusSquared","radius","diff","denom","disc","solveQuadratic","magnitudeSquared","start","stop","scratchLineSegmentRay","lineSegmentSphere","maxT","magnitude","min","scratchQ","scratchW","rayEllipsoid","ellipsoid","w2","product","inverseRadii","oneOverRadii","multiplyComponents","w","q2","qw","qw2","firstAxisScratch","secondAxisScratch","thirdAxisScratch","referenceScratch","bCart","bScratch","Matrix3","btScratch","diScratch","dScratch","cScratch","tempMatrix","aScratch","sScratch","closestScratch","surfPointScratch","Cartographic","grazingAltitudeLocation","position","geodeticSurfaceNormal","intersects","f","transformPositionToScaledSpace","firstAxis","reference","mostOrthogonalAxis","secondAxis","thirdAxis","z","B_T","transpose","D_I","fromScale","radii","s","altitude","multiply","multiplyByVector","solutions","cosines","xSquared","wSquared","l2","COLUMN1ROW1","COLUMN2ROW2","l1","COLUMN1ROW0","COLUMN0ROW1","l0","COLUMN0ROW0","r1","COLUMN2ROW1","COLUMN1ROW2","r0","COLUMN2ROW0","COLUMN0ROW2","cosine0","sine0","push","cosine1","sine1","r0Squared","r1Squared","r0r1","c4","c1","c0","i","cosineSquared","sineSquared","sine","EPSILON12","quadraticVectorExpression","negate","closest","maximumValue","Number","NEGATIVE_INFINITY","dotProduct","surfacePoint","cartesianToCartographic","clamp","height","cartographicToCartesian","lineSegmentPlaneDifference","lineSegmentPlane","endPoint0","endPoint1","nDotDiff","nDotP0","trianglePlaneIntersection","u1","u2","planeNormal","planeD","p0Behind","p1Behind","p2Behind","numBehind","positions","indices"],"mappings":"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"}