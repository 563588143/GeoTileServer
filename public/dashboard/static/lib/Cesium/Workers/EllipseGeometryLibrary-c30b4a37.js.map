{"version":3,"file":"EllipseGeometryLibrary-c30b4a37.js","sources":["../../../../Source/Core/EllipseGeometryLibrary.js"],"sourcesContent":["import Cartesian3 from \"./Cartesian3.js\";\nimport CesiumMath from \"./Math.js\";\nimport Matrix3 from \"./Matrix3.js\";\nimport Quaternion from \"./Quaternion.js\";\n\nvar EllipseGeometryLibrary = {};\n\nvar rotAxis = new Cartesian3();\nvar tempVec = new Cartesian3();\nvar unitQuat = new Quaternion();\nvar rotMtx = new Matrix3();\n\nfunction pointOnEllipsoid(\n  theta,\n  rotation,\n  northVec,\n  eastVec,\n  aSqr,\n  ab,\n  bSqr,\n  mag,\n  unitPos,\n  result\n) {\n  var azimuth = theta + rotation;\n\n  Cartesian3.multiplyByScalar(eastVec, Math.cos(azimuth), rotAxis);\n  Cartesian3.multiplyByScalar(northVec, Math.sin(azimuth), tempVec);\n  Cartesian3.add(rotAxis, tempVec, rotAxis);\n\n  var cosThetaSquared = Math.cos(theta);\n  cosThetaSquared = cosThetaSquared * cosThetaSquared;\n\n  var sinThetaSquared = Math.sin(theta);\n  sinThetaSquared = sinThetaSquared * sinThetaSquared;\n\n  var radius = ab / Math.sqrt(bSqr * cosThetaSquared + aSqr * sinThetaSquared);\n  var angle = radius / mag;\n\n  // Create the quaternion to rotate the position vector to the boundary of the ellipse.\n  Quaternion.fromAxisAngle(rotAxis, angle, unitQuat);\n  Matrix3.fromQuaternion(unitQuat, rotMtx);\n\n  Matrix3.multiplyByVector(rotMtx, unitPos, result);\n  Cartesian3.normalize(result, result);\n  Cartesian3.multiplyByScalar(result, mag, result);\n  return result;\n}\n\nvar scratchCartesian1 = new Cartesian3();\nvar scratchCartesian2 = new Cartesian3();\nvar scratchCartesian3 = new Cartesian3();\nvar scratchNormal = new Cartesian3();\n/**\n * Returns the positions raised to the given heights\n * @private\n */\nEllipseGeometryLibrary.raisePositionsToHeight = function (\n  positions,\n  options,\n  extrude\n) {\n  var ellipsoid = options.ellipsoid;\n  var height = options.height;\n  var extrudedHeight = options.extrudedHeight;\n  var size = extrude ? (positions.length / 3) * 2 : positions.length / 3;\n\n  var finalPositions = new Float64Array(size * 3);\n\n  var length = positions.length;\n  var bottomOffset = extrude ? length : 0;\n  for (var i = 0; i < length; i += 3) {\n    var i1 = i + 1;\n    var i2 = i + 2;\n\n    var position = Cartesian3.fromArray(positions, i, scratchCartesian1);\n    ellipsoid.scaleToGeodeticSurface(position, position);\n\n    var extrudedPosition = Cartesian3.clone(position, scratchCartesian2);\n    var normal = ellipsoid.geodeticSurfaceNormal(position, scratchNormal);\n    var scaledNormal = Cartesian3.multiplyByScalar(\n      normal,\n      height,\n      scratchCartesian3\n    );\n    Cartesian3.add(position, scaledNormal, position);\n\n    if (extrude) {\n      Cartesian3.multiplyByScalar(normal, extrudedHeight, scaledNormal);\n      Cartesian3.add(extrudedPosition, scaledNormal, extrudedPosition);\n\n      finalPositions[i + bottomOffset] = extrudedPosition.x;\n      finalPositions[i1 + bottomOffset] = extrudedPosition.y;\n      finalPositions[i2 + bottomOffset] = extrudedPosition.z;\n    }\n\n    finalPositions[i] = position.x;\n    finalPositions[i1] = position.y;\n    finalPositions[i2] = position.z;\n  }\n\n  return finalPositions;\n};\n\nvar unitPosScratch = new Cartesian3();\nvar eastVecScratch = new Cartesian3();\nvar northVecScratch = new Cartesian3();\n/**\n * Returns an array of positions that make up the ellipse.\n * @private\n */\nEllipseGeometryLibrary.computeEllipsePositions = function (\n  options,\n  addFillPositions,\n  addEdgePositions\n) {\n  var semiMinorAxis = options.semiMinorAxis;\n  var semiMajorAxis = options.semiMajorAxis;\n  var rotation = options.rotation;\n  var center = options.center;\n\n  // Computing the arc-length of the ellipse is too expensive to be practical. Estimating it using the\n  // arc length of the sphere is too inaccurate and creates sharp edges when either the semi-major or\n  // semi-minor axis is much bigger than the other. Instead, scale the angle delta to make\n  // the distance along the ellipse boundary more closely match the granularity.\n  var granularity = options.granularity * 8.0;\n\n  var aSqr = semiMinorAxis * semiMinorAxis;\n  var bSqr = semiMajorAxis * semiMajorAxis;\n  var ab = semiMajorAxis * semiMinorAxis;\n\n  var mag = Cartesian3.magnitude(center);\n\n  var unitPos = Cartesian3.normalize(center, unitPosScratch);\n  var eastVec = Cartesian3.cross(Cartesian3.UNIT_Z, center, eastVecScratch);\n  eastVec = Cartesian3.normalize(eastVec, eastVec);\n  var northVec = Cartesian3.cross(unitPos, eastVec, northVecScratch);\n\n  // The number of points in the first quadrant\n  var numPts = 1 + Math.ceil(CesiumMath.PI_OVER_TWO / granularity);\n\n  var deltaTheta = CesiumMath.PI_OVER_TWO / (numPts - 1);\n  var theta = CesiumMath.PI_OVER_TWO - numPts * deltaTheta;\n  if (theta < 0.0) {\n    numPts -= Math.ceil(Math.abs(theta) / deltaTheta);\n  }\n\n  // If the number of points were three, the ellipse\n  // would be tessellated like below:\n  //\n  //         *---*\n  //       / | \\ | \\\n  //     *---*---*---*\n  //   / | \\ | \\ | \\ | \\\n  //  / .*---*---*---*. \\\n  // * ` | \\ | \\ | \\ | `*\n  //  \\`.*---*---*---*.`/\n  //   \\ | \\ | \\ | \\ | /\n  //     *---*---*---*\n  //       \\ | \\ | /\n  //         *---*\n  // The first and last column have one position and fan to connect to the adjacent column.\n  // Each other vertical column contains an even number of positions.\n  var size = 2 * (numPts * (numPts + 2));\n  var positions = addFillPositions ? new Array(size * 3) : undefined;\n  var positionIndex = 0;\n  var position = scratchCartesian1;\n  var reflectedPosition = scratchCartesian2;\n\n  var outerPositionsLength = numPts * 4 * 3;\n  var outerRightIndex = outerPositionsLength - 1;\n  var outerLeftIndex = 0;\n  var outerPositions = addEdgePositions\n    ? new Array(outerPositionsLength)\n    : undefined;\n\n  var i;\n  var j;\n  var numInterior;\n  var t;\n  var interiorPosition;\n\n  // Compute points in the 'eastern' half of the ellipse\n  theta = CesiumMath.PI_OVER_TWO;\n  position = pointOnEllipsoid(\n    theta,\n    rotation,\n    northVec,\n    eastVec,\n    aSqr,\n    ab,\n    bSqr,\n    mag,\n    unitPos,\n    position\n  );\n  if (addFillPositions) {\n    positions[positionIndex++] = position.x;\n    positions[positionIndex++] = position.y;\n    positions[positionIndex++] = position.z;\n  }\n  if (addEdgePositions) {\n    outerPositions[outerRightIndex--] = position.z;\n    outerPositions[outerRightIndex--] = position.y;\n    outerPositions[outerRightIndex--] = position.x;\n  }\n  theta = CesiumMath.PI_OVER_TWO - deltaTheta;\n  for (i = 1; i < numPts + 1; ++i) {\n    position = pointOnEllipsoid(\n      theta,\n      rotation,\n      northVec,\n      eastVec,\n      aSqr,\n      ab,\n      bSqr,\n      mag,\n      unitPos,\n      position\n    );\n    reflectedPosition = pointOnEllipsoid(\n      Math.PI - theta,\n      rotation,\n      northVec,\n      eastVec,\n      aSqr,\n      ab,\n      bSqr,\n      mag,\n      unitPos,\n      reflectedPosition\n    );\n\n    if (addFillPositions) {\n      positions[positionIndex++] = position.x;\n      positions[positionIndex++] = position.y;\n      positions[positionIndex++] = position.z;\n\n      numInterior = 2 * i + 2;\n      for (j = 1; j < numInterior - 1; ++j) {\n        t = j / (numInterior - 1);\n        interiorPosition = Cartesian3.lerp(\n          position,\n          reflectedPosition,\n          t,\n          scratchCartesian3\n        );\n        positions[positionIndex++] = interiorPosition.x;\n        positions[positionIndex++] = interiorPosition.y;\n        positions[positionIndex++] = interiorPosition.z;\n      }\n\n      positions[positionIndex++] = reflectedPosition.x;\n      positions[positionIndex++] = reflectedPosition.y;\n      positions[positionIndex++] = reflectedPosition.z;\n    }\n\n    if (addEdgePositions) {\n      outerPositions[outerRightIndex--] = position.z;\n      outerPositions[outerRightIndex--] = position.y;\n      outerPositions[outerRightIndex--] = position.x;\n      outerPositions[outerLeftIndex++] = reflectedPosition.x;\n      outerPositions[outerLeftIndex++] = reflectedPosition.y;\n      outerPositions[outerLeftIndex++] = reflectedPosition.z;\n    }\n\n    theta = CesiumMath.PI_OVER_TWO - (i + 1) * deltaTheta;\n  }\n\n  // Compute points in the 'western' half of the ellipse\n  for (i = numPts; i > 1; --i) {\n    theta = CesiumMath.PI_OVER_TWO - (i - 1) * deltaTheta;\n\n    position = pointOnEllipsoid(\n      -theta,\n      rotation,\n      northVec,\n      eastVec,\n      aSqr,\n      ab,\n      bSqr,\n      mag,\n      unitPos,\n      position\n    );\n    reflectedPosition = pointOnEllipsoid(\n      theta + Math.PI,\n      rotation,\n      northVec,\n      eastVec,\n      aSqr,\n      ab,\n      bSqr,\n      mag,\n      unitPos,\n      reflectedPosition\n    );\n\n    if (addFillPositions) {\n      positions[positionIndex++] = position.x;\n      positions[positionIndex++] = position.y;\n      positions[positionIndex++] = position.z;\n\n      numInterior = 2 * (i - 1) + 2;\n      for (j = 1; j < numInterior - 1; ++j) {\n        t = j / (numInterior - 1);\n        interiorPosition = Cartesian3.lerp(\n          position,\n          reflectedPosition,\n          t,\n          scratchCartesian3\n        );\n        positions[positionIndex++] = interiorPosition.x;\n        positions[positionIndex++] = interiorPosition.y;\n        positions[positionIndex++] = interiorPosition.z;\n      }\n\n      positions[positionIndex++] = reflectedPosition.x;\n      positions[positionIndex++] = reflectedPosition.y;\n      positions[positionIndex++] = reflectedPosition.z;\n    }\n\n    if (addEdgePositions) {\n      outerPositions[outerRightIndex--] = position.z;\n      outerPositions[outerRightIndex--] = position.y;\n      outerPositions[outerRightIndex--] = position.x;\n      outerPositions[outerLeftIndex++] = reflectedPosition.x;\n      outerPositions[outerLeftIndex++] = reflectedPosition.y;\n      outerPositions[outerLeftIndex++] = reflectedPosition.z;\n    }\n  }\n\n  theta = CesiumMath.PI_OVER_TWO;\n  position = pointOnEllipsoid(\n    -theta,\n    rotation,\n    northVec,\n    eastVec,\n    aSqr,\n    ab,\n    bSqr,\n    mag,\n    unitPos,\n    position\n  );\n\n  var r = {};\n  if (addFillPositions) {\n    positions[positionIndex++] = position.x;\n    positions[positionIndex++] = position.y;\n    positions[positionIndex++] = position.z;\n    r.positions = positions;\n    r.numPts = numPts;\n  }\n  if (addEdgePositions) {\n    outerPositions[outerRightIndex--] = position.z;\n    outerPositions[outerRightIndex--] = position.y;\n    outerPositions[outerRightIndex--] = position.x;\n    r.outerPositions = outerPositions;\n  }\n\n  return r;\n};\nexport default EllipseGeometryLibrary;\n"],"names":["EllipseGeometryLibrary","rotAxis","Cartesian3","tempVec","unitQuat","Quaternion","rotMtx","Matrix3","pointOnEllipsoid","theta","rotation","northVec","eastVec","aSqr","ab","bSqr","mag","unitPos","result","azimuth","multiplyByScalar","Math","cos","sin","add","cosThetaSquared","sinThetaSquared","angle","sqrt","fromAxisAngle","fromQuaternion","multiplyByVector","normalize","scratchCartesian1","scratchCartesian2","scratchCartesian3","scratchNormal","raisePositionsToHeight","positions","options","extrude","ellipsoid","height","extrudedHeight","size","length","finalPositions","Float64Array","bottomOffset","i","i1","i2","position","fromArray","scaleToGeodeticSurface","extrudedPosition","clone","normal","geodeticSurfaceNormal","scaledNormal","x","y","z","unitPosScratch","eastVecScratch","northVecScratch","computeEllipsePositions","addFillPositions","addEdgePositions","semiMinorAxis","semiMajorAxis","center","granularity","magnitude","cross","UNIT_Z","numPts","ceil","CesiumMath","PI_OVER_TWO","deltaTheta","abs","j","numInterior","t","interiorPosition","Array","undefined","positionIndex","reflectedPosition","outerPositionsLength","outerRightIndex","outerLeftIndex","outerPositions","PI","lerp","r"],"mappings":"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"}