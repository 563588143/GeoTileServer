{"version":3,"file":"Matrix2-91d5b6af.js","sources":["../../../../Source/Core/Cartesian3.js","../../../../Source/Core/scaleToGeodeticSurface.js","../../../../Source/Core/Cartographic.js","../../../../Source/Core/Ellipsoid.js","../../../../Source/Core/Matrix3.js","../../../../Source/Core/Cartesian4.js","../../../../Source/Core/Matrix4.js","../../../../Source/Core/Rectangle.js","../../../../Source/Core/Cartesian2.js","../../../../Source/Core/Matrix2.js"],"sourcesContent":["import Check from \"./Check.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport CesiumMath from \"./Math.js\";\n\n/**\n * A 3D Cartesian point.\n * @alias Cartesian3\n * @constructor\n *\n * @param {Number} [x=0.0] The X component.\n * @param {Number} [y=0.0] The Y component.\n * @param {Number} [z=0.0] The Z component.\n *\n * @see Cartesian2\n * @see Cartesian4\n * @see Packable\n */\nfunction Cartesian3(x, y, z) {\n  /**\n   * The X component.\n   * @type {Number}\n   * @default 0.0\n   */\n  this.x = defaultValue(x, 0.0);\n\n  /**\n   * The Y component.\n   * @type {Number}\n   * @default 0.0\n   */\n  this.y = defaultValue(y, 0.0);\n\n  /**\n   * The Z component.\n   * @type {Number}\n   * @default 0.0\n   */\n  this.z = defaultValue(z, 0.0);\n}\n\n/**\n * Converts the provided Spherical into Cartesian3 coordinates.\n *\n * @param {Spherical} spherical The Spherical to be converted to Cartesian3.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if one was not provided.\n */\nCartesian3.fromSpherical = function (spherical, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"spherical\", spherical);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n\n  var clock = spherical.clock;\n  var cone = spherical.cone;\n  var magnitude = defaultValue(spherical.magnitude, 1.0);\n  var radial = magnitude * Math.sin(cone);\n  result.x = radial * Math.cos(clock);\n  result.y = radial * Math.sin(clock);\n  result.z = magnitude * Math.cos(cone);\n  return result;\n};\n\n/**\n * Creates a Cartesian3 instance from x, y and z coordinates.\n *\n * @param {Number} x The x coordinate.\n * @param {Number} y The y coordinate.\n * @param {Number} z The z coordinate.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if one was not provided.\n */\nCartesian3.fromElements = function (x, y, z, result) {\n  if (!defined(result)) {\n    return new Cartesian3(x, y, z);\n  }\n\n  result.x = x;\n  result.y = y;\n  result.z = z;\n  return result;\n};\n\n/**\n * Duplicates a Cartesian3 instance.\n *\n * @param {Cartesian3} cartesian The Cartesian to duplicate.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if one was not provided. (Returns undefined if cartesian is undefined)\n */\nCartesian3.clone = function (cartesian, result) {\n  if (!defined(cartesian)) {\n    return undefined;\n  }\n  if (!defined(result)) {\n    return new Cartesian3(cartesian.x, cartesian.y, cartesian.z);\n  }\n\n  result.x = cartesian.x;\n  result.y = cartesian.y;\n  result.z = cartesian.z;\n  return result;\n};\n\n/**\n * Creates a Cartesian3 instance from an existing Cartesian4.  This simply takes the\n * x, y, and z properties of the Cartesian4 and drops w.\n * @function\n *\n * @param {Cartesian4} cartesian The Cartesian4 instance to create a Cartesian3 instance from.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if one was not provided.\n */\nCartesian3.fromCartesian4 = Cartesian3.clone;\n\n/**\n * The number of elements used to pack the object into an array.\n * @type {Number}\n */\nCartesian3.packedLength = 3;\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {Cartesian3} value The value to pack.\n * @param {Number[]} array The array to pack into.\n * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {Number[]} The array that was packed into\n */\nCartesian3.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"value\", value);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  array[startingIndex++] = value.x;\n  array[startingIndex++] = value.y;\n  array[startingIndex] = value.z;\n\n  return array;\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {Number[]} array The packed array.\n * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {Cartesian3} [result] The object into which to store the result.\n * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if one was not provided.\n */\nCartesian3.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n  result.x = array[startingIndex++];\n  result.y = array[startingIndex++];\n  result.z = array[startingIndex];\n  return result;\n};\n\n/**\n * Flattens an array of Cartesian3s into an array of components.\n *\n * @param {Cartesian3[]} array The array of cartesians to pack.\n * @param {Number[]} [result] The array onto which to store the result. If this is a typed array, it must have array.length * 3 components, else a {@link DeveloperError} will be thrown. If it is a regular array, it will be resized to have (array.length * 3) elements.\n * @returns {Number[]} The packed array.\n */\nCartesian3.packArray = function (array, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  var length = array.length;\n  var resultLength = length * 3;\n  if (!defined(result)) {\n    result = new Array(resultLength);\n  } else if (!Array.isArray(result) && result.length !== resultLength) {\n    throw new DeveloperError(\n      \"If result is a typed array, it must have exactly array.length * 3 elements\"\n    );\n  } else if (result.length !== resultLength) {\n    result.length = resultLength;\n  }\n\n  for (var i = 0; i < length; ++i) {\n    Cartesian3.pack(array[i], result, i * 3);\n  }\n  return result;\n};\n\n/**\n * Unpacks an array of cartesian components into an array of Cartesian3s.\n *\n * @param {Number[]} array The array of components to unpack.\n * @param {Cartesian3[]} [result] The array onto which to store the result.\n * @returns {Cartesian3[]} The unpacked array.\n */\nCartesian3.unpackArray = function (array, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  Check.typeOf.number.greaterThanOrEquals(\"array.length\", array.length, 3);\n  if (array.length % 3 !== 0) {\n    throw new DeveloperError(\"array length must be a multiple of 3.\");\n  }\n  //>>includeEnd('debug');\n\n  var length = array.length;\n  if (!defined(result)) {\n    result = new Array(length / 3);\n  } else {\n    result.length = length / 3;\n  }\n\n  for (var i = 0; i < length; i += 3) {\n    var index = i / 3;\n    result[index] = Cartesian3.unpack(array, i, result[index]);\n  }\n  return result;\n};\n\n/**\n * Creates a Cartesian3 from three consecutive elements in an array.\n * @function\n *\n * @param {Number[]} array The array whose three consecutive elements correspond to the x, y, and z components, respectively.\n * @param {Number} [startingIndex=0] The offset into the array of the first element, which corresponds to the x component.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if one was not provided.\n *\n * @example\n * // Create a Cartesian3 with (1.0, 2.0, 3.0)\n * var v = [1.0, 2.0, 3.0];\n * var p = Cesium.Cartesian3.fromArray(v);\n *\n * // Create a Cartesian3 with (1.0, 2.0, 3.0) using an offset into an array\n * var v2 = [0.0, 0.0, 1.0, 2.0, 3.0];\n * var p2 = Cesium.Cartesian3.fromArray(v2, 2);\n */\nCartesian3.fromArray = Cartesian3.unpack;\n\n/**\n * Computes the value of the maximum component for the supplied Cartesian.\n *\n * @param {Cartesian3} cartesian The cartesian to use.\n * @returns {Number} The value of the maximum component.\n */\nCartesian3.maximumComponent = function (cartesian) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  //>>includeEnd('debug');\n\n  return Math.max(cartesian.x, cartesian.y, cartesian.z);\n};\n\n/**\n * Computes the value of the minimum component for the supplied Cartesian.\n *\n * @param {Cartesian3} cartesian The cartesian to use.\n * @returns {Number} The value of the minimum component.\n */\nCartesian3.minimumComponent = function (cartesian) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  //>>includeEnd('debug');\n\n  return Math.min(cartesian.x, cartesian.y, cartesian.z);\n};\n\n/**\n * Compares two Cartesians and computes a Cartesian which contains the minimum components of the supplied Cartesians.\n *\n * @param {Cartesian3} first A cartesian to compare.\n * @param {Cartesian3} second A cartesian to compare.\n * @param {Cartesian3} result The object into which to store the result.\n * @returns {Cartesian3} A cartesian with the minimum components.\n */\nCartesian3.minimumByComponent = function (first, second, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"first\", first);\n  Check.typeOf.object(\"second\", second);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = Math.min(first.x, second.x);\n  result.y = Math.min(first.y, second.y);\n  result.z = Math.min(first.z, second.z);\n\n  return result;\n};\n\n/**\n * Compares two Cartesians and computes a Cartesian which contains the maximum components of the supplied Cartesians.\n *\n * @param {Cartesian3} first A cartesian to compare.\n * @param {Cartesian3} second A cartesian to compare.\n * @param {Cartesian3} result The object into which to store the result.\n * @returns {Cartesian3} A cartesian with the maximum components.\n */\nCartesian3.maximumByComponent = function (first, second, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"first\", first);\n  Check.typeOf.object(\"second\", second);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = Math.max(first.x, second.x);\n  result.y = Math.max(first.y, second.y);\n  result.z = Math.max(first.z, second.z);\n  return result;\n};\n\n/**\n * Computes the provided Cartesian's squared magnitude.\n *\n * @param {Cartesian3} cartesian The Cartesian instance whose squared magnitude is to be computed.\n * @returns {Number} The squared magnitude.\n */\nCartesian3.magnitudeSquared = function (cartesian) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  //>>includeEnd('debug');\n\n  return (\n    cartesian.x * cartesian.x +\n    cartesian.y * cartesian.y +\n    cartesian.z * cartesian.z\n  );\n};\n\n/**\n * Computes the Cartesian's magnitude (length).\n *\n * @param {Cartesian3} cartesian The Cartesian instance whose magnitude is to be computed.\n * @returns {Number} The magnitude.\n */\nCartesian3.magnitude = function (cartesian) {\n  return Math.sqrt(Cartesian3.magnitudeSquared(cartesian));\n};\n\nvar distanceScratch = new Cartesian3();\n\n/**\n * Computes the distance between two points.\n *\n * @param {Cartesian3} left The first point to compute the distance from.\n * @param {Cartesian3} right The second point to compute the distance to.\n * @returns {Number} The distance between two points.\n *\n * @example\n * // Returns 1.0\n * var d = Cesium.Cartesian3.distance(new Cesium.Cartesian3(1.0, 0.0, 0.0), new Cesium.Cartesian3(2.0, 0.0, 0.0));\n */\nCartesian3.distance = function (left, right) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  //>>includeEnd('debug');\n\n  Cartesian3.subtract(left, right, distanceScratch);\n  return Cartesian3.magnitude(distanceScratch);\n};\n\n/**\n * Computes the squared distance between two points.  Comparing squared distances\n * using this function is more efficient than comparing distances using {@link Cartesian3#distance}.\n *\n * @param {Cartesian3} left The first point to compute the distance from.\n * @param {Cartesian3} right The second point to compute the distance to.\n * @returns {Number} The distance between two points.\n *\n * @example\n * // Returns 4.0, not 2.0\n * var d = Cesium.Cartesian3.distanceSquared(new Cesium.Cartesian3(1.0, 0.0, 0.0), new Cesium.Cartesian3(3.0, 0.0, 0.0));\n */\nCartesian3.distanceSquared = function (left, right) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  //>>includeEnd('debug');\n\n  Cartesian3.subtract(left, right, distanceScratch);\n  return Cartesian3.magnitudeSquared(distanceScratch);\n};\n\n/**\n * Computes the normalized form of the supplied Cartesian.\n *\n * @param {Cartesian3} cartesian The Cartesian to be normalized.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter.\n */\nCartesian3.normalize = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  var magnitude = Cartesian3.magnitude(cartesian);\n\n  result.x = cartesian.x / magnitude;\n  result.y = cartesian.y / magnitude;\n  result.z = cartesian.z / magnitude;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (isNaN(result.x) || isNaN(result.y) || isNaN(result.z)) {\n    throw new DeveloperError(\"normalized result is not a number\");\n  }\n  //>>includeEnd('debug');\n\n  return result;\n};\n\n/**\n * Computes the dot (scalar) product of two Cartesians.\n *\n * @param {Cartesian3} left The first Cartesian.\n * @param {Cartesian3} right The second Cartesian.\n * @returns {Number} The dot product.\n */\nCartesian3.dot = function (left, right) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  //>>includeEnd('debug');\n\n  return left.x * right.x + left.y * right.y + left.z * right.z;\n};\n\n/**\n * Computes the componentwise product of two Cartesians.\n *\n * @param {Cartesian3} left The first Cartesian.\n * @param {Cartesian3} right The second Cartesian.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter.\n */\nCartesian3.multiplyComponents = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = left.x * right.x;\n  result.y = left.y * right.y;\n  result.z = left.z * right.z;\n  return result;\n};\n\n/**\n * Computes the componentwise quotient of two Cartesians.\n *\n * @param {Cartesian3} left The first Cartesian.\n * @param {Cartesian3} right The second Cartesian.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter.\n */\nCartesian3.divideComponents = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = left.x / right.x;\n  result.y = left.y / right.y;\n  result.z = left.z / right.z;\n  return result;\n};\n\n/**\n * Computes the componentwise sum of two Cartesians.\n *\n * @param {Cartesian3} left The first Cartesian.\n * @param {Cartesian3} right The second Cartesian.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter.\n */\nCartesian3.add = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = left.x + right.x;\n  result.y = left.y + right.y;\n  result.z = left.z + right.z;\n  return result;\n};\n\n/**\n * Computes the componentwise difference of two Cartesians.\n *\n * @param {Cartesian3} left The first Cartesian.\n * @param {Cartesian3} right The second Cartesian.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter.\n */\nCartesian3.subtract = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = left.x - right.x;\n  result.y = left.y - right.y;\n  result.z = left.z - right.z;\n  return result;\n};\n\n/**\n * Multiplies the provided Cartesian componentwise by the provided scalar.\n *\n * @param {Cartesian3} cartesian The Cartesian to be scaled.\n * @param {Number} scalar The scalar to multiply with.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter.\n */\nCartesian3.multiplyByScalar = function (cartesian, scalar, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.number(\"scalar\", scalar);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = cartesian.x * scalar;\n  result.y = cartesian.y * scalar;\n  result.z = cartesian.z * scalar;\n  return result;\n};\n\n/**\n * Divides the provided Cartesian componentwise by the provided scalar.\n *\n * @param {Cartesian3} cartesian The Cartesian to be divided.\n * @param {Number} scalar The scalar to divide by.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter.\n */\nCartesian3.divideByScalar = function (cartesian, scalar, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.number(\"scalar\", scalar);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = cartesian.x / scalar;\n  result.y = cartesian.y / scalar;\n  result.z = cartesian.z / scalar;\n  return result;\n};\n\n/**\n * Negates the provided Cartesian.\n *\n * @param {Cartesian3} cartesian The Cartesian to be negated.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter.\n */\nCartesian3.negate = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = -cartesian.x;\n  result.y = -cartesian.y;\n  result.z = -cartesian.z;\n  return result;\n};\n\n/**\n * Computes the absolute value of the provided Cartesian.\n *\n * @param {Cartesian3} cartesian The Cartesian whose absolute value is to be computed.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter.\n */\nCartesian3.abs = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = Math.abs(cartesian.x);\n  result.y = Math.abs(cartesian.y);\n  result.z = Math.abs(cartesian.z);\n  return result;\n};\n\nvar lerpScratch = new Cartesian3();\n/**\n * Computes the linear interpolation or extrapolation at t using the provided cartesians.\n *\n * @param {Cartesian3} start The value corresponding to t at 0.0.\n * @param {Cartesian3} end The value corresponding to t at 1.0.\n * @param {Number} t The point along t at which to interpolate.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter.\n */\nCartesian3.lerp = function (start, end, t, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"start\", start);\n  Check.typeOf.object(\"end\", end);\n  Check.typeOf.number(\"t\", t);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  Cartesian3.multiplyByScalar(end, t, lerpScratch);\n  result = Cartesian3.multiplyByScalar(start, 1.0 - t, result);\n  return Cartesian3.add(lerpScratch, result, result);\n};\n\nvar angleBetweenScratch = new Cartesian3();\nvar angleBetweenScratch2 = new Cartesian3();\n/**\n * Returns the angle, in radians, between the provided Cartesians.\n *\n * @param {Cartesian3} left The first Cartesian.\n * @param {Cartesian3} right The second Cartesian.\n * @returns {Number} The angle between the Cartesians.\n */\nCartesian3.angleBetween = function (left, right) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  //>>includeEnd('debug');\n\n  Cartesian3.normalize(left, angleBetweenScratch);\n  Cartesian3.normalize(right, angleBetweenScratch2);\n  var cosine = Cartesian3.dot(angleBetweenScratch, angleBetweenScratch2);\n  var sine = Cartesian3.magnitude(\n    Cartesian3.cross(\n      angleBetweenScratch,\n      angleBetweenScratch2,\n      angleBetweenScratch\n    )\n  );\n  return Math.atan2(sine, cosine);\n};\n\nvar mostOrthogonalAxisScratch = new Cartesian3();\n/**\n * Returns the axis that is most orthogonal to the provided Cartesian.\n *\n * @param {Cartesian3} cartesian The Cartesian on which to find the most orthogonal axis.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The most orthogonal axis.\n */\nCartesian3.mostOrthogonalAxis = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  var f = Cartesian3.normalize(cartesian, mostOrthogonalAxisScratch);\n  Cartesian3.abs(f, f);\n\n  if (f.x <= f.y) {\n    if (f.x <= f.z) {\n      result = Cartesian3.clone(Cartesian3.UNIT_X, result);\n    } else {\n      result = Cartesian3.clone(Cartesian3.UNIT_Z, result);\n    }\n  } else if (f.y <= f.z) {\n    result = Cartesian3.clone(Cartesian3.UNIT_Y, result);\n  } else {\n    result = Cartesian3.clone(Cartesian3.UNIT_Z, result);\n  }\n\n  return result;\n};\n\n/**\n * Projects vector a onto vector b\n * @param {Cartesian3} a The vector that needs projecting\n * @param {Cartesian3} b The vector to project onto\n * @param {Cartesian3} result The result cartesian\n * @returns {Cartesian3} The modified result parameter\n */\nCartesian3.projectVector = function (a, b, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"a\", a);\n  Check.defined(\"b\", b);\n  Check.defined(\"result\", result);\n  //>>includeEnd('debug');\n\n  var scalar = Cartesian3.dot(a, b) / Cartesian3.dot(b, b);\n  return Cartesian3.multiplyByScalar(b, scalar, result);\n};\n\n/**\n * Compares the provided Cartesians componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {Cartesian3} [left] The first Cartesian.\n * @param {Cartesian3} [right] The second Cartesian.\n * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n */\nCartesian3.equals = function (left, right) {\n  return (\n    left === right ||\n    (defined(left) &&\n      defined(right) &&\n      left.x === right.x &&\n      left.y === right.y &&\n      left.z === right.z)\n  );\n};\n\n/**\n * @private\n */\nCartesian3.equalsArray = function (cartesian, array, offset) {\n  return (\n    cartesian.x === array[offset] &&\n    cartesian.y === array[offset + 1] &&\n    cartesian.z === array[offset + 2]\n  );\n};\n\n/**\n * Compares the provided Cartesians componentwise and returns\n * <code>true</code> if they pass an absolute or relative tolerance test,\n * <code>false</code> otherwise.\n *\n * @param {Cartesian3} [left] The first Cartesian.\n * @param {Cartesian3} [right] The second Cartesian.\n * @param {Number} [relativeEpsilon=0] The relative epsilon tolerance to use for equality testing.\n * @param {Number} [absoluteEpsilon=relativeEpsilon] The absolute epsilon tolerance to use for equality testing.\n * @returns {Boolean} <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.\n */\nCartesian3.equalsEpsilon = function (\n  left,\n  right,\n  relativeEpsilon,\n  absoluteEpsilon\n) {\n  return (\n    left === right ||\n    (defined(left) &&\n      defined(right) &&\n      CesiumMath.equalsEpsilon(\n        left.x,\n        right.x,\n        relativeEpsilon,\n        absoluteEpsilon\n      ) &&\n      CesiumMath.equalsEpsilon(\n        left.y,\n        right.y,\n        relativeEpsilon,\n        absoluteEpsilon\n      ) &&\n      CesiumMath.equalsEpsilon(\n        left.z,\n        right.z,\n        relativeEpsilon,\n        absoluteEpsilon\n      ))\n  );\n};\n\n/**\n * Computes the cross (outer) product of two Cartesians.\n *\n * @param {Cartesian3} left The first Cartesian.\n * @param {Cartesian3} right The second Cartesian.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The cross product.\n */\nCartesian3.cross = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  var leftX = left.x;\n  var leftY = left.y;\n  var leftZ = left.z;\n  var rightX = right.x;\n  var rightY = right.y;\n  var rightZ = right.z;\n\n  var x = leftY * rightZ - leftZ * rightY;\n  var y = leftZ * rightX - leftX * rightZ;\n  var z = leftX * rightY - leftY * rightX;\n\n  result.x = x;\n  result.y = y;\n  result.z = z;\n  return result;\n};\n\n/**\n * Computes the midpoint between the right and left Cartesian.\n * @param {Cartesian3} left The first Cartesian.\n * @param {Cartesian3} right The second Cartesian.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The midpoint.\n */\nCartesian3.midpoint = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = (left.x + right.x) * 0.5;\n  result.y = (left.y + right.y) * 0.5;\n  result.z = (left.z + right.z) * 0.5;\n\n  return result;\n};\n\n/**\n * Returns a Cartesian3 position from longitude and latitude values given in degrees.\n *\n * @param {Number} longitude The longitude, in degrees\n * @param {Number} latitude The latitude, in degrees\n * @param {Number} [height=0.0] The height, in meters, above the ellipsoid.\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the position lies.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The position\n *\n * @example\n * var position = Cesium.Cartesian3.fromDegrees(-115.0, 37.0);\n */\nCartesian3.fromDegrees = function (\n  longitude,\n  latitude,\n  height,\n  ellipsoid,\n  result\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"longitude\", longitude);\n  Check.typeOf.number(\"latitude\", latitude);\n  //>>includeEnd('debug');\n\n  longitude = CesiumMath.toRadians(longitude);\n  latitude = CesiumMath.toRadians(latitude);\n  return Cartesian3.fromRadians(longitude, latitude, height, ellipsoid, result);\n};\n\nvar scratchN = new Cartesian3();\nvar scratchK = new Cartesian3();\nvar wgs84RadiiSquared = new Cartesian3(\n  6378137.0 * 6378137.0,\n  6378137.0 * 6378137.0,\n  6356752.3142451793 * 6356752.3142451793\n);\n\n/**\n * Returns a Cartesian3 position from longitude and latitude values given in radians.\n *\n * @param {Number} longitude The longitude, in radians\n * @param {Number} latitude The latitude, in radians\n * @param {Number} [height=0.0] The height, in meters, above the ellipsoid.\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the position lies.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The position\n *\n * @example\n * var position = Cesium.Cartesian3.fromRadians(-2.007, 0.645);\n */\nCartesian3.fromRadians = function (\n  longitude,\n  latitude,\n  height,\n  ellipsoid,\n  result\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"longitude\", longitude);\n  Check.typeOf.number(\"latitude\", latitude);\n  //>>includeEnd('debug');\n\n  height = defaultValue(height, 0.0);\n  var radiiSquared = defined(ellipsoid)\n    ? ellipsoid.radiiSquared\n    : wgs84RadiiSquared;\n\n  var cosLatitude = Math.cos(latitude);\n  scratchN.x = cosLatitude * Math.cos(longitude);\n  scratchN.y = cosLatitude * Math.sin(longitude);\n  scratchN.z = Math.sin(latitude);\n  scratchN = Cartesian3.normalize(scratchN, scratchN);\n\n  Cartesian3.multiplyComponents(radiiSquared, scratchN, scratchK);\n  var gamma = Math.sqrt(Cartesian3.dot(scratchN, scratchK));\n  scratchK = Cartesian3.divideByScalar(scratchK, gamma, scratchK);\n  scratchN = Cartesian3.multiplyByScalar(scratchN, height, scratchN);\n\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n  return Cartesian3.add(scratchK, scratchN, result);\n};\n\n/**\n * Returns an array of Cartesian3 positions given an array of longitude and latitude values given in degrees.\n *\n * @param {Number[]} coordinates A list of longitude and latitude values. Values alternate [longitude, latitude, longitude, latitude...].\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the coordinates lie.\n * @param {Cartesian3[]} [result] An array of Cartesian3 objects to store the result.\n * @returns {Cartesian3[]} The array of positions.\n *\n * @example\n * var positions = Cesium.Cartesian3.fromDegreesArray([-115.0, 37.0, -107.0, 33.0]);\n */\nCartesian3.fromDegreesArray = function (coordinates, ellipsoid, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"coordinates\", coordinates);\n  if (coordinates.length < 2 || coordinates.length % 2 !== 0) {\n    throw new DeveloperError(\n      \"the number of coordinates must be a multiple of 2 and at least 2\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  var length = coordinates.length;\n  if (!defined(result)) {\n    result = new Array(length / 2);\n  } else {\n    result.length = length / 2;\n  }\n\n  for (var i = 0; i < length; i += 2) {\n    var longitude = coordinates[i];\n    var latitude = coordinates[i + 1];\n    var index = i / 2;\n    result[index] = Cartesian3.fromDegrees(\n      longitude,\n      latitude,\n      0,\n      ellipsoid,\n      result[index]\n    );\n  }\n\n  return result;\n};\n\n/**\n * Returns an array of Cartesian3 positions given an array of longitude and latitude values given in radians.\n *\n * @param {Number[]} coordinates A list of longitude and latitude values. Values alternate [longitude, latitude, longitude, latitude...].\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the coordinates lie.\n * @param {Cartesian3[]} [result] An array of Cartesian3 objects to store the result.\n * @returns {Cartesian3[]} The array of positions.\n *\n * @example\n * var positions = Cesium.Cartesian3.fromRadiansArray([-2.007, 0.645, -1.867, .575]);\n */\nCartesian3.fromRadiansArray = function (coordinates, ellipsoid, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"coordinates\", coordinates);\n  if (coordinates.length < 2 || coordinates.length % 2 !== 0) {\n    throw new DeveloperError(\n      \"the number of coordinates must be a multiple of 2 and at least 2\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  var length = coordinates.length;\n  if (!defined(result)) {\n    result = new Array(length / 2);\n  } else {\n    result.length = length / 2;\n  }\n\n  for (var i = 0; i < length; i += 2) {\n    var longitude = coordinates[i];\n    var latitude = coordinates[i + 1];\n    var index = i / 2;\n    result[index] = Cartesian3.fromRadians(\n      longitude,\n      latitude,\n      0,\n      ellipsoid,\n      result[index]\n    );\n  }\n\n  return result;\n};\n\n/**\n * Returns an array of Cartesian3 positions given an array of longitude, latitude and height values where longitude and latitude are given in degrees.\n *\n * @param {Number[]} coordinates A list of longitude, latitude and height values. Values alternate [longitude, latitude, height, longitude, latitude, height...].\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the position lies.\n * @param {Cartesian3[]} [result] An array of Cartesian3 objects to store the result.\n * @returns {Cartesian3[]} The array of positions.\n *\n * @example\n * var positions = Cesium.Cartesian3.fromDegreesArrayHeights([-115.0, 37.0, 100000.0, -107.0, 33.0, 150000.0]);\n */\nCartesian3.fromDegreesArrayHeights = function (coordinates, ellipsoid, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"coordinates\", coordinates);\n  if (coordinates.length < 3 || coordinates.length % 3 !== 0) {\n    throw new DeveloperError(\n      \"the number of coordinates must be a multiple of 3 and at least 3\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  var length = coordinates.length;\n  if (!defined(result)) {\n    result = new Array(length / 3);\n  } else {\n    result.length = length / 3;\n  }\n\n  for (var i = 0; i < length; i += 3) {\n    var longitude = coordinates[i];\n    var latitude = coordinates[i + 1];\n    var height = coordinates[i + 2];\n    var index = i / 3;\n    result[index] = Cartesian3.fromDegrees(\n      longitude,\n      latitude,\n      height,\n      ellipsoid,\n      result[index]\n    );\n  }\n\n  return result;\n};\n\n/**\n * Returns an array of Cartesian3 positions given an array of longitude, latitude and height values where longitude and latitude are given in radians.\n *\n * @param {Number[]} coordinates A list of longitude, latitude and height values. Values alternate [longitude, latitude, height, longitude, latitude, height...].\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the position lies.\n * @param {Cartesian3[]} [result] An array of Cartesian3 objects to store the result.\n * @returns {Cartesian3[]} The array of positions.\n *\n * @example\n * var positions = Cesium.Cartesian3.fromRadiansArrayHeights([-2.007, 0.645, 100000.0, -1.867, .575, 150000.0]);\n */\nCartesian3.fromRadiansArrayHeights = function (coordinates, ellipsoid, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"coordinates\", coordinates);\n  if (coordinates.length < 3 || coordinates.length % 3 !== 0) {\n    throw new DeveloperError(\n      \"the number of coordinates must be a multiple of 3 and at least 3\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  var length = coordinates.length;\n  if (!defined(result)) {\n    result = new Array(length / 3);\n  } else {\n    result.length = length / 3;\n  }\n\n  for (var i = 0; i < length; i += 3) {\n    var longitude = coordinates[i];\n    var latitude = coordinates[i + 1];\n    var height = coordinates[i + 2];\n    var index = i / 3;\n    result[index] = Cartesian3.fromRadians(\n      longitude,\n      latitude,\n      height,\n      ellipsoid,\n      result[index]\n    );\n  }\n\n  return result;\n};\n\n/**\n * An immutable Cartesian3 instance initialized to (0.0, 0.0, 0.0).\n *\n * @type {Cartesian3}\n * @constant\n */\nCartesian3.ZERO = Object.freeze(new Cartesian3(0.0, 0.0, 0.0));\n\n/**\n * An immutable Cartesian3 instance initialized to (1.0, 1.0, 1.0).\n *\n * @type {Cartesian3}\n * @constant\n */\nCartesian3.ONE = Object.freeze(new Cartesian3(1.0, 1.0, 1.0));\n\n/**\n * An immutable Cartesian3 instance initialized to (1.0, 0.0, 0.0).\n *\n * @type {Cartesian3}\n * @constant\n */\nCartesian3.UNIT_X = Object.freeze(new Cartesian3(1.0, 0.0, 0.0));\n\n/**\n * An immutable Cartesian3 instance initialized to (0.0, 1.0, 0.0).\n *\n * @type {Cartesian3}\n * @constant\n */\nCartesian3.UNIT_Y = Object.freeze(new Cartesian3(0.0, 1.0, 0.0));\n\n/**\n * An immutable Cartesian3 instance initialized to (0.0, 0.0, 1.0).\n *\n * @type {Cartesian3}\n * @constant\n */\nCartesian3.UNIT_Z = Object.freeze(new Cartesian3(0.0, 0.0, 1.0));\n\n/**\n * Duplicates this Cartesian3 instance.\n *\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if one was not provided.\n */\nCartesian3.prototype.clone = function (result) {\n  return Cartesian3.clone(this, result);\n};\n\n/**\n * Compares this Cartesian against the provided Cartesian componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {Cartesian3} [right] The right hand side Cartesian.\n * @returns {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.\n */\nCartesian3.prototype.equals = function (right) {\n  return Cartesian3.equals(this, right);\n};\n\n/**\n * Compares this Cartesian against the provided Cartesian componentwise and returns\n * <code>true</code> if they pass an absolute or relative tolerance test,\n * <code>false</code> otherwise.\n *\n * @param {Cartesian3} [right] The right hand side Cartesian.\n * @param {Number} [relativeEpsilon=0] The relative epsilon tolerance to use for equality testing.\n * @param {Number} [absoluteEpsilon=relativeEpsilon] The absolute epsilon tolerance to use for equality testing.\n * @returns {Boolean} <code>true</code> if they are within the provided epsilon, <code>false</code> otherwise.\n */\nCartesian3.prototype.equalsEpsilon = function (\n  right,\n  relativeEpsilon,\n  absoluteEpsilon\n) {\n  return Cartesian3.equalsEpsilon(\n    this,\n    right,\n    relativeEpsilon,\n    absoluteEpsilon\n  );\n};\n\n/**\n * Creates a string representing this Cartesian in the format '(x, y, z)'.\n *\n * @returns {String} A string representing this Cartesian in the format '(x, y, z)'.\n */\nCartesian3.prototype.toString = function () {\n  return \"(\" + this.x + \", \" + this.y + \", \" + this.z + \")\";\n};\nexport default Cartesian3;\n","import Cartesian3 from \"./Cartesian3.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport CesiumMath from \"./Math.js\";\n\nvar scaleToGeodeticSurfaceIntersection = new Cartesian3();\nvar scaleToGeodeticSurfaceGradient = new Cartesian3();\n\n/**\n * Scales the provided Cartesian position along the geodetic surface normal\n * so that it is on the surface of this ellipsoid.  If the position is\n * at the center of the ellipsoid, this function returns undefined.\n *\n * @param {Cartesian3} cartesian The Cartesian position to scale.\n * @param {Cartesian3} oneOverRadii One over radii of the ellipsoid.\n * @param {Cartesian3} oneOverRadiiSquared One over radii squared of the ellipsoid.\n * @param {Number} centerToleranceSquared Tolerance for closeness to the center.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter, a new Cartesian3 instance if none was provided, or undefined if the position is at the center.\n *\n * @function scaleToGeodeticSurface\n *\n * @private\n */\nfunction scaleToGeodeticSurface(\n  cartesian,\n  oneOverRadii,\n  oneOverRadiiSquared,\n  centerToleranceSquared,\n  result\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(cartesian)) {\n    throw new DeveloperError(\"cartesian is required.\");\n  }\n  if (!defined(oneOverRadii)) {\n    throw new DeveloperError(\"oneOverRadii is required.\");\n  }\n  if (!defined(oneOverRadiiSquared)) {\n    throw new DeveloperError(\"oneOverRadiiSquared is required.\");\n  }\n  if (!defined(centerToleranceSquared)) {\n    throw new DeveloperError(\"centerToleranceSquared is required.\");\n  }\n  //>>includeEnd('debug');\n\n  var positionX = cartesian.x;\n  var positionY = cartesian.y;\n  var positionZ = cartesian.z;\n\n  var oneOverRadiiX = oneOverRadii.x;\n  var oneOverRadiiY = oneOverRadii.y;\n  var oneOverRadiiZ = oneOverRadii.z;\n\n  var x2 = positionX * positionX * oneOverRadiiX * oneOverRadiiX;\n  var y2 = positionY * positionY * oneOverRadiiY * oneOverRadiiY;\n  var z2 = positionZ * positionZ * oneOverRadiiZ * oneOverRadiiZ;\n\n  // Compute the squared ellipsoid norm.\n  var squaredNorm = x2 + y2 + z2;\n  var ratio = Math.sqrt(1.0 / squaredNorm);\n\n  // As an initial approximation, assume that the radial intersection is the projection point.\n  var intersection = Cartesian3.multiplyByScalar(\n    cartesian,\n    ratio,\n    scaleToGeodeticSurfaceIntersection\n  );\n\n  // If the position is near the center, the iteration will not converge.\n  if (squaredNorm < centerToleranceSquared) {\n    return !isFinite(ratio)\n      ? undefined\n      : Cartesian3.clone(intersection, result);\n  }\n\n  var oneOverRadiiSquaredX = oneOverRadiiSquared.x;\n  var oneOverRadiiSquaredY = oneOverRadiiSquared.y;\n  var oneOverRadiiSquaredZ = oneOverRadiiSquared.z;\n\n  // Use the gradient at the intersection point in place of the true unit normal.\n  // The difference in magnitude will be absorbed in the multiplier.\n  var gradient = scaleToGeodeticSurfaceGradient;\n  gradient.x = intersection.x * oneOverRadiiSquaredX * 2.0;\n  gradient.y = intersection.y * oneOverRadiiSquaredY * 2.0;\n  gradient.z = intersection.z * oneOverRadiiSquaredZ * 2.0;\n\n  // Compute the initial guess at the normal vector multiplier, lambda.\n  var lambda =\n    ((1.0 - ratio) * Cartesian3.magnitude(cartesian)) /\n    (0.5 * Cartesian3.magnitude(gradient));\n  var correction = 0.0;\n\n  var func;\n  var denominator;\n  var xMultiplier;\n  var yMultiplier;\n  var zMultiplier;\n  var xMultiplier2;\n  var yMultiplier2;\n  var zMultiplier2;\n  var xMultiplier3;\n  var yMultiplier3;\n  var zMultiplier3;\n\n  do {\n    lambda -= correction;\n\n    xMultiplier = 1.0 / (1.0 + lambda * oneOverRadiiSquaredX);\n    yMultiplier = 1.0 / (1.0 + lambda * oneOverRadiiSquaredY);\n    zMultiplier = 1.0 / (1.0 + lambda * oneOverRadiiSquaredZ);\n\n    xMultiplier2 = xMultiplier * xMultiplier;\n    yMultiplier2 = yMultiplier * yMultiplier;\n    zMultiplier2 = zMultiplier * zMultiplier;\n\n    xMultiplier3 = xMultiplier2 * xMultiplier;\n    yMultiplier3 = yMultiplier2 * yMultiplier;\n    zMultiplier3 = zMultiplier2 * zMultiplier;\n\n    func = x2 * xMultiplier2 + y2 * yMultiplier2 + z2 * zMultiplier2 - 1.0;\n\n    // \"denominator\" here refers to the use of this expression in the velocity and acceleration\n    // computations in the sections to follow.\n    denominator =\n      x2 * xMultiplier3 * oneOverRadiiSquaredX +\n      y2 * yMultiplier3 * oneOverRadiiSquaredY +\n      z2 * zMultiplier3 * oneOverRadiiSquaredZ;\n\n    var derivative = -2.0 * denominator;\n\n    correction = func / derivative;\n  } while (Math.abs(func) > CesiumMath.EPSILON12);\n\n  if (!defined(result)) {\n    return new Cartesian3(\n      positionX * xMultiplier,\n      positionY * yMultiplier,\n      positionZ * zMultiplier\n    );\n  }\n  result.x = positionX * xMultiplier;\n  result.y = positionY * yMultiplier;\n  result.z = positionZ * zMultiplier;\n  return result;\n}\nexport default scaleToGeodeticSurface;\n","import Cartesian3 from \"./Cartesian3.js\";\nimport Check from \"./Check.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport CesiumMath from \"./Math.js\";\nimport scaleToGeodeticSurface from \"./scaleToGeodeticSurface.js\";\n\n/**\n * A position defined by longitude, latitude, and height.\n * @alias Cartographic\n * @constructor\n *\n * @param {Number} [longitude=0.0] The longitude, in radians.\n * @param {Number} [latitude=0.0] The latitude, in radians.\n * @param {Number} [height=0.0] The height, in meters, above the ellipsoid.\n *\n * @see Ellipsoid\n */\nfunction Cartographic(longitude, latitude, height) {\n  /**\n   * The longitude, in radians.\n   * @type {Number}\n   * @default 0.0\n   */\n  this.longitude = defaultValue(longitude, 0.0);\n\n  /**\n   * The latitude, in radians.\n   * @type {Number}\n   * @default 0.0\n   */\n  this.latitude = defaultValue(latitude, 0.0);\n\n  /**\n   * The height, in meters, above the ellipsoid.\n   * @type {Number}\n   * @default 0.0\n   */\n  this.height = defaultValue(height, 0.0);\n}\n\n/**\n * Creates a new Cartographic instance from longitude and latitude\n * specified in radians.\n *\n * @param {Number} longitude The longitude, in radians.\n * @param {Number} latitude The latitude, in radians.\n * @param {Number} [height=0.0] The height, in meters, above the ellipsoid.\n * @param {Cartographic} [result] The object onto which to store the result.\n * @returns {Cartographic} The modified result parameter or a new Cartographic instance if one was not provided.\n */\nCartographic.fromRadians = function (longitude, latitude, height, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"longitude\", longitude);\n  Check.typeOf.number(\"latitude\", latitude);\n  //>>includeEnd('debug');\n\n  height = defaultValue(height, 0.0);\n\n  if (!defined(result)) {\n    return new Cartographic(longitude, latitude, height);\n  }\n\n  result.longitude = longitude;\n  result.latitude = latitude;\n  result.height = height;\n  return result;\n};\n\n/**\n * Creates a new Cartographic instance from longitude and latitude\n * specified in degrees.  The values in the resulting object will\n * be in radians.\n *\n * @param {Number} longitude The longitude, in degrees.\n * @param {Number} latitude The latitude, in degrees.\n * @param {Number} [height=0.0] The height, in meters, above the ellipsoid.\n * @param {Cartographic} [result] The object onto which to store the result.\n * @returns {Cartographic} The modified result parameter or a new Cartographic instance if one was not provided.\n */\nCartographic.fromDegrees = function (longitude, latitude, height, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"longitude\", longitude);\n  Check.typeOf.number(\"latitude\", latitude);\n  //>>includeEnd('debug');\n  longitude = CesiumMath.toRadians(longitude);\n  latitude = CesiumMath.toRadians(latitude);\n\n  return Cartographic.fromRadians(longitude, latitude, height, result);\n};\n\nvar cartesianToCartographicN = new Cartesian3();\nvar cartesianToCartographicP = new Cartesian3();\nvar cartesianToCartographicH = new Cartesian3();\nvar wgs84OneOverRadii = new Cartesian3(\n  1.0 / 6378137.0,\n  1.0 / 6378137.0,\n  1.0 / 6356752.3142451793\n);\nvar wgs84OneOverRadiiSquared = new Cartesian3(\n  1.0 / (6378137.0 * 6378137.0),\n  1.0 / (6378137.0 * 6378137.0),\n  1.0 / (6356752.3142451793 * 6356752.3142451793)\n);\nvar wgs84CenterToleranceSquared = CesiumMath.EPSILON1;\n\n/**\n * Creates a new Cartographic instance from a Cartesian position. The values in the\n * resulting object will be in radians.\n *\n * @param {Cartesian3} cartesian The Cartesian position to convert to cartographic representation.\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the position lies.\n * @param {Cartographic} [result] The object onto which to store the result.\n * @returns {Cartographic} The modified result parameter, new Cartographic instance if none was provided, or undefined if the cartesian is at the center of the ellipsoid.\n */\nCartographic.fromCartesian = function (cartesian, ellipsoid, result) {\n  var oneOverRadii = defined(ellipsoid)\n    ? ellipsoid.oneOverRadii\n    : wgs84OneOverRadii;\n  var oneOverRadiiSquared = defined(ellipsoid)\n    ? ellipsoid.oneOverRadiiSquared\n    : wgs84OneOverRadiiSquared;\n  var centerToleranceSquared = defined(ellipsoid)\n    ? ellipsoid._centerToleranceSquared\n    : wgs84CenterToleranceSquared;\n\n  //`cartesian is required.` is thrown from scaleToGeodeticSurface\n  var p = scaleToGeodeticSurface(\n    cartesian,\n    oneOverRadii,\n    oneOverRadiiSquared,\n    centerToleranceSquared,\n    cartesianToCartographicP\n  );\n\n  if (!defined(p)) {\n    return undefined;\n  }\n\n  var n = Cartesian3.multiplyComponents(\n    p,\n    oneOverRadiiSquared,\n    cartesianToCartographicN\n  );\n  n = Cartesian3.normalize(n, n);\n\n  var h = Cartesian3.subtract(cartesian, p, cartesianToCartographicH);\n\n  var longitude = Math.atan2(n.y, n.x);\n  var latitude = Math.asin(n.z);\n  var height =\n    CesiumMath.sign(Cartesian3.dot(h, cartesian)) * Cartesian3.magnitude(h);\n\n  if (!defined(result)) {\n    return new Cartographic(longitude, latitude, height);\n  }\n  result.longitude = longitude;\n  result.latitude = latitude;\n  result.height = height;\n  return result;\n};\n\n/**\n * Creates a new Cartesian3 instance from a Cartographic input. The values in the inputted\n * object should be in radians.\n *\n * @param {Cartographic} cartographic Input to be converted into a Cartesian3 output.\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the position lies.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The position\n */\nCartographic.toCartesian = function (cartographic, ellipsoid, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"cartographic\", cartographic);\n  //>>includeEnd('debug');\n\n  return Cartesian3.fromRadians(\n    cartographic.longitude,\n    cartographic.latitude,\n    cartographic.height,\n    ellipsoid,\n    result\n  );\n};\n\n/**\n * Duplicates a Cartographic instance.\n *\n * @param {Cartographic} cartographic The cartographic to duplicate.\n * @param {Cartographic} [result] The object onto which to store the result.\n * @returns {Cartographic} The modified result parameter or a new Cartographic instance if one was not provided. (Returns undefined if cartographic is undefined)\n */\nCartographic.clone = function (cartographic, result) {\n  if (!defined(cartographic)) {\n    return undefined;\n  }\n  if (!defined(result)) {\n    return new Cartographic(\n      cartographic.longitude,\n      cartographic.latitude,\n      cartographic.height\n    );\n  }\n  result.longitude = cartographic.longitude;\n  result.latitude = cartographic.latitude;\n  result.height = cartographic.height;\n  return result;\n};\n\n/**\n * Compares the provided cartographics componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {Cartographic} [left] The first cartographic.\n * @param {Cartographic} [right] The second cartographic.\n * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n */\nCartographic.equals = function (left, right) {\n  return (\n    left === right ||\n    (defined(left) &&\n      defined(right) &&\n      left.longitude === right.longitude &&\n      left.latitude === right.latitude &&\n      left.height === right.height)\n  );\n};\n\n/**\n * Compares the provided cartographics componentwise and returns\n * <code>true</code> if they are within the provided epsilon,\n * <code>false</code> otherwise.\n *\n * @param {Cartographic} [left] The first cartographic.\n * @param {Cartographic} [right] The second cartographic.\n * @param {Number} [epsilon=0] The epsilon to use for equality testing.\n * @returns {Boolean} <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.\n */\nCartographic.equalsEpsilon = function (left, right, epsilon) {\n  epsilon = defaultValue(epsilon, 0);\n\n  return (\n    left === right ||\n    (defined(left) &&\n      defined(right) &&\n      Math.abs(left.longitude - right.longitude) <= epsilon &&\n      Math.abs(left.latitude - right.latitude) <= epsilon &&\n      Math.abs(left.height - right.height) <= epsilon)\n  );\n};\n\n/**\n * An immutable Cartographic instance initialized to (0.0, 0.0, 0.0).\n *\n * @type {Cartographic}\n * @constant\n */\nCartographic.ZERO = Object.freeze(new Cartographic(0.0, 0.0, 0.0));\n\n/**\n * Duplicates this instance.\n *\n * @param {Cartographic} [result] The object onto which to store the result.\n * @returns {Cartographic} The modified result parameter or a new Cartographic instance if one was not provided.\n */\nCartographic.prototype.clone = function (result) {\n  return Cartographic.clone(this, result);\n};\n\n/**\n * Compares the provided against this cartographic componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {Cartographic} [right] The second cartographic.\n * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n */\nCartographic.prototype.equals = function (right) {\n  return Cartographic.equals(this, right);\n};\n\n/**\n * Compares the provided against this cartographic componentwise and returns\n * <code>true</code> if they are within the provided epsilon,\n * <code>false</code> otherwise.\n *\n * @param {Cartographic} [right] The second cartographic.\n * @param {Number} [epsilon=0] The epsilon to use for equality testing.\n * @returns {Boolean} <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.\n */\nCartographic.prototype.equalsEpsilon = function (right, epsilon) {\n  return Cartographic.equalsEpsilon(this, right, epsilon);\n};\n\n/**\n * Creates a string representing this cartographic in the format '(longitude, latitude, height)'.\n *\n * @returns {String} A string representing the provided cartographic in the format '(longitude, latitude, height)'.\n */\nCartographic.prototype.toString = function () {\n  return \"(\" + this.longitude + \", \" + this.latitude + \", \" + this.height + \")\";\n};\nexport default Cartographic;\n","import Cartesian3 from \"./Cartesian3.js\";\nimport Cartographic from \"./Cartographic.js\";\nimport Check from \"./Check.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport CesiumMath from \"./Math.js\";\nimport scaleToGeodeticSurface from \"./scaleToGeodeticSurface.js\";\n\nfunction initialize(ellipsoid, x, y, z) {\n  x = defaultValue(x, 0.0);\n  y = defaultValue(y, 0.0);\n  z = defaultValue(z, 0.0);\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number.greaterThanOrEquals(\"x\", x, 0.0);\n  Check.typeOf.number.greaterThanOrEquals(\"y\", y, 0.0);\n  Check.typeOf.number.greaterThanOrEquals(\"z\", z, 0.0);\n  //>>includeEnd('debug');\n\n  ellipsoid._radii = new Cartesian3(x, y, z);\n\n  ellipsoid._radiiSquared = new Cartesian3(x * x, y * y, z * z);\n\n  ellipsoid._radiiToTheFourth = new Cartesian3(\n    x * x * x * x,\n    y * y * y * y,\n    z * z * z * z\n  );\n\n  ellipsoid._oneOverRadii = new Cartesian3(\n    x === 0.0 ? 0.0 : 1.0 / x,\n    y === 0.0 ? 0.0 : 1.0 / y,\n    z === 0.0 ? 0.0 : 1.0 / z\n  );\n\n  ellipsoid._oneOverRadiiSquared = new Cartesian3(\n    x === 0.0 ? 0.0 : 1.0 / (x * x),\n    y === 0.0 ? 0.0 : 1.0 / (y * y),\n    z === 0.0 ? 0.0 : 1.0 / (z * z)\n  );\n\n  ellipsoid._minimumRadius = Math.min(x, y, z);\n\n  ellipsoid._maximumRadius = Math.max(x, y, z);\n\n  ellipsoid._centerToleranceSquared = CesiumMath.EPSILON1;\n\n  if (ellipsoid._radiiSquared.z !== 0) {\n    ellipsoid._squaredXOverSquaredZ =\n      ellipsoid._radiiSquared.x / ellipsoid._radiiSquared.z;\n  }\n}\n\n/**\n * A quadratic surface defined in Cartesian coordinates by the equation\n * <code>(x / a)^2 + (y / b)^2 + (z / c)^2 = 1</code>.  Primarily used\n * by Cesium to represent the shape of planetary bodies.\n *\n * Rather than constructing this object directly, one of the provided\n * constants is normally used.\n * @alias Ellipsoid\n * @constructor\n *\n * @param {Number} [x=0] The radius in the x direction.\n * @param {Number} [y=0] The radius in the y direction.\n * @param {Number} [z=0] The radius in the z direction.\n *\n * @exception {DeveloperError} All radii components must be greater than or equal to zero.\n *\n * @see Ellipsoid.fromCartesian3\n * @see Ellipsoid.WGS84\n * @see Ellipsoid.UNIT_SPHERE\n */\nfunction Ellipsoid(x, y, z) {\n  this._radii = undefined;\n  this._radiiSquared = undefined;\n  this._radiiToTheFourth = undefined;\n  this._oneOverRadii = undefined;\n  this._oneOverRadiiSquared = undefined;\n  this._minimumRadius = undefined;\n  this._maximumRadius = undefined;\n  this._centerToleranceSquared = undefined;\n  this._squaredXOverSquaredZ = undefined;\n\n  initialize(this, x, y, z);\n}\n\nObject.defineProperties(Ellipsoid.prototype, {\n  /**\n   * Gets the radii of the ellipsoid.\n   * @memberof Ellipsoid.prototype\n   * @type {Cartesian3}\n   * @readonly\n   */\n  radii: {\n    get: function () {\n      return this._radii;\n    },\n  },\n  /**\n   * Gets the squared radii of the ellipsoid.\n   * @memberof Ellipsoid.prototype\n   * @type {Cartesian3}\n   * @readonly\n   */\n  radiiSquared: {\n    get: function () {\n      return this._radiiSquared;\n    },\n  },\n  /**\n   * Gets the radii of the ellipsoid raise to the fourth power.\n   * @memberof Ellipsoid.prototype\n   * @type {Cartesian3}\n   * @readonly\n   */\n  radiiToTheFourth: {\n    get: function () {\n      return this._radiiToTheFourth;\n    },\n  },\n  /**\n   * Gets one over the radii of the ellipsoid.\n   * @memberof Ellipsoid.prototype\n   * @type {Cartesian3}\n   * @readonly\n   */\n  oneOverRadii: {\n    get: function () {\n      return this._oneOverRadii;\n    },\n  },\n  /**\n   * Gets one over the squared radii of the ellipsoid.\n   * @memberof Ellipsoid.prototype\n   * @type {Cartesian3}\n   * @readonly\n   */\n  oneOverRadiiSquared: {\n    get: function () {\n      return this._oneOverRadiiSquared;\n    },\n  },\n  /**\n   * Gets the minimum radius of the ellipsoid.\n   * @memberof Ellipsoid.prototype\n   * @type {Number}\n   * @readonly\n   */\n  minimumRadius: {\n    get: function () {\n      return this._minimumRadius;\n    },\n  },\n  /**\n   * Gets the maximum radius of the ellipsoid.\n   * @memberof Ellipsoid.prototype\n   * @type {Number}\n   * @readonly\n   */\n  maximumRadius: {\n    get: function () {\n      return this._maximumRadius;\n    },\n  },\n});\n\n/**\n * Duplicates an Ellipsoid instance.\n *\n * @param {Ellipsoid} ellipsoid The ellipsoid to duplicate.\n * @param {Ellipsoid} [result] The object onto which to store the result, or undefined if a new\n *                    instance should be created.\n * @returns {Ellipsoid} The cloned Ellipsoid. (Returns undefined if ellipsoid is undefined)\n */\nEllipsoid.clone = function (ellipsoid, result) {\n  if (!defined(ellipsoid)) {\n    return undefined;\n  }\n  var radii = ellipsoid._radii;\n\n  if (!defined(result)) {\n    return new Ellipsoid(radii.x, radii.y, radii.z);\n  }\n\n  Cartesian3.clone(radii, result._radii);\n  Cartesian3.clone(ellipsoid._radiiSquared, result._radiiSquared);\n  Cartesian3.clone(ellipsoid._radiiToTheFourth, result._radiiToTheFourth);\n  Cartesian3.clone(ellipsoid._oneOverRadii, result._oneOverRadii);\n  Cartesian3.clone(ellipsoid._oneOverRadiiSquared, result._oneOverRadiiSquared);\n  result._minimumRadius = ellipsoid._minimumRadius;\n  result._maximumRadius = ellipsoid._maximumRadius;\n  result._centerToleranceSquared = ellipsoid._centerToleranceSquared;\n\n  return result;\n};\n\n/**\n * Computes an Ellipsoid from a Cartesian specifying the radii in x, y, and z directions.\n *\n * @param {Cartesian3} [cartesian=Cartesian3.ZERO] The ellipsoid's radius in the x, y, and z directions.\n * @param {Ellipsoid} [result] The object onto which to store the result, or undefined if a new\n *                    instance should be created.\n * @returns {Ellipsoid} A new Ellipsoid instance.\n *\n * @exception {DeveloperError} All radii components must be greater than or equal to zero.\n *\n * @see Ellipsoid.WGS84\n * @see Ellipsoid.UNIT_SPHERE\n */\nEllipsoid.fromCartesian3 = function (cartesian, result) {\n  if (!defined(result)) {\n    result = new Ellipsoid();\n  }\n\n  if (!defined(cartesian)) {\n    return result;\n  }\n\n  initialize(result, cartesian.x, cartesian.y, cartesian.z);\n  return result;\n};\n\n/**\n * An Ellipsoid instance initialized to the WGS84 standard.\n *\n * @type {Ellipsoid}\n * @constant\n */\nEllipsoid.WGS84 = Object.freeze(\n  new Ellipsoid(6378137.0, 6378137.0, 6356752.3142451793)\n);\n\n/**\n * An Ellipsoid instance initialized to radii of (1.0, 1.0, 1.0).\n *\n * @type {Ellipsoid}\n * @constant\n */\nEllipsoid.UNIT_SPHERE = Object.freeze(new Ellipsoid(1.0, 1.0, 1.0));\n\n/**\n * An Ellipsoid instance initialized to a sphere with the lunar radius.\n *\n * @type {Ellipsoid}\n * @constant\n */\nEllipsoid.MOON = Object.freeze(\n  new Ellipsoid(\n    CesiumMath.LUNAR_RADIUS,\n    CesiumMath.LUNAR_RADIUS,\n    CesiumMath.LUNAR_RADIUS\n  )\n);\n\n/**\n * Duplicates an Ellipsoid instance.\n *\n * @param {Ellipsoid} [result] The object onto which to store the result, or undefined if a new\n *                    instance should be created.\n * @returns {Ellipsoid} The cloned Ellipsoid.\n */\nEllipsoid.prototype.clone = function (result) {\n  return Ellipsoid.clone(this, result);\n};\n\n/**\n * The number of elements used to pack the object into an array.\n * @type {Number}\n */\nEllipsoid.packedLength = Cartesian3.packedLength;\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {Ellipsoid} value The value to pack.\n * @param {Number[]} array The array to pack into.\n * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {Number[]} The array that was packed into\n */\nEllipsoid.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"value\", value);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  Cartesian3.pack(value._radii, array, startingIndex);\n\n  return array;\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {Number[]} array The packed array.\n * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {Ellipsoid} [result] The object into which to store the result.\n * @returns {Ellipsoid} The modified result parameter or a new Ellipsoid instance if one was not provided.\n */\nEllipsoid.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  var radii = Cartesian3.unpack(array, startingIndex);\n  return Ellipsoid.fromCartesian3(radii, result);\n};\n\n/**\n * Computes the unit vector directed from the center of this ellipsoid toward the provided Cartesian position.\n * @function\n *\n * @param {Cartesian3} cartesian The Cartesian for which to to determine the geocentric normal.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if none was provided.\n */\nEllipsoid.prototype.geocentricSurfaceNormal = Cartesian3.normalize;\n\n/**\n * Computes the normal of the plane tangent to the surface of the ellipsoid at the provided position.\n *\n * @param {Cartographic} cartographic The cartographic position for which to to determine the geodetic normal.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if none was provided.\n */\nEllipsoid.prototype.geodeticSurfaceNormalCartographic = function (\n  cartographic,\n  result\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartographic\", cartographic);\n  //>>includeEnd('debug');\n\n  var longitude = cartographic.longitude;\n  var latitude = cartographic.latitude;\n  var cosLatitude = Math.cos(latitude);\n\n  var x = cosLatitude * Math.cos(longitude);\n  var y = cosLatitude * Math.sin(longitude);\n  var z = Math.sin(latitude);\n\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n  result.x = x;\n  result.y = y;\n  result.z = z;\n  return Cartesian3.normalize(result, result);\n};\n\n/**\n * Computes the normal of the plane tangent to the surface of the ellipsoid at the provided position.\n *\n * @param {Cartesian3} cartesian The Cartesian position for which to to determine the surface normal.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if none was provided, or undefined if a normal cannot be found.\n */\nEllipsoid.prototype.geodeticSurfaceNormal = function (cartesian, result) {\n  if (\n    Cartesian3.equalsEpsilon(cartesian, Cartesian3.ZERO, CesiumMath.EPSILON14)\n  ) {\n    return undefined;\n  }\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n  result = Cartesian3.multiplyComponents(\n    cartesian,\n    this._oneOverRadiiSquared,\n    result\n  );\n  return Cartesian3.normalize(result, result);\n};\n\nvar cartographicToCartesianNormal = new Cartesian3();\nvar cartographicToCartesianK = new Cartesian3();\n\n/**\n * Converts the provided cartographic to Cartesian representation.\n *\n * @param {Cartographic} cartographic The cartographic position.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if none was provided.\n *\n * @example\n * //Create a Cartographic and determine it's Cartesian representation on a WGS84 ellipsoid.\n * var position = new Cesium.Cartographic(Cesium.Math.toRadians(21), Cesium.Math.toRadians(78), 5000);\n * var cartesianPosition = Cesium.Ellipsoid.WGS84.cartographicToCartesian(position);\n */\nEllipsoid.prototype.cartographicToCartesian = function (cartographic, result) {\n  //`cartographic is required` is thrown from geodeticSurfaceNormalCartographic.\n  var n = cartographicToCartesianNormal;\n  var k = cartographicToCartesianK;\n  this.geodeticSurfaceNormalCartographic(cartographic, n);\n  Cartesian3.multiplyComponents(this._radiiSquared, n, k);\n  var gamma = Math.sqrt(Cartesian3.dot(n, k));\n  Cartesian3.divideByScalar(k, gamma, k);\n  Cartesian3.multiplyByScalar(n, cartographic.height, n);\n\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n  return Cartesian3.add(k, n, result);\n};\n\n/**\n * Converts the provided array of cartographics to an array of Cartesians.\n *\n * @param {Cartographic[]} cartographics An array of cartographic positions.\n * @param {Cartesian3[]} [result] The object onto which to store the result.\n * @returns {Cartesian3[]} The modified result parameter or a new Array instance if none was provided.\n *\n * @example\n * //Convert an array of Cartographics and determine their Cartesian representation on a WGS84 ellipsoid.\n * var positions = [new Cesium.Cartographic(Cesium.Math.toRadians(21), Cesium.Math.toRadians(78), 0),\n *                  new Cesium.Cartographic(Cesium.Math.toRadians(21.321), Cesium.Math.toRadians(78.123), 100),\n *                  new Cesium.Cartographic(Cesium.Math.toRadians(21.645), Cesium.Math.toRadians(78.456), 250)];\n * var cartesianPositions = Cesium.Ellipsoid.WGS84.cartographicArrayToCartesianArray(positions);\n */\nEllipsoid.prototype.cartographicArrayToCartesianArray = function (\n  cartographics,\n  result\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"cartographics\", cartographics);\n  //>>includeEnd('debug')\n\n  var length = cartographics.length;\n  if (!defined(result)) {\n    result = new Array(length);\n  } else {\n    result.length = length;\n  }\n  for (var i = 0; i < length; i++) {\n    result[i] = this.cartographicToCartesian(cartographics[i], result[i]);\n  }\n  return result;\n};\n\nvar cartesianToCartographicN = new Cartesian3();\nvar cartesianToCartographicP = new Cartesian3();\nvar cartesianToCartographicH = new Cartesian3();\n\n/**\n * Converts the provided cartesian to cartographic representation.\n * The cartesian is undefined at the center of the ellipsoid.\n *\n * @param {Cartesian3} cartesian The Cartesian position to convert to cartographic representation.\n * @param {Cartographic} [result] The object onto which to store the result.\n * @returns {Cartographic} The modified result parameter, new Cartographic instance if none was provided, or undefined if the cartesian is at the center of the ellipsoid.\n *\n * @example\n * //Create a Cartesian and determine it's Cartographic representation on a WGS84 ellipsoid.\n * var position = new Cesium.Cartesian3(17832.12, 83234.52, 952313.73);\n * var cartographicPosition = Cesium.Ellipsoid.WGS84.cartesianToCartographic(position);\n */\nEllipsoid.prototype.cartesianToCartographic = function (cartesian, result) {\n  //`cartesian is required.` is thrown from scaleToGeodeticSurface\n  var p = this.scaleToGeodeticSurface(cartesian, cartesianToCartographicP);\n\n  if (!defined(p)) {\n    return undefined;\n  }\n\n  var n = this.geodeticSurfaceNormal(p, cartesianToCartographicN);\n  var h = Cartesian3.subtract(cartesian, p, cartesianToCartographicH);\n\n  var longitude = Math.atan2(n.y, n.x);\n  var latitude = Math.asin(n.z);\n  var height =\n    CesiumMath.sign(Cartesian3.dot(h, cartesian)) * Cartesian3.magnitude(h);\n\n  if (!defined(result)) {\n    return new Cartographic(longitude, latitude, height);\n  }\n  result.longitude = longitude;\n  result.latitude = latitude;\n  result.height = height;\n  return result;\n};\n\n/**\n * Converts the provided array of cartesians to an array of cartographics.\n *\n * @param {Cartesian3[]} cartesians An array of Cartesian positions.\n * @param {Cartographic[]} [result] The object onto which to store the result.\n * @returns {Cartographic[]} The modified result parameter or a new Array instance if none was provided.\n *\n * @example\n * //Create an array of Cartesians and determine their Cartographic representation on a WGS84 ellipsoid.\n * var positions = [new Cesium.Cartesian3(17832.12, 83234.52, 952313.73),\n *                  new Cesium.Cartesian3(17832.13, 83234.53, 952313.73),\n *                  new Cesium.Cartesian3(17832.14, 83234.54, 952313.73)]\n * var cartographicPositions = Cesium.Ellipsoid.WGS84.cartesianArrayToCartographicArray(positions);\n */\nEllipsoid.prototype.cartesianArrayToCartographicArray = function (\n  cartesians,\n  result\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"cartesians\", cartesians);\n  //>>includeEnd('debug');\n\n  var length = cartesians.length;\n  if (!defined(result)) {\n    result = new Array(length);\n  } else {\n    result.length = length;\n  }\n  for (var i = 0; i < length; ++i) {\n    result[i] = this.cartesianToCartographic(cartesians[i], result[i]);\n  }\n  return result;\n};\n\n/**\n * Scales the provided Cartesian position along the geodetic surface normal\n * so that it is on the surface of this ellipsoid.  If the position is\n * at the center of the ellipsoid, this function returns undefined.\n *\n * @param {Cartesian3} cartesian The Cartesian position to scale.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter, a new Cartesian3 instance if none was provided, or undefined if the position is at the center.\n */\nEllipsoid.prototype.scaleToGeodeticSurface = function (cartesian, result) {\n  return scaleToGeodeticSurface(\n    cartesian,\n    this._oneOverRadii,\n    this._oneOverRadiiSquared,\n    this._centerToleranceSquared,\n    result\n  );\n};\n\n/**\n * Scales the provided Cartesian position along the geocentric surface normal\n * so that it is on the surface of this ellipsoid.\n *\n * @param {Cartesian3} cartesian The Cartesian position to scale.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if none was provided.\n */\nEllipsoid.prototype.scaleToGeocentricSurface = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n\n  var positionX = cartesian.x;\n  var positionY = cartesian.y;\n  var positionZ = cartesian.z;\n  var oneOverRadiiSquared = this._oneOverRadiiSquared;\n\n  var beta =\n    1.0 /\n    Math.sqrt(\n      positionX * positionX * oneOverRadiiSquared.x +\n        positionY * positionY * oneOverRadiiSquared.y +\n        positionZ * positionZ * oneOverRadiiSquared.z\n    );\n\n  return Cartesian3.multiplyByScalar(cartesian, beta, result);\n};\n\n/**\n * Transforms a Cartesian X, Y, Z position to the ellipsoid-scaled space by multiplying\n * its components by the result of {@link Ellipsoid#oneOverRadii}.\n *\n * @param {Cartesian3} position The position to transform.\n * @param {Cartesian3} [result] The position to which to copy the result, or undefined to create and\n *        return a new instance.\n * @returns {Cartesian3} The position expressed in the scaled space.  The returned instance is the\n *          one passed as the result parameter if it is not undefined, or a new instance of it is.\n */\nEllipsoid.prototype.transformPositionToScaledSpace = function (\n  position,\n  result\n) {\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n\n  return Cartesian3.multiplyComponents(position, this._oneOverRadii, result);\n};\n\n/**\n * Transforms a Cartesian X, Y, Z position from the ellipsoid-scaled space by multiplying\n * its components by the result of {@link Ellipsoid#radii}.\n *\n * @param {Cartesian3} position The position to transform.\n * @param {Cartesian3} [result] The position to which to copy the result, or undefined to create and\n *        return a new instance.\n * @returns {Cartesian3} The position expressed in the unscaled space.  The returned instance is the\n *          one passed as the result parameter if it is not undefined, or a new instance of it is.\n */\nEllipsoid.prototype.transformPositionFromScaledSpace = function (\n  position,\n  result\n) {\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n\n  return Cartesian3.multiplyComponents(position, this._radii, result);\n};\n\n/**\n * Compares this Ellipsoid against the provided Ellipsoid componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {Ellipsoid} [right] The other Ellipsoid.\n * @returns {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.\n */\nEllipsoid.prototype.equals = function (right) {\n  return (\n    this === right ||\n    (defined(right) && Cartesian3.equals(this._radii, right._radii))\n  );\n};\n\n/**\n * Creates a string representing this Ellipsoid in the format '(radii.x, radii.y, radii.z)'.\n *\n * @returns {String} A string representing this ellipsoid in the format '(radii.x, radii.y, radii.z)'.\n */\nEllipsoid.prototype.toString = function () {\n  return this._radii.toString();\n};\n\n/**\n * Computes a point which is the intersection of the surface normal with the z-axis.\n *\n * @param {Cartesian3} position the position. must be on the surface of the ellipsoid.\n * @param {Number} [buffer = 0.0] A buffer to subtract from the ellipsoid size when checking if the point is inside the ellipsoid.\n *                                In earth case, with common earth datums, there is no need for this buffer since the intersection point is always (relatively) very close to the center.\n *                                In WGS84 datum, intersection point is at max z = +-42841.31151331382 (0.673% of z-axis).\n *                                Intersection point could be outside the ellipsoid if the ratio of MajorAxis / AxisOfRotation is bigger than the square root of 2\n * @param {Cartesian3} [result] The cartesian to which to copy the result, or undefined to create and\n *        return a new instance.\n * @returns {Cartesian3 | undefined} the intersection point if it's inside the ellipsoid, undefined otherwise\n *\n * @exception {DeveloperError} position is required.\n * @exception {DeveloperError} Ellipsoid must be an ellipsoid of revolution (radii.x == radii.y).\n * @exception {DeveloperError} Ellipsoid.radii.z must be greater than 0.\n */\nEllipsoid.prototype.getSurfaceNormalIntersectionWithZAxis = function (\n  position,\n  buffer,\n  result\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"position\", position);\n\n  if (\n    !CesiumMath.equalsEpsilon(\n      this._radii.x,\n      this._radii.y,\n      CesiumMath.EPSILON15\n    )\n  ) {\n    throw new DeveloperError(\n      \"Ellipsoid must be an ellipsoid of revolution (radii.x == radii.y)\"\n    );\n  }\n\n  Check.typeOf.number.greaterThan(\"Ellipsoid.radii.z\", this._radii.z, 0);\n  //>>includeEnd('debug');\n\n  buffer = defaultValue(buffer, 0.0);\n\n  var squaredXOverSquaredZ = this._squaredXOverSquaredZ;\n\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n\n  result.x = 0.0;\n  result.y = 0.0;\n  result.z = position.z * (1 - squaredXOverSquaredZ);\n\n  if (Math.abs(result.z) >= this._radii.z - buffer) {\n    return undefined;\n  }\n\n  return result;\n};\n\nvar abscissas = [\n  0.14887433898163,\n  0.43339539412925,\n  0.67940956829902,\n  0.86506336668898,\n  0.97390652851717,\n  0.0,\n];\nvar weights = [\n  0.29552422471475,\n  0.26926671930999,\n  0.21908636251598,\n  0.14945134915058,\n  0.066671344308684,\n  0.0,\n];\n\n/**\n * Compute the 10th order Gauss-Legendre Quadrature of the given definite integral.\n *\n * @param {Number} a The lower bound for the integration.\n * @param {Number} b The upper bound for the integration.\n * @param {Ellipsoid~RealValuedScalarFunction} func The function to integrate.\n * @returns {Number} The value of the integral of the given function over the given domain.\n *\n * @private\n */\nfunction gaussLegendreQuadrature(a, b, func) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"a\", a);\n  Check.typeOf.number(\"b\", b);\n  Check.typeOf.func(\"func\", func);\n  //>>includeEnd('debug');\n\n  // The range is half of the normal range since the five weights add to one (ten weights add to two).\n  // The values of the abscissas are multiplied by two to account for this.\n  var xMean = 0.5 * (b + a);\n  var xRange = 0.5 * (b - a);\n\n  var sum = 0.0;\n  for (var i = 0; i < 5; i++) {\n    var dx = xRange * abscissas[i];\n    sum += weights[i] * (func(xMean + dx) + func(xMean - dx));\n  }\n\n  // Scale the sum to the range of x.\n  sum *= xRange;\n  return sum;\n}\n\n/**\n * A real valued scalar function.\n * @callback Ellipsoid~RealValuedScalarFunction\n *\n * @param {Number} x The value used to evaluate the function.\n * @returns {Number} The value of the function at x.\n *\n * @private\n */\n\n/**\n * Computes an approximation of the surface area of a rectangle on the surface of an ellipsoid using\n * Gauss-Legendre 10th order quadrature.\n *\n * @param {Rectangle} rectangle The rectangle used for computing the surface area.\n * @returns {Number} The approximate area of the rectangle on the surface of this ellipsoid.\n */\nEllipsoid.prototype.surfaceArea = function (rectangle) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"rectangle\", rectangle);\n  //>>includeEnd('debug');\n  var minLongitude = rectangle.west;\n  var maxLongitude = rectangle.east;\n  var minLatitude = rectangle.south;\n  var maxLatitude = rectangle.north;\n\n  while (maxLongitude < minLongitude) {\n    maxLongitude += CesiumMath.TWO_PI;\n  }\n\n  var radiiSquared = this._radiiSquared;\n  var a2 = radiiSquared.x;\n  var b2 = radiiSquared.y;\n  var c2 = radiiSquared.z;\n  var a2b2 = a2 * b2;\n  return gaussLegendreQuadrature(minLatitude, maxLatitude, function (lat) {\n    // phi represents the angle measured from the north pole\n    // sin(phi) = sin(pi / 2 - lat) = cos(lat), cos(phi) is similar\n    var sinPhi = Math.cos(lat);\n    var cosPhi = Math.sin(lat);\n    return (\n      Math.cos(lat) *\n      gaussLegendreQuadrature(minLongitude, maxLongitude, function (lon) {\n        var cosTheta = Math.cos(lon);\n        var sinTheta = Math.sin(lon);\n        return Math.sqrt(\n          a2b2 * cosPhi * cosPhi +\n            c2 *\n              (b2 * cosTheta * cosTheta + a2 * sinTheta * sinTheta) *\n              sinPhi *\n              sinPhi\n        );\n      })\n    );\n  });\n};\n\nexport default Ellipsoid;\n","import Cartesian3 from \"./Cartesian3.js\";\nimport Check from \"./Check.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport CesiumMath from \"./Math.js\";\n\n/**\n * A 3x3 matrix, indexable as a column-major order array.\n * Constructor parameters are in row-major order for code readability.\n * @alias Matrix3\n * @constructor\n * @implements {ArrayLike<number>}\n *\n * @param {Number} [column0Row0=0.0] The value for column 0, row 0.\n * @param {Number} [column1Row0=0.0] The value for column 1, row 0.\n * @param {Number} [column2Row0=0.0] The value for column 2, row 0.\n * @param {Number} [column0Row1=0.0] The value for column 0, row 1.\n * @param {Number} [column1Row1=0.0] The value for column 1, row 1.\n * @param {Number} [column2Row1=0.0] The value for column 2, row 1.\n * @param {Number} [column0Row2=0.0] The value for column 0, row 2.\n * @param {Number} [column1Row2=0.0] The value for column 1, row 2.\n * @param {Number} [column2Row2=0.0] The value for column 2, row 2.\n *\n * @see Matrix3.fromColumnMajorArray\n * @see Matrix3.fromRowMajorArray\n * @see Matrix3.fromQuaternion\n * @see Matrix3.fromScale\n * @see Matrix3.fromUniformScale\n * @see Matrix2\n * @see Matrix4\n */\nfunction Matrix3(\n  column0Row0,\n  column1Row0,\n  column2Row0,\n  column0Row1,\n  column1Row1,\n  column2Row1,\n  column0Row2,\n  column1Row2,\n  column2Row2\n) {\n  this[0] = defaultValue(column0Row0, 0.0);\n  this[1] = defaultValue(column0Row1, 0.0);\n  this[2] = defaultValue(column0Row2, 0.0);\n  this[3] = defaultValue(column1Row0, 0.0);\n  this[4] = defaultValue(column1Row1, 0.0);\n  this[5] = defaultValue(column1Row2, 0.0);\n  this[6] = defaultValue(column2Row0, 0.0);\n  this[7] = defaultValue(column2Row1, 0.0);\n  this[8] = defaultValue(column2Row2, 0.0);\n}\n\n/**\n * The number of elements used to pack the object into an array.\n * @type {Number}\n */\nMatrix3.packedLength = 9;\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {Matrix3} value The value to pack.\n * @param {Number[]} array The array to pack into.\n * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {Number[]} The array that was packed into\n */\nMatrix3.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"value\", value);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  array[startingIndex++] = value[0];\n  array[startingIndex++] = value[1];\n  array[startingIndex++] = value[2];\n  array[startingIndex++] = value[3];\n  array[startingIndex++] = value[4];\n  array[startingIndex++] = value[5];\n  array[startingIndex++] = value[6];\n  array[startingIndex++] = value[7];\n  array[startingIndex++] = value[8];\n\n  return array;\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {Number[]} array The packed array.\n * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {Matrix3} [result] The object into which to store the result.\n * @returns {Matrix3} The modified result parameter or a new Matrix3 instance if one was not provided.\n */\nMatrix3.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  if (!defined(result)) {\n    result = new Matrix3();\n  }\n\n  result[0] = array[startingIndex++];\n  result[1] = array[startingIndex++];\n  result[2] = array[startingIndex++];\n  result[3] = array[startingIndex++];\n  result[4] = array[startingIndex++];\n  result[5] = array[startingIndex++];\n  result[6] = array[startingIndex++];\n  result[7] = array[startingIndex++];\n  result[8] = array[startingIndex++];\n  return result;\n};\n\n/**\n * Duplicates a Matrix3 instance.\n *\n * @param {Matrix3} matrix The matrix to duplicate.\n * @param {Matrix3} [result] The object onto which to store the result.\n * @returns {Matrix3} The modified result parameter or a new Matrix3 instance if one was not provided. (Returns undefined if matrix is undefined)\n */\nMatrix3.clone = function (matrix, result) {\n  if (!defined(matrix)) {\n    return undefined;\n  }\n  if (!defined(result)) {\n    return new Matrix3(\n      matrix[0],\n      matrix[3],\n      matrix[6],\n      matrix[1],\n      matrix[4],\n      matrix[7],\n      matrix[2],\n      matrix[5],\n      matrix[8]\n    );\n  }\n  result[0] = matrix[0];\n  result[1] = matrix[1];\n  result[2] = matrix[2];\n  result[3] = matrix[3];\n  result[4] = matrix[4];\n  result[5] = matrix[5];\n  result[6] = matrix[6];\n  result[7] = matrix[7];\n  result[8] = matrix[8];\n  return result;\n};\n\n/**\n * Creates a Matrix3 from 9 consecutive elements in an array.\n *\n * @param {Number[]} array The array whose 9 consecutive elements correspond to the positions of the matrix.  Assumes column-major order.\n * @param {Number} [startingIndex=0] The offset into the array of the first element, which corresponds to first column first row position in the matrix.\n * @param {Matrix3} [result] The object onto which to store the result.\n * @returns {Matrix3} The modified result parameter or a new Matrix3 instance if one was not provided.\n *\n * @example\n * // Create the Matrix3:\n * // [1.0, 2.0, 3.0]\n * // [1.0, 2.0, 3.0]\n * // [1.0, 2.0, 3.0]\n *\n * var v = [1.0, 1.0, 1.0, 2.0, 2.0, 2.0, 3.0, 3.0, 3.0];\n * var m = Cesium.Matrix3.fromArray(v);\n *\n * // Create same Matrix3 with using an offset into an array\n * var v2 = [0.0, 0.0, 1.0, 1.0, 1.0, 2.0, 2.0, 2.0, 3.0, 3.0, 3.0];\n * var m2 = Cesium.Matrix3.fromArray(v2, 2);\n */\nMatrix3.fromArray = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  if (!defined(result)) {\n    result = new Matrix3();\n  }\n\n  result[0] = array[startingIndex];\n  result[1] = array[startingIndex + 1];\n  result[2] = array[startingIndex + 2];\n  result[3] = array[startingIndex + 3];\n  result[4] = array[startingIndex + 4];\n  result[5] = array[startingIndex + 5];\n  result[6] = array[startingIndex + 6];\n  result[7] = array[startingIndex + 7];\n  result[8] = array[startingIndex + 8];\n  return result;\n};\n\n/**\n * Creates a Matrix3 instance from a column-major order array.\n *\n * @param {Number[]} values The column-major order array.\n * @param {Matrix3} [result] The object in which the result will be stored, if undefined a new instance will be created.\n * @returns {Matrix3} The modified result parameter, or a new Matrix3 instance if one was not provided.\n */\nMatrix3.fromColumnMajorArray = function (values, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"values\", values);\n  //>>includeEnd('debug');\n\n  return Matrix3.clone(values, result);\n};\n\n/**\n * Creates a Matrix3 instance from a row-major order array.\n * The resulting matrix will be in column-major order.\n *\n * @param {Number[]} values The row-major order array.\n * @param {Matrix3} [result] The object in which the result will be stored, if undefined a new instance will be created.\n * @returns {Matrix3} The modified result parameter, or a new Matrix3 instance if one was not provided.\n */\nMatrix3.fromRowMajorArray = function (values, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"values\", values);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    return new Matrix3(\n      values[0],\n      values[1],\n      values[2],\n      values[3],\n      values[4],\n      values[5],\n      values[6],\n      values[7],\n      values[8]\n    );\n  }\n  result[0] = values[0];\n  result[1] = values[3];\n  result[2] = values[6];\n  result[3] = values[1];\n  result[4] = values[4];\n  result[5] = values[7];\n  result[6] = values[2];\n  result[7] = values[5];\n  result[8] = values[8];\n  return result;\n};\n\n/**\n * Computes a 3x3 rotation matrix from the provided quaternion.\n *\n * @param {Quaternion} quaternion the quaternion to use.\n * @param {Matrix3} [result] The object in which the result will be stored, if undefined a new instance will be created.\n * @returns {Matrix3} The 3x3 rotation matrix from this quaternion.\n */\nMatrix3.fromQuaternion = function (quaternion, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"quaternion\", quaternion);\n  //>>includeEnd('debug');\n\n  var x2 = quaternion.x * quaternion.x;\n  var xy = quaternion.x * quaternion.y;\n  var xz = quaternion.x * quaternion.z;\n  var xw = quaternion.x * quaternion.w;\n  var y2 = quaternion.y * quaternion.y;\n  var yz = quaternion.y * quaternion.z;\n  var yw = quaternion.y * quaternion.w;\n  var z2 = quaternion.z * quaternion.z;\n  var zw = quaternion.z * quaternion.w;\n  var w2 = quaternion.w * quaternion.w;\n\n  var m00 = x2 - y2 - z2 + w2;\n  var m01 = 2.0 * (xy - zw);\n  var m02 = 2.0 * (xz + yw);\n\n  var m10 = 2.0 * (xy + zw);\n  var m11 = -x2 + y2 - z2 + w2;\n  var m12 = 2.0 * (yz - xw);\n\n  var m20 = 2.0 * (xz - yw);\n  var m21 = 2.0 * (yz + xw);\n  var m22 = -x2 - y2 + z2 + w2;\n\n  if (!defined(result)) {\n    return new Matrix3(m00, m01, m02, m10, m11, m12, m20, m21, m22);\n  }\n  result[0] = m00;\n  result[1] = m10;\n  result[2] = m20;\n  result[3] = m01;\n  result[4] = m11;\n  result[5] = m21;\n  result[6] = m02;\n  result[7] = m12;\n  result[8] = m22;\n  return result;\n};\n\n/**\n * Computes a 3x3 rotation matrix from the provided headingPitchRoll. (see http://en.wikipedia.org/wiki/Conversion_between_quaternions_and_Euler_angles )\n *\n * @param {HeadingPitchRoll} headingPitchRoll the headingPitchRoll to use.\n * @param {Matrix3} [result] The object in which the result will be stored, if undefined a new instance will be created.\n * @returns {Matrix3} The 3x3 rotation matrix from this headingPitchRoll.\n */\nMatrix3.fromHeadingPitchRoll = function (headingPitchRoll, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"headingPitchRoll\", headingPitchRoll);\n  //>>includeEnd('debug');\n\n  var cosTheta = Math.cos(-headingPitchRoll.pitch);\n  var cosPsi = Math.cos(-headingPitchRoll.heading);\n  var cosPhi = Math.cos(headingPitchRoll.roll);\n  var sinTheta = Math.sin(-headingPitchRoll.pitch);\n  var sinPsi = Math.sin(-headingPitchRoll.heading);\n  var sinPhi = Math.sin(headingPitchRoll.roll);\n\n  var m00 = cosTheta * cosPsi;\n  var m01 = -cosPhi * sinPsi + sinPhi * sinTheta * cosPsi;\n  var m02 = sinPhi * sinPsi + cosPhi * sinTheta * cosPsi;\n\n  var m10 = cosTheta * sinPsi;\n  var m11 = cosPhi * cosPsi + sinPhi * sinTheta * sinPsi;\n  var m12 = -sinPhi * cosPsi + cosPhi * sinTheta * sinPsi;\n\n  var m20 = -sinTheta;\n  var m21 = sinPhi * cosTheta;\n  var m22 = cosPhi * cosTheta;\n\n  if (!defined(result)) {\n    return new Matrix3(m00, m01, m02, m10, m11, m12, m20, m21, m22);\n  }\n  result[0] = m00;\n  result[1] = m10;\n  result[2] = m20;\n  result[3] = m01;\n  result[4] = m11;\n  result[5] = m21;\n  result[6] = m02;\n  result[7] = m12;\n  result[8] = m22;\n  return result;\n};\n\n/**\n * Computes a Matrix3 instance representing a non-uniform scale.\n *\n * @param {Cartesian3} scale The x, y, and z scale factors.\n * @param {Matrix3} [result] The object in which the result will be stored, if undefined a new instance will be created.\n * @returns {Matrix3} The modified result parameter, or a new Matrix3 instance if one was not provided.\n *\n * @example\n * // Creates\n * //   [7.0, 0.0, 0.0]\n * //   [0.0, 8.0, 0.0]\n * //   [0.0, 0.0, 9.0]\n * var m = Cesium.Matrix3.fromScale(new Cesium.Cartesian3(7.0, 8.0, 9.0));\n */\nMatrix3.fromScale = function (scale, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"scale\", scale);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    return new Matrix3(scale.x, 0.0, 0.0, 0.0, scale.y, 0.0, 0.0, 0.0, scale.z);\n  }\n\n  result[0] = scale.x;\n  result[1] = 0.0;\n  result[2] = 0.0;\n  result[3] = 0.0;\n  result[4] = scale.y;\n  result[5] = 0.0;\n  result[6] = 0.0;\n  result[7] = 0.0;\n  result[8] = scale.z;\n  return result;\n};\n\n/**\n * Computes a Matrix3 instance representing a uniform scale.\n *\n * @param {Number} scale The uniform scale factor.\n * @param {Matrix3} [result] The object in which the result will be stored, if undefined a new instance will be created.\n * @returns {Matrix3} The modified result parameter, or a new Matrix3 instance if one was not provided.\n *\n * @example\n * // Creates\n * //   [2.0, 0.0, 0.0]\n * //   [0.0, 2.0, 0.0]\n * //   [0.0, 0.0, 2.0]\n * var m = Cesium.Matrix3.fromUniformScale(2.0);\n */\nMatrix3.fromUniformScale = function (scale, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"scale\", scale);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    return new Matrix3(scale, 0.0, 0.0, 0.0, scale, 0.0, 0.0, 0.0, scale);\n  }\n\n  result[0] = scale;\n  result[1] = 0.0;\n  result[2] = 0.0;\n  result[3] = 0.0;\n  result[4] = scale;\n  result[5] = 0.0;\n  result[6] = 0.0;\n  result[7] = 0.0;\n  result[8] = scale;\n  return result;\n};\n\n/**\n * Computes a Matrix3 instance representing the cross product equivalent matrix of a Cartesian3 vector.\n *\n * @param {Cartesian3} vector the vector on the left hand side of the cross product operation.\n * @param {Matrix3} [result] The object in which the result will be stored, if undefined a new instance will be created.\n * @returns {Matrix3} The modified result parameter, or a new Matrix3 instance if one was not provided.\n *\n * @example\n * // Creates\n * //   [0.0, -9.0,  8.0]\n * //   [9.0,  0.0, -7.0]\n * //   [-8.0, 7.0,  0.0]\n * var m = Cesium.Matrix3.fromCrossProduct(new Cesium.Cartesian3(7.0, 8.0, 9.0));\n */\nMatrix3.fromCrossProduct = function (vector, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"vector\", vector);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    return new Matrix3(\n      0.0,\n      -vector.z,\n      vector.y,\n      vector.z,\n      0.0,\n      -vector.x,\n      -vector.y,\n      vector.x,\n      0.0\n    );\n  }\n\n  result[0] = 0.0;\n  result[1] = vector.z;\n  result[2] = -vector.y;\n  result[3] = -vector.z;\n  result[4] = 0.0;\n  result[5] = vector.x;\n  result[6] = vector.y;\n  result[7] = -vector.x;\n  result[8] = 0.0;\n  return result;\n};\n\n/**\n * Creates a rotation matrix around the x-axis.\n *\n * @param {Number} angle The angle, in radians, of the rotation.  Positive angles are counterclockwise.\n * @param {Matrix3} [result] The object in which the result will be stored, if undefined a new instance will be created.\n * @returns {Matrix3} The modified result parameter, or a new Matrix3 instance if one was not provided.\n *\n * @example\n * // Rotate a point 45 degrees counterclockwise around the x-axis.\n * var p = new Cesium.Cartesian3(5, 6, 7);\n * var m = Cesium.Matrix3.fromRotationX(Cesium.Math.toRadians(45.0));\n * var rotated = Cesium.Matrix3.multiplyByVector(m, p, new Cesium.Cartesian3());\n */\nMatrix3.fromRotationX = function (angle, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"angle\", angle);\n  //>>includeEnd('debug');\n\n  var cosAngle = Math.cos(angle);\n  var sinAngle = Math.sin(angle);\n\n  if (!defined(result)) {\n    return new Matrix3(\n      1.0,\n      0.0,\n      0.0,\n      0.0,\n      cosAngle,\n      -sinAngle,\n      0.0,\n      sinAngle,\n      cosAngle\n    );\n  }\n\n  result[0] = 1.0;\n  result[1] = 0.0;\n  result[2] = 0.0;\n  result[3] = 0.0;\n  result[4] = cosAngle;\n  result[5] = sinAngle;\n  result[6] = 0.0;\n  result[7] = -sinAngle;\n  result[8] = cosAngle;\n\n  return result;\n};\n\n/**\n * Creates a rotation matrix around the y-axis.\n *\n * @param {Number} angle The angle, in radians, of the rotation.  Positive angles are counterclockwise.\n * @param {Matrix3} [result] The object in which the result will be stored, if undefined a new instance will be created.\n * @returns {Matrix3} The modified result parameter, or a new Matrix3 instance if one was not provided.\n *\n * @example\n * // Rotate a point 45 degrees counterclockwise around the y-axis.\n * var p = new Cesium.Cartesian3(5, 6, 7);\n * var m = Cesium.Matrix3.fromRotationY(Cesium.Math.toRadians(45.0));\n * var rotated = Cesium.Matrix3.multiplyByVector(m, p, new Cesium.Cartesian3());\n */\nMatrix3.fromRotationY = function (angle, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"angle\", angle);\n  //>>includeEnd('debug');\n\n  var cosAngle = Math.cos(angle);\n  var sinAngle = Math.sin(angle);\n\n  if (!defined(result)) {\n    return new Matrix3(\n      cosAngle,\n      0.0,\n      sinAngle,\n      0.0,\n      1.0,\n      0.0,\n      -sinAngle,\n      0.0,\n      cosAngle\n    );\n  }\n\n  result[0] = cosAngle;\n  result[1] = 0.0;\n  result[2] = -sinAngle;\n  result[3] = 0.0;\n  result[4] = 1.0;\n  result[5] = 0.0;\n  result[6] = sinAngle;\n  result[7] = 0.0;\n  result[8] = cosAngle;\n\n  return result;\n};\n\n/**\n * Creates a rotation matrix around the z-axis.\n *\n * @param {Number} angle The angle, in radians, of the rotation.  Positive angles are counterclockwise.\n * @param {Matrix3} [result] The object in which the result will be stored, if undefined a new instance will be created.\n * @returns {Matrix3} The modified result parameter, or a new Matrix3 instance if one was not provided.\n *\n * @example\n * // Rotate a point 45 degrees counterclockwise around the z-axis.\n * var p = new Cesium.Cartesian3(5, 6, 7);\n * var m = Cesium.Matrix3.fromRotationZ(Cesium.Math.toRadians(45.0));\n * var rotated = Cesium.Matrix3.multiplyByVector(m, p, new Cesium.Cartesian3());\n */\nMatrix3.fromRotationZ = function (angle, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"angle\", angle);\n  //>>includeEnd('debug');\n\n  var cosAngle = Math.cos(angle);\n  var sinAngle = Math.sin(angle);\n\n  if (!defined(result)) {\n    return new Matrix3(\n      cosAngle,\n      -sinAngle,\n      0.0,\n      sinAngle,\n      cosAngle,\n      0.0,\n      0.0,\n      0.0,\n      1.0\n    );\n  }\n\n  result[0] = cosAngle;\n  result[1] = sinAngle;\n  result[2] = 0.0;\n  result[3] = -sinAngle;\n  result[4] = cosAngle;\n  result[5] = 0.0;\n  result[6] = 0.0;\n  result[7] = 0.0;\n  result[8] = 1.0;\n\n  return result;\n};\n\n/**\n * Creates an Array from the provided Matrix3 instance.\n * The array will be in column-major order.\n *\n * @param {Matrix3} matrix The matrix to use..\n * @param {Number[]} [result] The Array onto which to store the result.\n * @returns {Number[]} The modified Array parameter or a new Array instance if one was not provided.\n */\nMatrix3.toArray = function (matrix, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    return [\n      matrix[0],\n      matrix[1],\n      matrix[2],\n      matrix[3],\n      matrix[4],\n      matrix[5],\n      matrix[6],\n      matrix[7],\n      matrix[8],\n    ];\n  }\n  result[0] = matrix[0];\n  result[1] = matrix[1];\n  result[2] = matrix[2];\n  result[3] = matrix[3];\n  result[4] = matrix[4];\n  result[5] = matrix[5];\n  result[6] = matrix[6];\n  result[7] = matrix[7];\n  result[8] = matrix[8];\n  return result;\n};\n\n/**\n * Computes the array index of the element at the provided row and column.\n *\n * @param {Number} row The zero-based index of the row.\n * @param {Number} column The zero-based index of the column.\n * @returns {Number} The index of the element at the provided row and column.\n *\n * @exception {DeveloperError} row must be 0, 1, or 2.\n * @exception {DeveloperError} column must be 0, 1, or 2.\n *\n * @example\n * var myMatrix = new Cesium.Matrix3();\n * var column1Row0Index = Cesium.Matrix3.getElementIndex(1, 0);\n * var column1Row0 = myMatrix[column1Row0Index]\n * myMatrix[column1Row0Index] = 10.0;\n */\nMatrix3.getElementIndex = function (column, row) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number.greaterThanOrEquals(\"row\", row, 0);\n  Check.typeOf.number.lessThanOrEquals(\"row\", row, 2);\n  Check.typeOf.number.greaterThanOrEquals(\"column\", column, 0);\n  Check.typeOf.number.lessThanOrEquals(\"column\", column, 2);\n  //>>includeEnd('debug');\n\n  return column * 3 + row;\n};\n\n/**\n * Retrieves a copy of the matrix column at the provided index as a Cartesian3 instance.\n *\n * @param {Matrix3} matrix The matrix to use.\n * @param {Number} index The zero-based index of the column to retrieve.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter.\n *\n * @exception {DeveloperError} index must be 0, 1, or 2.\n */\nMatrix3.getColumn = function (matrix, index, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.number.greaterThanOrEquals(\"index\", index, 0);\n  Check.typeOf.number.lessThanOrEquals(\"index\", index, 2);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  var startIndex = index * 3;\n  var x = matrix[startIndex];\n  var y = matrix[startIndex + 1];\n  var z = matrix[startIndex + 2];\n\n  result.x = x;\n  result.y = y;\n  result.z = z;\n  return result;\n};\n\n/**\n * Computes a new matrix that replaces the specified column in the provided matrix with the provided Cartesian3 instance.\n *\n * @param {Matrix3} matrix The matrix to use.\n * @param {Number} index The zero-based index of the column to set.\n * @param {Cartesian3} cartesian The Cartesian whose values will be assigned to the specified column.\n * @param {Matrix3} result The object onto which to store the result.\n * @returns {Matrix3} The modified result parameter.\n *\n * @exception {DeveloperError} index must be 0, 1, or 2.\n */\nMatrix3.setColumn = function (matrix, index, cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.number.greaterThanOrEquals(\"index\", index, 0);\n  Check.typeOf.number.lessThanOrEquals(\"index\", index, 2);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result = Matrix3.clone(matrix, result);\n  var startIndex = index * 3;\n  result[startIndex] = cartesian.x;\n  result[startIndex + 1] = cartesian.y;\n  result[startIndex + 2] = cartesian.z;\n  return result;\n};\n\n/**\n * Retrieves a copy of the matrix row at the provided index as a Cartesian3 instance.\n *\n * @param {Matrix3} matrix The matrix to use.\n * @param {Number} index The zero-based index of the row to retrieve.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter.\n *\n * @exception {DeveloperError} index must be 0, 1, or 2.\n */\nMatrix3.getRow = function (matrix, index, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.number.greaterThanOrEquals(\"index\", index, 0);\n  Check.typeOf.number.lessThanOrEquals(\"index\", index, 2);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  var x = matrix[index];\n  var y = matrix[index + 3];\n  var z = matrix[index + 6];\n\n  result.x = x;\n  result.y = y;\n  result.z = z;\n  return result;\n};\n\n/**\n * Computes a new matrix that replaces the specified row in the provided matrix with the provided Cartesian3 instance.\n *\n * @param {Matrix3} matrix The matrix to use.\n * @param {Number} index The zero-based index of the row to set.\n * @param {Cartesian3} cartesian The Cartesian whose values will be assigned to the specified row.\n * @param {Matrix3} result The object onto which to store the result.\n * @returns {Matrix3} The modified result parameter.\n *\n * @exception {DeveloperError} index must be 0, 1, or 2.\n */\nMatrix3.setRow = function (matrix, index, cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.number.greaterThanOrEquals(\"index\", index, 0);\n  Check.typeOf.number.lessThanOrEquals(\"index\", index, 2);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result = Matrix3.clone(matrix, result);\n  result[index] = cartesian.x;\n  result[index + 3] = cartesian.y;\n  result[index + 6] = cartesian.z;\n  return result;\n};\n\nvar scratchColumn = new Cartesian3();\n\n/**\n * Extracts the non-uniform scale assuming the matrix is an affine transformation.\n *\n * @param {Matrix3} matrix The matrix.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter.\n */\nMatrix3.getScale = function (matrix, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = Cartesian3.magnitude(\n    Cartesian3.fromElements(matrix[0], matrix[1], matrix[2], scratchColumn)\n  );\n  result.y = Cartesian3.magnitude(\n    Cartesian3.fromElements(matrix[3], matrix[4], matrix[5], scratchColumn)\n  );\n  result.z = Cartesian3.magnitude(\n    Cartesian3.fromElements(matrix[6], matrix[7], matrix[8], scratchColumn)\n  );\n  return result;\n};\n\nvar scratchScale = new Cartesian3();\n\n/**\n * Computes the maximum scale assuming the matrix is an affine transformation.\n * The maximum scale is the maximum length of the column vectors.\n *\n * @param {Matrix3} matrix The matrix.\n * @returns {Number} The maximum scale.\n */\nMatrix3.getMaximumScale = function (matrix) {\n  Matrix3.getScale(matrix, scratchScale);\n  return Cartesian3.maximumComponent(scratchScale);\n};\n\n/**\n * Computes the product of two matrices.\n *\n * @param {Matrix3} left The first matrix.\n * @param {Matrix3} right The second matrix.\n * @param {Matrix3} result The object onto which to store the result.\n * @returns {Matrix3} The modified result parameter.\n */\nMatrix3.multiply = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  var column0Row0 =\n    left[0] * right[0] + left[3] * right[1] + left[6] * right[2];\n  var column0Row1 =\n    left[1] * right[0] + left[4] * right[1] + left[7] * right[2];\n  var column0Row2 =\n    left[2] * right[0] + left[5] * right[1] + left[8] * right[2];\n\n  var column1Row0 =\n    left[0] * right[3] + left[3] * right[4] + left[6] * right[5];\n  var column1Row1 =\n    left[1] * right[3] + left[4] * right[4] + left[7] * right[5];\n  var column1Row2 =\n    left[2] * right[3] + left[5] * right[4] + left[8] * right[5];\n\n  var column2Row0 =\n    left[0] * right[6] + left[3] * right[7] + left[6] * right[8];\n  var column2Row1 =\n    left[1] * right[6] + left[4] * right[7] + left[7] * right[8];\n  var column2Row2 =\n    left[2] * right[6] + left[5] * right[7] + left[8] * right[8];\n\n  result[0] = column0Row0;\n  result[1] = column0Row1;\n  result[2] = column0Row2;\n  result[3] = column1Row0;\n  result[4] = column1Row1;\n  result[5] = column1Row2;\n  result[6] = column2Row0;\n  result[7] = column2Row1;\n  result[8] = column2Row2;\n  return result;\n};\n\n/**\n * Computes the sum of two matrices.\n *\n * @param {Matrix3} left The first matrix.\n * @param {Matrix3} right The second matrix.\n * @param {Matrix3} result The object onto which to store the result.\n * @returns {Matrix3} The modified result parameter.\n */\nMatrix3.add = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result[0] = left[0] + right[0];\n  result[1] = left[1] + right[1];\n  result[2] = left[2] + right[2];\n  result[3] = left[3] + right[3];\n  result[4] = left[4] + right[4];\n  result[5] = left[5] + right[5];\n  result[6] = left[6] + right[6];\n  result[7] = left[7] + right[7];\n  result[8] = left[8] + right[8];\n  return result;\n};\n\n/**\n * Computes the difference of two matrices.\n *\n * @param {Matrix3} left The first matrix.\n * @param {Matrix3} right The second matrix.\n * @param {Matrix3} result The object onto which to store the result.\n * @returns {Matrix3} The modified result parameter.\n */\nMatrix3.subtract = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result[0] = left[0] - right[0];\n  result[1] = left[1] - right[1];\n  result[2] = left[2] - right[2];\n  result[3] = left[3] - right[3];\n  result[4] = left[4] - right[4];\n  result[5] = left[5] - right[5];\n  result[6] = left[6] - right[6];\n  result[7] = left[7] - right[7];\n  result[8] = left[8] - right[8];\n  return result;\n};\n\n/**\n * Computes the product of a matrix and a column vector.\n *\n * @param {Matrix3} matrix The matrix.\n * @param {Cartesian3} cartesian The column.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter.\n */\nMatrix3.multiplyByVector = function (matrix, cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  var vX = cartesian.x;\n  var vY = cartesian.y;\n  var vZ = cartesian.z;\n\n  var x = matrix[0] * vX + matrix[3] * vY + matrix[6] * vZ;\n  var y = matrix[1] * vX + matrix[4] * vY + matrix[7] * vZ;\n  var z = matrix[2] * vX + matrix[5] * vY + matrix[8] * vZ;\n\n  result.x = x;\n  result.y = y;\n  result.z = z;\n  return result;\n};\n\n/**\n * Computes the product of a matrix and a scalar.\n *\n * @param {Matrix3} matrix The matrix.\n * @param {Number} scalar The number to multiply by.\n * @param {Matrix3} result The object onto which to store the result.\n * @returns {Matrix3} The modified result parameter.\n */\nMatrix3.multiplyByScalar = function (matrix, scalar, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.number(\"scalar\", scalar);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result[0] = matrix[0] * scalar;\n  result[1] = matrix[1] * scalar;\n  result[2] = matrix[2] * scalar;\n  result[3] = matrix[3] * scalar;\n  result[4] = matrix[4] * scalar;\n  result[5] = matrix[5] * scalar;\n  result[6] = matrix[6] * scalar;\n  result[7] = matrix[7] * scalar;\n  result[8] = matrix[8] * scalar;\n  return result;\n};\n\n/**\n * Computes the product of a matrix times a (non-uniform) scale, as if the scale were a scale matrix.\n *\n * @param {Matrix3} matrix The matrix on the left-hand side.\n * @param {Cartesian3} scale The non-uniform scale on the right-hand side.\n * @param {Matrix3} result The object onto which to store the result.\n * @returns {Matrix3} The modified result parameter.\n *\n *\n * @example\n * // Instead of Cesium.Matrix3.multiply(m, Cesium.Matrix3.fromScale(scale), m);\n * Cesium.Matrix3.multiplyByScale(m, scale, m);\n *\n * @see Matrix3.fromScale\n * @see Matrix3.multiplyByUniformScale\n */\nMatrix3.multiplyByScale = function (matrix, scale, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.object(\"scale\", scale);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result[0] = matrix[0] * scale.x;\n  result[1] = matrix[1] * scale.x;\n  result[2] = matrix[2] * scale.x;\n  result[3] = matrix[3] * scale.y;\n  result[4] = matrix[4] * scale.y;\n  result[5] = matrix[5] * scale.y;\n  result[6] = matrix[6] * scale.z;\n  result[7] = matrix[7] * scale.z;\n  result[8] = matrix[8] * scale.z;\n  return result;\n};\n\n/**\n * Creates a negated copy of the provided matrix.\n *\n * @param {Matrix3} matrix The matrix to negate.\n * @param {Matrix3} result The object onto which to store the result.\n * @returns {Matrix3} The modified result parameter.\n */\nMatrix3.negate = function (matrix, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result[0] = -matrix[0];\n  result[1] = -matrix[1];\n  result[2] = -matrix[2];\n  result[3] = -matrix[3];\n  result[4] = -matrix[4];\n  result[5] = -matrix[5];\n  result[6] = -matrix[6];\n  result[7] = -matrix[7];\n  result[8] = -matrix[8];\n  return result;\n};\n\n/**\n * Computes the transpose of the provided matrix.\n *\n * @param {Matrix3} matrix The matrix to transpose.\n * @param {Matrix3} result The object onto which to store the result.\n * @returns {Matrix3} The modified result parameter.\n */\nMatrix3.transpose = function (matrix, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  var column0Row0 = matrix[0];\n  var column0Row1 = matrix[3];\n  var column0Row2 = matrix[6];\n  var column1Row0 = matrix[1];\n  var column1Row1 = matrix[4];\n  var column1Row2 = matrix[7];\n  var column2Row0 = matrix[2];\n  var column2Row1 = matrix[5];\n  var column2Row2 = matrix[8];\n\n  result[0] = column0Row0;\n  result[1] = column0Row1;\n  result[2] = column0Row2;\n  result[3] = column1Row0;\n  result[4] = column1Row1;\n  result[5] = column1Row2;\n  result[6] = column2Row0;\n  result[7] = column2Row1;\n  result[8] = column2Row2;\n  return result;\n};\n\nvar UNIT = new Cartesian3(1, 1, 1);\n\n/**\n * Extracts the rotation assuming the matrix is an affine transformation.\n *\n * @param {Matrix3} matrix The matrix.\n * @param {Matrix3} result The object onto which to store the result.\n * @returns {Matrix3} The modified result parameter\n */\nMatrix3.getRotation = function (matrix, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  var inverseScale = Cartesian3.divideComponents(\n    UNIT,\n    Matrix3.getScale(matrix, scratchScale),\n    scratchScale\n  );\n  result = Matrix3.multiplyByScale(matrix, inverseScale, result);\n\n  return result;\n};\n\nfunction computeFrobeniusNorm(matrix) {\n  var norm = 0.0;\n  for (var i = 0; i < 9; ++i) {\n    var temp = matrix[i];\n    norm += temp * temp;\n  }\n\n  return Math.sqrt(norm);\n}\n\nvar rowVal = [1, 0, 0];\nvar colVal = [2, 2, 1];\n\nfunction offDiagonalFrobeniusNorm(matrix) {\n  // Computes the \"off-diagonal\" Frobenius norm.\n  // Assumes matrix is symmetric.\n\n  var norm = 0.0;\n  for (var i = 0; i < 3; ++i) {\n    var temp = matrix[Matrix3.getElementIndex(colVal[i], rowVal[i])];\n    norm += 2.0 * temp * temp;\n  }\n\n  return Math.sqrt(norm);\n}\n\nfunction shurDecomposition(matrix, result) {\n  // This routine was created based upon Matrix Computations, 3rd ed., by Golub and Van Loan,\n  // section 8.4.2 The 2by2 Symmetric Schur Decomposition.\n  //\n  // The routine takes a matrix, which is assumed to be symmetric, and\n  // finds the largest off-diagonal term, and then creates\n  // a matrix (result) which can be used to help reduce it\n\n  var tolerance = CesiumMath.EPSILON15;\n\n  var maxDiagonal = 0.0;\n  var rotAxis = 1;\n\n  // find pivot (rotAxis) based on max diagonal of matrix\n  for (var i = 0; i < 3; ++i) {\n    var temp = Math.abs(matrix[Matrix3.getElementIndex(colVal[i], rowVal[i])]);\n    if (temp > maxDiagonal) {\n      rotAxis = i;\n      maxDiagonal = temp;\n    }\n  }\n\n  var c = 1.0;\n  var s = 0.0;\n\n  var p = rowVal[rotAxis];\n  var q = colVal[rotAxis];\n\n  if (Math.abs(matrix[Matrix3.getElementIndex(q, p)]) > tolerance) {\n    var qq = matrix[Matrix3.getElementIndex(q, q)];\n    var pp = matrix[Matrix3.getElementIndex(p, p)];\n    var qp = matrix[Matrix3.getElementIndex(q, p)];\n\n    var tau = (qq - pp) / 2.0 / qp;\n    var t;\n\n    if (tau < 0.0) {\n      t = -1.0 / (-tau + Math.sqrt(1.0 + tau * tau));\n    } else {\n      t = 1.0 / (tau + Math.sqrt(1.0 + tau * tau));\n    }\n\n    c = 1.0 / Math.sqrt(1.0 + t * t);\n    s = t * c;\n  }\n\n  result = Matrix3.clone(Matrix3.IDENTITY, result);\n\n  result[Matrix3.getElementIndex(p, p)] = result[\n    Matrix3.getElementIndex(q, q)\n  ] = c;\n  result[Matrix3.getElementIndex(q, p)] = s;\n  result[Matrix3.getElementIndex(p, q)] = -s;\n\n  return result;\n}\n\nvar jMatrix = new Matrix3();\nvar jMatrixTranspose = new Matrix3();\n\n/**\n * Computes the eigenvectors and eigenvalues of a symmetric matrix.\n * <p>\n * Returns a diagonal matrix and unitary matrix such that:\n * <code>matrix = unitary matrix * diagonal matrix * transpose(unitary matrix)</code>\n * </p>\n * <p>\n * The values along the diagonal of the diagonal matrix are the eigenvalues. The columns\n * of the unitary matrix are the corresponding eigenvectors.\n * </p>\n *\n * @param {Matrix3} matrix The matrix to decompose into diagonal and unitary matrix. Expected to be symmetric.\n * @param {Object} [result] An object with unitary and diagonal properties which are matrices onto which to store the result.\n * @returns {Object} An object with unitary and diagonal properties which are the unitary and diagonal matrices, respectively.\n *\n * @example\n * var a = //... symetric matrix\n * var result = {\n *     unitary : new Cesium.Matrix3(),\n *     diagonal : new Cesium.Matrix3()\n * };\n * Cesium.Matrix3.computeEigenDecomposition(a, result);\n *\n * var unitaryTranspose = Cesium.Matrix3.transpose(result.unitary, new Cesium.Matrix3());\n * var b = Cesium.Matrix3.multiply(result.unitary, result.diagonal, new Cesium.Matrix3());\n * Cesium.Matrix3.multiply(b, unitaryTranspose, b); // b is now equal to a\n *\n * var lambda = Cesium.Matrix3.getColumn(result.diagonal, 0, new Cesium.Cartesian3()).x;  // first eigenvalue\n * var v = Cesium.Matrix3.getColumn(result.unitary, 0, new Cesium.Cartesian3());          // first eigenvector\n * var c = Cesium.Cartesian3.multiplyByScalar(v, lambda, new Cesium.Cartesian3());        // equal to Cesium.Matrix3.multiplyByVector(a, v)\n */\nMatrix3.computeEigenDecomposition = function (matrix, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  //>>includeEnd('debug');\n\n  // This routine was created based upon Matrix Computations, 3rd ed., by Golub and Van Loan,\n  // section 8.4.3 The Classical Jacobi Algorithm\n\n  var tolerance = CesiumMath.EPSILON20;\n  var maxSweeps = 10;\n\n  var count = 0;\n  var sweep = 0;\n\n  if (!defined(result)) {\n    result = {};\n  }\n\n  var unitaryMatrix = (result.unitary = Matrix3.clone(\n    Matrix3.IDENTITY,\n    result.unitary\n  ));\n  var diagMatrix = (result.diagonal = Matrix3.clone(matrix, result.diagonal));\n\n  var epsilon = tolerance * computeFrobeniusNorm(diagMatrix);\n\n  while (sweep < maxSweeps && offDiagonalFrobeniusNorm(diagMatrix) > epsilon) {\n    shurDecomposition(diagMatrix, jMatrix);\n    Matrix3.transpose(jMatrix, jMatrixTranspose);\n    Matrix3.multiply(diagMatrix, jMatrix, diagMatrix);\n    Matrix3.multiply(jMatrixTranspose, diagMatrix, diagMatrix);\n    Matrix3.multiply(unitaryMatrix, jMatrix, unitaryMatrix);\n\n    if (++count > 2) {\n      ++sweep;\n      count = 0;\n    }\n  }\n\n  return result;\n};\n\n/**\n * Computes a matrix, which contains the absolute (unsigned) values of the provided matrix's elements.\n *\n * @param {Matrix3} matrix The matrix with signed elements.\n * @param {Matrix3} result The object onto which to store the result.\n * @returns {Matrix3} The modified result parameter.\n */\nMatrix3.abs = function (matrix, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result[0] = Math.abs(matrix[0]);\n  result[1] = Math.abs(matrix[1]);\n  result[2] = Math.abs(matrix[2]);\n  result[3] = Math.abs(matrix[3]);\n  result[4] = Math.abs(matrix[4]);\n  result[5] = Math.abs(matrix[5]);\n  result[6] = Math.abs(matrix[6]);\n  result[7] = Math.abs(matrix[7]);\n  result[8] = Math.abs(matrix[8]);\n\n  return result;\n};\n\n/**\n * Computes the determinant of the provided matrix.\n *\n * @param {Matrix3} matrix The matrix to use.\n * @returns {Number} The value of the determinant of the matrix.\n */\nMatrix3.determinant = function (matrix) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  //>>includeEnd('debug');\n\n  var m11 = matrix[0];\n  var m21 = matrix[3];\n  var m31 = matrix[6];\n  var m12 = matrix[1];\n  var m22 = matrix[4];\n  var m32 = matrix[7];\n  var m13 = matrix[2];\n  var m23 = matrix[5];\n  var m33 = matrix[8];\n\n  return (\n    m11 * (m22 * m33 - m23 * m32) +\n    m12 * (m23 * m31 - m21 * m33) +\n    m13 * (m21 * m32 - m22 * m31)\n  );\n};\n\n/**\n * Computes the inverse of the provided matrix.\n *\n * @param {Matrix3} matrix The matrix to invert.\n * @param {Matrix3} result The object onto which to store the result.\n * @returns {Matrix3} The modified result parameter.\n *\n * @exception {DeveloperError} matrix is not invertible.\n */\nMatrix3.inverse = function (matrix, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  var m11 = matrix[0];\n  var m21 = matrix[1];\n  var m31 = matrix[2];\n  var m12 = matrix[3];\n  var m22 = matrix[4];\n  var m32 = matrix[5];\n  var m13 = matrix[6];\n  var m23 = matrix[7];\n  var m33 = matrix[8];\n\n  var determinant = Matrix3.determinant(matrix);\n\n  //>>includeStart('debug', pragmas.debug);\n  if (Math.abs(determinant) <= CesiumMath.EPSILON15) {\n    throw new DeveloperError(\"matrix is not invertible\");\n  }\n  //>>includeEnd('debug');\n\n  result[0] = m22 * m33 - m23 * m32;\n  result[1] = m23 * m31 - m21 * m33;\n  result[2] = m21 * m32 - m22 * m31;\n  result[3] = m13 * m32 - m12 * m33;\n  result[4] = m11 * m33 - m13 * m31;\n  result[5] = m12 * m31 - m11 * m32;\n  result[6] = m12 * m23 - m13 * m22;\n  result[7] = m13 * m21 - m11 * m23;\n  result[8] = m11 * m22 - m12 * m21;\n\n  var scale = 1.0 / determinant;\n  return Matrix3.multiplyByScalar(result, scale, result);\n};\n\nvar scratchTransposeMatrix = new Matrix3();\n\n/**\n * Computes the inverse transpose of a matrix.\n *\n * @param {Matrix3} matrix The matrix to transpose and invert.\n * @param {Matrix3} result The object onto which to store the result.\n * @returns {Matrix3} The modified result parameter.\n */\nMatrix3.inverseTranspose = function (matrix, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  return Matrix3.inverse(\n    Matrix3.transpose(matrix, scratchTransposeMatrix),\n    result\n  );\n};\n\n/**\n * Compares the provided matrices componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {Matrix3} [left] The first matrix.\n * @param {Matrix3} [right] The second matrix.\n * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n */\nMatrix3.equals = function (left, right) {\n  return (\n    left === right ||\n    (defined(left) &&\n      defined(right) &&\n      left[0] === right[0] &&\n      left[1] === right[1] &&\n      left[2] === right[2] &&\n      left[3] === right[3] &&\n      left[4] === right[4] &&\n      left[5] === right[5] &&\n      left[6] === right[6] &&\n      left[7] === right[7] &&\n      left[8] === right[8])\n  );\n};\n\n/**\n * Compares the provided matrices componentwise and returns\n * <code>true</code> if they are within the provided epsilon,\n * <code>false</code> otherwise.\n *\n * @param {Matrix3} [left] The first matrix.\n * @param {Matrix3} [right] The second matrix.\n * @param {Number} [epsilon=0] The epsilon to use for equality testing.\n * @returns {Boolean} <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.\n */\nMatrix3.equalsEpsilon = function (left, right, epsilon) {\n  epsilon = defaultValue(epsilon, 0);\n\n  return (\n    left === right ||\n    (defined(left) &&\n      defined(right) &&\n      Math.abs(left[0] - right[0]) <= epsilon &&\n      Math.abs(left[1] - right[1]) <= epsilon &&\n      Math.abs(left[2] - right[2]) <= epsilon &&\n      Math.abs(left[3] - right[3]) <= epsilon &&\n      Math.abs(left[4] - right[4]) <= epsilon &&\n      Math.abs(left[5] - right[5]) <= epsilon &&\n      Math.abs(left[6] - right[6]) <= epsilon &&\n      Math.abs(left[7] - right[7]) <= epsilon &&\n      Math.abs(left[8] - right[8]) <= epsilon)\n  );\n};\n\n/**\n * An immutable Matrix3 instance initialized to the identity matrix.\n *\n * @type {Matrix3}\n * @constant\n */\nMatrix3.IDENTITY = Object.freeze(\n  new Matrix3(1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0)\n);\n\n/**\n * An immutable Matrix3 instance initialized to the zero matrix.\n *\n * @type {Matrix3}\n * @constant\n */\nMatrix3.ZERO = Object.freeze(\n  new Matrix3(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0)\n);\n\n/**\n * The index into Matrix3 for column 0, row 0.\n *\n * @type {Number}\n * @constant\n */\nMatrix3.COLUMN0ROW0 = 0;\n\n/**\n * The index into Matrix3 for column 0, row 1.\n *\n * @type {Number}\n * @constant\n */\nMatrix3.COLUMN0ROW1 = 1;\n\n/**\n * The index into Matrix3 for column 0, row 2.\n *\n * @type {Number}\n * @constant\n */\nMatrix3.COLUMN0ROW2 = 2;\n\n/**\n * The index into Matrix3 for column 1, row 0.\n *\n * @type {Number}\n * @constant\n */\nMatrix3.COLUMN1ROW0 = 3;\n\n/**\n * The index into Matrix3 for column 1, row 1.\n *\n * @type {Number}\n * @constant\n */\nMatrix3.COLUMN1ROW1 = 4;\n\n/**\n * The index into Matrix3 for column 1, row 2.\n *\n * @type {Number}\n * @constant\n */\nMatrix3.COLUMN1ROW2 = 5;\n\n/**\n * The index into Matrix3 for column 2, row 0.\n *\n * @type {Number}\n * @constant\n */\nMatrix3.COLUMN2ROW0 = 6;\n\n/**\n * The index into Matrix3 for column 2, row 1.\n *\n * @type {Number}\n * @constant\n */\nMatrix3.COLUMN2ROW1 = 7;\n\n/**\n * The index into Matrix3 for column 2, row 2.\n *\n * @type {Number}\n * @constant\n */\nMatrix3.COLUMN2ROW2 = 8;\n\nObject.defineProperties(Matrix3.prototype, {\n  /**\n   * Gets the number of items in the collection.\n   * @memberof Matrix3.prototype\n   *\n   * @type {Number}\n   */\n  length: {\n    get: function () {\n      return Matrix3.packedLength;\n    },\n  },\n});\n\n/**\n * Duplicates the provided Matrix3 instance.\n *\n * @param {Matrix3} [result] The object onto which to store the result.\n * @returns {Matrix3} The modified result parameter or a new Matrix3 instance if one was not provided.\n */\nMatrix3.prototype.clone = function (result) {\n  return Matrix3.clone(this, result);\n};\n\n/**\n * Compares this matrix to the provided matrix componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {Matrix3} [right] The right hand side matrix.\n * @returns {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.\n */\nMatrix3.prototype.equals = function (right) {\n  return Matrix3.equals(this, right);\n};\n\n/**\n * @private\n */\nMatrix3.equalsArray = function (matrix, array, offset) {\n  return (\n    matrix[0] === array[offset] &&\n    matrix[1] === array[offset + 1] &&\n    matrix[2] === array[offset + 2] &&\n    matrix[3] === array[offset + 3] &&\n    matrix[4] === array[offset + 4] &&\n    matrix[5] === array[offset + 5] &&\n    matrix[6] === array[offset + 6] &&\n    matrix[7] === array[offset + 7] &&\n    matrix[8] === array[offset + 8]\n  );\n};\n\n/**\n * Compares this matrix to the provided matrix componentwise and returns\n * <code>true</code> if they are within the provided epsilon,\n * <code>false</code> otherwise.\n *\n * @param {Matrix3} [right] The right hand side matrix.\n * @param {Number} [epsilon=0] The epsilon to use for equality testing.\n * @returns {Boolean} <code>true</code> if they are within the provided epsilon, <code>false</code> otherwise.\n */\nMatrix3.prototype.equalsEpsilon = function (right, epsilon) {\n  return Matrix3.equalsEpsilon(this, right, epsilon);\n};\n\n/**\n * Creates a string representing this Matrix with each row being\n * on a separate line and in the format '(column0, column1, column2)'.\n *\n * @returns {String} A string representing the provided Matrix with each row being on a separate line and in the format '(column0, column1, column2)'.\n */\nMatrix3.prototype.toString = function () {\n  return (\n    \"(\" +\n    this[0] +\n    \", \" +\n    this[3] +\n    \", \" +\n    this[6] +\n    \")\\n\" +\n    \"(\" +\n    this[1] +\n    \", \" +\n    this[4] +\n    \", \" +\n    this[7] +\n    \")\\n\" +\n    \"(\" +\n    this[2] +\n    \", \" +\n    this[5] +\n    \", \" +\n    this[8] +\n    \")\"\n  );\n};\nexport default Matrix3;\n","import Check from \"./Check.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport CesiumMath from \"./Math.js\";\n\n/**\n * A 4D Cartesian point.\n * @alias Cartesian4\n * @constructor\n *\n * @param {Number} [x=0.0] The X component.\n * @param {Number} [y=0.0] The Y component.\n * @param {Number} [z=0.0] The Z component.\n * @param {Number} [w=0.0] The W component.\n *\n * @see Cartesian2\n * @see Cartesian3\n * @see Packable\n */\nfunction Cartesian4(x, y, z, w) {\n  /**\n   * The X component.\n   * @type {Number}\n   * @default 0.0\n   */\n  this.x = defaultValue(x, 0.0);\n\n  /**\n   * The Y component.\n   * @type {Number}\n   * @default 0.0\n   */\n  this.y = defaultValue(y, 0.0);\n\n  /**\n   * The Z component.\n   * @type {Number}\n   * @default 0.0\n   */\n  this.z = defaultValue(z, 0.0);\n\n  /**\n   * The W component.\n   * @type {Number}\n   * @default 0.0\n   */\n  this.w = defaultValue(w, 0.0);\n}\n\n/**\n * Creates a Cartesian4 instance from x, y, z and w coordinates.\n *\n * @param {Number} x The x coordinate.\n * @param {Number} y The y coordinate.\n * @param {Number} z The z coordinate.\n * @param {Number} w The w coordinate.\n * @param {Cartesian4} [result] The object onto which to store the result.\n * @returns {Cartesian4} The modified result parameter or a new Cartesian4 instance if one was not provided.\n */\nCartesian4.fromElements = function (x, y, z, w, result) {\n  if (!defined(result)) {\n    return new Cartesian4(x, y, z, w);\n  }\n\n  result.x = x;\n  result.y = y;\n  result.z = z;\n  result.w = w;\n  return result;\n};\n\n/**\n * Creates a Cartesian4 instance from a {@link Color}. <code>red</code>, <code>green</code>, <code>blue</code>,\n * and <code>alpha</code> map to <code>x</code>, <code>y</code>, <code>z</code>, and <code>w</code>, respectively.\n *\n * @param {Color} color The source color.\n * @param {Cartesian4} [result] The object onto which to store the result.\n * @returns {Cartesian4} The modified result parameter or a new Cartesian4 instance if one was not provided.\n */\nCartesian4.fromColor = function (color, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"color\", color);\n  //>>includeEnd('debug');\n  if (!defined(result)) {\n    return new Cartesian4(color.red, color.green, color.blue, color.alpha);\n  }\n\n  result.x = color.red;\n  result.y = color.green;\n  result.z = color.blue;\n  result.w = color.alpha;\n  return result;\n};\n\n/**\n * Duplicates a Cartesian4 instance.\n *\n * @param {Cartesian4} cartesian The Cartesian to duplicate.\n * @param {Cartesian4} [result] The object onto which to store the result.\n * @returns {Cartesian4} The modified result parameter or a new Cartesian4 instance if one was not provided. (Returns undefined if cartesian is undefined)\n */\nCartesian4.clone = function (cartesian, result) {\n  if (!defined(cartesian)) {\n    return undefined;\n  }\n\n  if (!defined(result)) {\n    return new Cartesian4(cartesian.x, cartesian.y, cartesian.z, cartesian.w);\n  }\n\n  result.x = cartesian.x;\n  result.y = cartesian.y;\n  result.z = cartesian.z;\n  result.w = cartesian.w;\n  return result;\n};\n\n/**\n * The number of elements used to pack the object into an array.\n * @type {Number}\n */\nCartesian4.packedLength = 4;\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {Cartesian4} value The value to pack.\n * @param {Number[]} array The array to pack into.\n * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {Number[]} The array that was packed into\n */\nCartesian4.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"value\", value);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  array[startingIndex++] = value.x;\n  array[startingIndex++] = value.y;\n  array[startingIndex++] = value.z;\n  array[startingIndex] = value.w;\n\n  return array;\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {Number[]} array The packed array.\n * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {Cartesian4} [result] The object into which to store the result.\n * @returns {Cartesian4}  The modified result parameter or a new Cartesian4 instance if one was not provided.\n */\nCartesian4.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  if (!defined(result)) {\n    result = new Cartesian4();\n  }\n  result.x = array[startingIndex++];\n  result.y = array[startingIndex++];\n  result.z = array[startingIndex++];\n  result.w = array[startingIndex];\n  return result;\n};\n\n/**\n     * Flattens an array of Cartesian4s into and array of components.\n     *\n     * @param {Cartesian4[]} array The array of cartesians to pack.\n     * @param {Number[]} [result] The array onto which to store the result. If this is a typed array, it must have array.length * 4 components, else a {@link DeveloperError} will be thrown. If it is a regular array, it will be resized to have (array.length * 4) elements.\n\n     * @returns {Number[]} The packed array.\n     */\nCartesian4.packArray = function (array, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  var length = array.length;\n  var resultLength = length * 4;\n  if (!defined(result)) {\n    result = new Array(resultLength);\n  } else if (!Array.isArray(result) && result.length !== resultLength) {\n    throw new DeveloperError(\n      \"If result is a typed array, it must have exactly array.length * 4 elements\"\n    );\n  } else if (result.length !== resultLength) {\n    result.length = resultLength;\n  }\n\n  for (var i = 0; i < length; ++i) {\n    Cartesian4.pack(array[i], result, i * 4);\n  }\n  return result;\n};\n\n/**\n * Unpacks an array of cartesian components into and array of Cartesian4s.\n *\n * @param {Number[]} array The array of components to unpack.\n * @param {Cartesian4[]} [result] The array onto which to store the result.\n * @returns {Cartesian4[]} The unpacked array.\n */\nCartesian4.unpackArray = function (array, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  Check.typeOf.number.greaterThanOrEquals(\"array.length\", array.length, 4);\n  if (array.length % 4 !== 0) {\n    throw new DeveloperError(\"array length must be a multiple of 4.\");\n  }\n  //>>includeEnd('debug');\n\n  var length = array.length;\n  if (!defined(result)) {\n    result = new Array(length / 4);\n  } else {\n    result.length = length / 4;\n  }\n\n  for (var i = 0; i < length; i += 4) {\n    var index = i / 4;\n    result[index] = Cartesian4.unpack(array, i, result[index]);\n  }\n  return result;\n};\n\n/**\n * Creates a Cartesian4 from four consecutive elements in an array.\n * @function\n *\n * @param {Number[]} array The array whose four consecutive elements correspond to the x, y, z, and w components, respectively.\n * @param {Number} [startingIndex=0] The offset into the array of the first element, which corresponds to the x component.\n * @param {Cartesian4} [result] The object onto which to store the result.\n * @returns {Cartesian4}  The modified result parameter or a new Cartesian4 instance if one was not provided.\n *\n * @example\n * // Create a Cartesian4 with (1.0, 2.0, 3.0, 4.0)\n * var v = [1.0, 2.0, 3.0, 4.0];\n * var p = Cesium.Cartesian4.fromArray(v);\n *\n * // Create a Cartesian4 with (1.0, 2.0, 3.0, 4.0) using an offset into an array\n * var v2 = [0.0, 0.0, 1.0, 2.0, 3.0, 4.0];\n * var p2 = Cesium.Cartesian4.fromArray(v2, 2);\n */\nCartesian4.fromArray = Cartesian4.unpack;\n\n/**\n * Computes the value of the maximum component for the supplied Cartesian.\n *\n * @param {Cartesian4} cartesian The cartesian to use.\n * @returns {Number} The value of the maximum component.\n */\nCartesian4.maximumComponent = function (cartesian) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  //>>includeEnd('debug');\n\n  return Math.max(cartesian.x, cartesian.y, cartesian.z, cartesian.w);\n};\n\n/**\n * Computes the value of the minimum component for the supplied Cartesian.\n *\n * @param {Cartesian4} cartesian The cartesian to use.\n * @returns {Number} The value of the minimum component.\n */\nCartesian4.minimumComponent = function (cartesian) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  //>>includeEnd('debug');\n\n  return Math.min(cartesian.x, cartesian.y, cartesian.z, cartesian.w);\n};\n\n/**\n * Compares two Cartesians and computes a Cartesian which contains the minimum components of the supplied Cartesians.\n *\n * @param {Cartesian4} first A cartesian to compare.\n * @param {Cartesian4} second A cartesian to compare.\n * @param {Cartesian4} result The object into which to store the result.\n * @returns {Cartesian4} A cartesian with the minimum components.\n */\nCartesian4.minimumByComponent = function (first, second, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"first\", first);\n  Check.typeOf.object(\"second\", second);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = Math.min(first.x, second.x);\n  result.y = Math.min(first.y, second.y);\n  result.z = Math.min(first.z, second.z);\n  result.w = Math.min(first.w, second.w);\n\n  return result;\n};\n\n/**\n * Compares two Cartesians and computes a Cartesian which contains the maximum components of the supplied Cartesians.\n *\n * @param {Cartesian4} first A cartesian to compare.\n * @param {Cartesian4} second A cartesian to compare.\n * @param {Cartesian4} result The object into which to store the result.\n * @returns {Cartesian4} A cartesian with the maximum components.\n */\nCartesian4.maximumByComponent = function (first, second, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"first\", first);\n  Check.typeOf.object(\"second\", second);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = Math.max(first.x, second.x);\n  result.y = Math.max(first.y, second.y);\n  result.z = Math.max(first.z, second.z);\n  result.w = Math.max(first.w, second.w);\n\n  return result;\n};\n\n/**\n * Computes the provided Cartesian's squared magnitude.\n *\n * @param {Cartesian4} cartesian The Cartesian instance whose squared magnitude is to be computed.\n * @returns {Number} The squared magnitude.\n */\nCartesian4.magnitudeSquared = function (cartesian) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  //>>includeEnd('debug');\n\n  return (\n    cartesian.x * cartesian.x +\n    cartesian.y * cartesian.y +\n    cartesian.z * cartesian.z +\n    cartesian.w * cartesian.w\n  );\n};\n\n/**\n * Computes the Cartesian's magnitude (length).\n *\n * @param {Cartesian4} cartesian The Cartesian instance whose magnitude is to be computed.\n * @returns {Number} The magnitude.\n */\nCartesian4.magnitude = function (cartesian) {\n  return Math.sqrt(Cartesian4.magnitudeSquared(cartesian));\n};\n\nvar distanceScratch = new Cartesian4();\n\n/**\n * Computes the 4-space distance between two points.\n *\n * @param {Cartesian4} left The first point to compute the distance from.\n * @param {Cartesian4} right The second point to compute the distance to.\n * @returns {Number} The distance between two points.\n *\n * @example\n * // Returns 1.0\n * var d = Cesium.Cartesian4.distance(\n *   new Cesium.Cartesian4(1.0, 0.0, 0.0, 0.0),\n *   new Cesium.Cartesian4(2.0, 0.0, 0.0, 0.0));\n */\nCartesian4.distance = function (left, right) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  //>>includeEnd('debug');\n\n  Cartesian4.subtract(left, right, distanceScratch);\n  return Cartesian4.magnitude(distanceScratch);\n};\n\n/**\n * Computes the squared distance between two points.  Comparing squared distances\n * using this function is more efficient than comparing distances using {@link Cartesian4#distance}.\n *\n * @param {Cartesian4} left The first point to compute the distance from.\n * @param {Cartesian4} right The second point to compute the distance to.\n * @returns {Number} The distance between two points.\n *\n * @example\n * // Returns 4.0, not 2.0\n * var d = Cesium.Cartesian4.distance(\n *   new Cesium.Cartesian4(1.0, 0.0, 0.0, 0.0),\n *   new Cesium.Cartesian4(3.0, 0.0, 0.0, 0.0));\n */\nCartesian4.distanceSquared = function (left, right) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  //>>includeEnd('debug');\n\n  Cartesian4.subtract(left, right, distanceScratch);\n  return Cartesian4.magnitudeSquared(distanceScratch);\n};\n\n/**\n * Computes the normalized form of the supplied Cartesian.\n *\n * @param {Cartesian4} cartesian The Cartesian to be normalized.\n * @param {Cartesian4} result The object onto which to store the result.\n * @returns {Cartesian4} The modified result parameter.\n */\nCartesian4.normalize = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  var magnitude = Cartesian4.magnitude(cartesian);\n\n  result.x = cartesian.x / magnitude;\n  result.y = cartesian.y / magnitude;\n  result.z = cartesian.z / magnitude;\n  result.w = cartesian.w / magnitude;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (\n    isNaN(result.x) ||\n    isNaN(result.y) ||\n    isNaN(result.z) ||\n    isNaN(result.w)\n  ) {\n    throw new DeveloperError(\"normalized result is not a number\");\n  }\n  //>>includeEnd('debug');\n\n  return result;\n};\n\n/**\n * Computes the dot (scalar) product of two Cartesians.\n *\n * @param {Cartesian4} left The first Cartesian.\n * @param {Cartesian4} right The second Cartesian.\n * @returns {Number} The dot product.\n */\nCartesian4.dot = function (left, right) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  //>>includeEnd('debug');\n\n  return (\n    left.x * right.x + left.y * right.y + left.z * right.z + left.w * right.w\n  );\n};\n\n/**\n * Computes the componentwise product of two Cartesians.\n *\n * @param {Cartesian4} left The first Cartesian.\n * @param {Cartesian4} right The second Cartesian.\n * @param {Cartesian4} result The object onto which to store the result.\n * @returns {Cartesian4} The modified result parameter.\n */\nCartesian4.multiplyComponents = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = left.x * right.x;\n  result.y = left.y * right.y;\n  result.z = left.z * right.z;\n  result.w = left.w * right.w;\n  return result;\n};\n\n/**\n * Computes the componentwise quotient of two Cartesians.\n *\n * @param {Cartesian4} left The first Cartesian.\n * @param {Cartesian4} right The second Cartesian.\n * @param {Cartesian4} result The object onto which to store the result.\n * @returns {Cartesian4} The modified result parameter.\n */\nCartesian4.divideComponents = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = left.x / right.x;\n  result.y = left.y / right.y;\n  result.z = left.z / right.z;\n  result.w = left.w / right.w;\n  return result;\n};\n\n/**\n * Computes the componentwise sum of two Cartesians.\n *\n * @param {Cartesian4} left The first Cartesian.\n * @param {Cartesian4} right The second Cartesian.\n * @param {Cartesian4} result The object onto which to store the result.\n * @returns {Cartesian4} The modified result parameter.\n */\nCartesian4.add = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = left.x + right.x;\n  result.y = left.y + right.y;\n  result.z = left.z + right.z;\n  result.w = left.w + right.w;\n  return result;\n};\n\n/**\n * Computes the componentwise difference of two Cartesians.\n *\n * @param {Cartesian4} left The first Cartesian.\n * @param {Cartesian4} right The second Cartesian.\n * @param {Cartesian4} result The object onto which to store the result.\n * @returns {Cartesian4} The modified result parameter.\n */\nCartesian4.subtract = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = left.x - right.x;\n  result.y = left.y - right.y;\n  result.z = left.z - right.z;\n  result.w = left.w - right.w;\n  return result;\n};\n\n/**\n * Multiplies the provided Cartesian componentwise by the provided scalar.\n *\n * @param {Cartesian4} cartesian The Cartesian to be scaled.\n * @param {Number} scalar The scalar to multiply with.\n * @param {Cartesian4} result The object onto which to store the result.\n * @returns {Cartesian4} The modified result parameter.\n */\nCartesian4.multiplyByScalar = function (cartesian, scalar, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.number(\"scalar\", scalar);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = cartesian.x * scalar;\n  result.y = cartesian.y * scalar;\n  result.z = cartesian.z * scalar;\n  result.w = cartesian.w * scalar;\n  return result;\n};\n\n/**\n * Divides the provided Cartesian componentwise by the provided scalar.\n *\n * @param {Cartesian4} cartesian The Cartesian to be divided.\n * @param {Number} scalar The scalar to divide by.\n * @param {Cartesian4} result The object onto which to store the result.\n * @returns {Cartesian4} The modified result parameter.\n */\nCartesian4.divideByScalar = function (cartesian, scalar, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.number(\"scalar\", scalar);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = cartesian.x / scalar;\n  result.y = cartesian.y / scalar;\n  result.z = cartesian.z / scalar;\n  result.w = cartesian.w / scalar;\n  return result;\n};\n\n/**\n * Negates the provided Cartesian.\n *\n * @param {Cartesian4} cartesian The Cartesian to be negated.\n * @param {Cartesian4} result The object onto which to store the result.\n * @returns {Cartesian4} The modified result parameter.\n */\nCartesian4.negate = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = -cartesian.x;\n  result.y = -cartesian.y;\n  result.z = -cartesian.z;\n  result.w = -cartesian.w;\n  return result;\n};\n\n/**\n * Computes the absolute value of the provided Cartesian.\n *\n * @param {Cartesian4} cartesian The Cartesian whose absolute value is to be computed.\n * @param {Cartesian4} result The object onto which to store the result.\n * @returns {Cartesian4} The modified result parameter.\n */\nCartesian4.abs = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = Math.abs(cartesian.x);\n  result.y = Math.abs(cartesian.y);\n  result.z = Math.abs(cartesian.z);\n  result.w = Math.abs(cartesian.w);\n  return result;\n};\n\nvar lerpScratch = new Cartesian4();\n/**\n * Computes the linear interpolation or extrapolation at t using the provided cartesians.\n *\n * @param {Cartesian4} start The value corresponding to t at 0.0.\n * @param {Cartesian4}end The value corresponding to t at 1.0.\n * @param {Number} t The point along t at which to interpolate.\n * @param {Cartesian4} result The object onto which to store the result.\n * @returns {Cartesian4} The modified result parameter.\n */\nCartesian4.lerp = function (start, end, t, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"start\", start);\n  Check.typeOf.object(\"end\", end);\n  Check.typeOf.number(\"t\", t);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  Cartesian4.multiplyByScalar(end, t, lerpScratch);\n  result = Cartesian4.multiplyByScalar(start, 1.0 - t, result);\n  return Cartesian4.add(lerpScratch, result, result);\n};\n\nvar mostOrthogonalAxisScratch = new Cartesian4();\n/**\n * Returns the axis that is most orthogonal to the provided Cartesian.\n *\n * @param {Cartesian4} cartesian The Cartesian on which to find the most orthogonal axis.\n * @param {Cartesian4} result The object onto which to store the result.\n * @returns {Cartesian4} The most orthogonal axis.\n */\nCartesian4.mostOrthogonalAxis = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  var f = Cartesian4.normalize(cartesian, mostOrthogonalAxisScratch);\n  Cartesian4.abs(f, f);\n\n  if (f.x <= f.y) {\n    if (f.x <= f.z) {\n      if (f.x <= f.w) {\n        result = Cartesian4.clone(Cartesian4.UNIT_X, result);\n      } else {\n        result = Cartesian4.clone(Cartesian4.UNIT_W, result);\n      }\n    } else if (f.z <= f.w) {\n      result = Cartesian4.clone(Cartesian4.UNIT_Z, result);\n    } else {\n      result = Cartesian4.clone(Cartesian4.UNIT_W, result);\n    }\n  } else if (f.y <= f.z) {\n    if (f.y <= f.w) {\n      result = Cartesian4.clone(Cartesian4.UNIT_Y, result);\n    } else {\n      result = Cartesian4.clone(Cartesian4.UNIT_W, result);\n    }\n  } else if (f.z <= f.w) {\n    result = Cartesian4.clone(Cartesian4.UNIT_Z, result);\n  } else {\n    result = Cartesian4.clone(Cartesian4.UNIT_W, result);\n  }\n\n  return result;\n};\n\n/**\n * Compares the provided Cartesians componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {Cartesian4} [left] The first Cartesian.\n * @param {Cartesian4} [right] The second Cartesian.\n * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n */\nCartesian4.equals = function (left, right) {\n  return (\n    left === right ||\n    (defined(left) &&\n      defined(right) &&\n      left.x === right.x &&\n      left.y === right.y &&\n      left.z === right.z &&\n      left.w === right.w)\n  );\n};\n\n/**\n * @private\n */\nCartesian4.equalsArray = function (cartesian, array, offset) {\n  return (\n    cartesian.x === array[offset] &&\n    cartesian.y === array[offset + 1] &&\n    cartesian.z === array[offset + 2] &&\n    cartesian.w === array[offset + 3]\n  );\n};\n\n/**\n * Compares the provided Cartesians componentwise and returns\n * <code>true</code> if they pass an absolute or relative tolerance test,\n * <code>false</code> otherwise.\n *\n * @param {Cartesian4} [left] The first Cartesian.\n * @param {Cartesian4} [right] The second Cartesian.\n * @param {Number} [relativeEpsilon=0] The relative epsilon tolerance to use for equality testing.\n * @param {Number} [absoluteEpsilon=relativeEpsilon] The absolute epsilon tolerance to use for equality testing.\n * @returns {Boolean} <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.\n */\nCartesian4.equalsEpsilon = function (\n  left,\n  right,\n  relativeEpsilon,\n  absoluteEpsilon\n) {\n  return (\n    left === right ||\n    (defined(left) &&\n      defined(right) &&\n      CesiumMath.equalsEpsilon(\n        left.x,\n        right.x,\n        relativeEpsilon,\n        absoluteEpsilon\n      ) &&\n      CesiumMath.equalsEpsilon(\n        left.y,\n        right.y,\n        relativeEpsilon,\n        absoluteEpsilon\n      ) &&\n      CesiumMath.equalsEpsilon(\n        left.z,\n        right.z,\n        relativeEpsilon,\n        absoluteEpsilon\n      ) &&\n      CesiumMath.equalsEpsilon(\n        left.w,\n        right.w,\n        relativeEpsilon,\n        absoluteEpsilon\n      ))\n  );\n};\n\n/**\n * An immutable Cartesian4 instance initialized to (0.0, 0.0, 0.0, 0.0).\n *\n * @type {Cartesian4}\n * @constant\n */\nCartesian4.ZERO = Object.freeze(new Cartesian4(0.0, 0.0, 0.0, 0.0));\n\n/**\n * An immutable Cartesian4 instance initialized to (1.0, 1.0, 1.0, 1.0).\n *\n * @type {Cartesian4}\n * @constant\n */\nCartesian4.ONE = Object.freeze(new Cartesian4(1.0, 1.0, 1.0, 1.0));\n\n/**\n * An immutable Cartesian4 instance initialized to (1.0, 0.0, 0.0, 0.0).\n *\n * @type {Cartesian4}\n * @constant\n */\nCartesian4.UNIT_X = Object.freeze(new Cartesian4(1.0, 0.0, 0.0, 0.0));\n\n/**\n * An immutable Cartesian4 instance initialized to (0.0, 1.0, 0.0, 0.0).\n *\n * @type {Cartesian4}\n * @constant\n */\nCartesian4.UNIT_Y = Object.freeze(new Cartesian4(0.0, 1.0, 0.0, 0.0));\n\n/**\n * An immutable Cartesian4 instance initialized to (0.0, 0.0, 1.0, 0.0).\n *\n * @type {Cartesian4}\n * @constant\n */\nCartesian4.UNIT_Z = Object.freeze(new Cartesian4(0.0, 0.0, 1.0, 0.0));\n\n/**\n * An immutable Cartesian4 instance initialized to (0.0, 0.0, 0.0, 1.0).\n *\n * @type {Cartesian4}\n * @constant\n */\nCartesian4.UNIT_W = Object.freeze(new Cartesian4(0.0, 0.0, 0.0, 1.0));\n\n/**\n * Duplicates this Cartesian4 instance.\n *\n * @param {Cartesian4} [result] The object onto which to store the result.\n * @returns {Cartesian4} The modified result parameter or a new Cartesian4 instance if one was not provided.\n */\nCartesian4.prototype.clone = function (result) {\n  return Cartesian4.clone(this, result);\n};\n\n/**\n * Compares this Cartesian against the provided Cartesian componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {Cartesian4} [right] The right hand side Cartesian.\n * @returns {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.\n */\nCartesian4.prototype.equals = function (right) {\n  return Cartesian4.equals(this, right);\n};\n\n/**\n * Compares this Cartesian against the provided Cartesian componentwise and returns\n * <code>true</code> if they pass an absolute or relative tolerance test,\n * <code>false</code> otherwise.\n *\n * @param {Cartesian4} [right] The right hand side Cartesian.\n * @param {Number} [relativeEpsilon=0] The relative epsilon tolerance to use for equality testing.\n * @param {Number} [absoluteEpsilon=relativeEpsilon] The absolute epsilon tolerance to use for equality testing.\n * @returns {Boolean} <code>true</code> if they are within the provided epsilon, <code>false</code> otherwise.\n */\nCartesian4.prototype.equalsEpsilon = function (\n  right,\n  relativeEpsilon,\n  absoluteEpsilon\n) {\n  return Cartesian4.equalsEpsilon(\n    this,\n    right,\n    relativeEpsilon,\n    absoluteEpsilon\n  );\n};\n\n/**\n * Creates a string representing this Cartesian in the format '(x, y, z, w)'.\n *\n * @returns {String} A string representing the provided Cartesian in the format '(x, y, z, w)'.\n */\nCartesian4.prototype.toString = function () {\n  return \"(\" + this.x + \", \" + this.y + \", \" + this.z + \", \" + this.w + \")\";\n};\n\n// scratchU8Array and scratchF32Array are views into the same buffer\nvar scratchF32Array = new Float32Array(1);\nvar scratchU8Array = new Uint8Array(scratchF32Array.buffer);\n\nvar testU32 = new Uint32Array([0x11223344]);\nvar testU8 = new Uint8Array(testU32.buffer);\nvar littleEndian = testU8[0] === 0x44;\n\n/**\n * Packs an arbitrary floating point value to 4 values representable using uint8.\n *\n * @param {Number} value A floating point number.\n * @param {Cartesian4} [result] The Cartesian4 that will contain the packed float.\n * @returns {Cartesian4} A Cartesian4 representing the float packed to values in x, y, z, and w.\n */\nCartesian4.packFloat = function (value, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"value\", value);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Cartesian4();\n  }\n\n  // scratchU8Array and scratchF32Array are views into the same buffer\n  scratchF32Array[0] = value;\n\n  if (littleEndian) {\n    result.x = scratchU8Array[0];\n    result.y = scratchU8Array[1];\n    result.z = scratchU8Array[2];\n    result.w = scratchU8Array[3];\n  } else {\n    // convert from big-endian to little-endian\n    result.x = scratchU8Array[3];\n    result.y = scratchU8Array[2];\n    result.z = scratchU8Array[1];\n    result.w = scratchU8Array[0];\n  }\n  return result;\n};\n\n/**\n * Unpacks a float packed using Cartesian4.packFloat.\n *\n * @param {Cartesian4} packedFloat A Cartesian4 containing a float packed to 4 values representable using uint8.\n * @returns {Number} The unpacked float.\n * @private\n */\nCartesian4.unpackFloat = function (packedFloat) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"packedFloat\", packedFloat);\n  //>>includeEnd('debug');\n\n  // scratchU8Array and scratchF32Array are views into the same buffer\n  if (littleEndian) {\n    scratchU8Array[0] = packedFloat.x;\n    scratchU8Array[1] = packedFloat.y;\n    scratchU8Array[2] = packedFloat.z;\n    scratchU8Array[3] = packedFloat.w;\n  } else {\n    // convert from little-endian to big-endian\n    scratchU8Array[0] = packedFloat.w;\n    scratchU8Array[1] = packedFloat.z;\n    scratchU8Array[2] = packedFloat.y;\n    scratchU8Array[3] = packedFloat.x;\n  }\n  return scratchF32Array[0];\n};\nexport default Cartesian4;\n","import Cartesian3 from \"./Cartesian3.js\";\nimport Cartesian4 from \"./Cartesian4.js\";\nimport Check from \"./Check.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport CesiumMath from \"./Math.js\";\nimport Matrix3 from \"./Matrix3.js\";\nimport RuntimeError from \"./RuntimeError.js\";\n\n/**\n * A 4x4 matrix, indexable as a column-major order array.\n * Constructor parameters are in row-major order for code readability.\n * @alias Matrix4\n * @constructor\n * @implements {ArrayLike<number>}\n *\n * @param {Number} [column0Row0=0.0] The value for column 0, row 0.\n * @param {Number} [column1Row0=0.0] The value for column 1, row 0.\n * @param {Number} [column2Row0=0.0] The value for column 2, row 0.\n * @param {Number} [column3Row0=0.0] The value for column 3, row 0.\n * @param {Number} [column0Row1=0.0] The value for column 0, row 1.\n * @param {Number} [column1Row1=0.0] The value for column 1, row 1.\n * @param {Number} [column2Row1=0.0] The value for column 2, row 1.\n * @param {Number} [column3Row1=0.0] The value for column 3, row 1.\n * @param {Number} [column0Row2=0.0] The value for column 0, row 2.\n * @param {Number} [column1Row2=0.0] The value for column 1, row 2.\n * @param {Number} [column2Row2=0.0] The value for column 2, row 2.\n * @param {Number} [column3Row2=0.0] The value for column 3, row 2.\n * @param {Number} [column0Row3=0.0] The value for column 0, row 3.\n * @param {Number} [column1Row3=0.0] The value for column 1, row 3.\n * @param {Number} [column2Row3=0.0] The value for column 2, row 3.\n * @param {Number} [column3Row3=0.0] The value for column 3, row 3.\n *\n * @see Matrix4.fromColumnMajorArray\n * @see Matrix4.fromRowMajorArray\n * @see Matrix4.fromRotationTranslation\n * @see Matrix4.fromTranslationRotationScale\n * @see Matrix4.fromTranslationQuaternionRotationScale\n * @see Matrix4.fromTranslation\n * @see Matrix4.fromScale\n * @see Matrix4.fromUniformScale\n * @see Matrix4.fromCamera\n * @see Matrix4.computePerspectiveFieldOfView\n * @see Matrix4.computeOrthographicOffCenter\n * @see Matrix4.computePerspectiveOffCenter\n * @see Matrix4.computeInfinitePerspectiveOffCenter\n * @see Matrix4.computeViewportTransformation\n * @see Matrix4.computeView\n * @see Matrix2\n * @see Matrix3\n * @see Packable\n */\nfunction Matrix4(\n  column0Row0,\n  column1Row0,\n  column2Row0,\n  column3Row0,\n  column0Row1,\n  column1Row1,\n  column2Row1,\n  column3Row1,\n  column0Row2,\n  column1Row2,\n  column2Row2,\n  column3Row2,\n  column0Row3,\n  column1Row3,\n  column2Row3,\n  column3Row3\n) {\n  this[0] = defaultValue(column0Row0, 0.0);\n  this[1] = defaultValue(column0Row1, 0.0);\n  this[2] = defaultValue(column0Row2, 0.0);\n  this[3] = defaultValue(column0Row3, 0.0);\n  this[4] = defaultValue(column1Row0, 0.0);\n  this[5] = defaultValue(column1Row1, 0.0);\n  this[6] = defaultValue(column1Row2, 0.0);\n  this[7] = defaultValue(column1Row3, 0.0);\n  this[8] = defaultValue(column2Row0, 0.0);\n  this[9] = defaultValue(column2Row1, 0.0);\n  this[10] = defaultValue(column2Row2, 0.0);\n  this[11] = defaultValue(column2Row3, 0.0);\n  this[12] = defaultValue(column3Row0, 0.0);\n  this[13] = defaultValue(column3Row1, 0.0);\n  this[14] = defaultValue(column3Row2, 0.0);\n  this[15] = defaultValue(column3Row3, 0.0);\n}\n\n/**\n * The number of elements used to pack the object into an array.\n * @type {Number}\n */\nMatrix4.packedLength = 16;\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {Matrix4} value The value to pack.\n * @param {Number[]} array The array to pack into.\n * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {Number[]} The array that was packed into\n */\nMatrix4.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"value\", value);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  array[startingIndex++] = value[0];\n  array[startingIndex++] = value[1];\n  array[startingIndex++] = value[2];\n  array[startingIndex++] = value[3];\n  array[startingIndex++] = value[4];\n  array[startingIndex++] = value[5];\n  array[startingIndex++] = value[6];\n  array[startingIndex++] = value[7];\n  array[startingIndex++] = value[8];\n  array[startingIndex++] = value[9];\n  array[startingIndex++] = value[10];\n  array[startingIndex++] = value[11];\n  array[startingIndex++] = value[12];\n  array[startingIndex++] = value[13];\n  array[startingIndex++] = value[14];\n  array[startingIndex] = value[15];\n\n  return array;\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {Number[]} array The packed array.\n * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {Matrix4} [result] The object into which to store the result.\n * @returns {Matrix4} The modified result parameter or a new Matrix4 instance if one was not provided.\n */\nMatrix4.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  if (!defined(result)) {\n    result = new Matrix4();\n  }\n\n  result[0] = array[startingIndex++];\n  result[1] = array[startingIndex++];\n  result[2] = array[startingIndex++];\n  result[3] = array[startingIndex++];\n  result[4] = array[startingIndex++];\n  result[5] = array[startingIndex++];\n  result[6] = array[startingIndex++];\n  result[7] = array[startingIndex++];\n  result[8] = array[startingIndex++];\n  result[9] = array[startingIndex++];\n  result[10] = array[startingIndex++];\n  result[11] = array[startingIndex++];\n  result[12] = array[startingIndex++];\n  result[13] = array[startingIndex++];\n  result[14] = array[startingIndex++];\n  result[15] = array[startingIndex];\n  return result;\n};\n\n/**\n * Duplicates a Matrix4 instance.\n *\n * @param {Matrix4} matrix The matrix to duplicate.\n * @param {Matrix4} [result] The object onto which to store the result.\n * @returns {Matrix4} The modified result parameter or a new Matrix4 instance if one was not provided. (Returns undefined if matrix is undefined)\n */\nMatrix4.clone = function (matrix, result) {\n  if (!defined(matrix)) {\n    return undefined;\n  }\n  if (!defined(result)) {\n    return new Matrix4(\n      matrix[0],\n      matrix[4],\n      matrix[8],\n      matrix[12],\n      matrix[1],\n      matrix[5],\n      matrix[9],\n      matrix[13],\n      matrix[2],\n      matrix[6],\n      matrix[10],\n      matrix[14],\n      matrix[3],\n      matrix[7],\n      matrix[11],\n      matrix[15]\n    );\n  }\n  result[0] = matrix[0];\n  result[1] = matrix[1];\n  result[2] = matrix[2];\n  result[3] = matrix[3];\n  result[4] = matrix[4];\n  result[5] = matrix[5];\n  result[6] = matrix[6];\n  result[7] = matrix[7];\n  result[8] = matrix[8];\n  result[9] = matrix[9];\n  result[10] = matrix[10];\n  result[11] = matrix[11];\n  result[12] = matrix[12];\n  result[13] = matrix[13];\n  result[14] = matrix[14];\n  result[15] = matrix[15];\n  return result;\n};\n\n/**\n * Creates a Matrix4 from 16 consecutive elements in an array.\n * @function\n *\n * @param {Number[]} array The array whose 16 consecutive elements correspond to the positions of the matrix.  Assumes column-major order.\n * @param {Number} [startingIndex=0] The offset into the array of the first element, which corresponds to first column first row position in the matrix.\n * @param {Matrix4} [result] The object onto which to store the result.\n * @returns {Matrix4} The modified result parameter or a new Matrix4 instance if one was not provided.\n *\n * @example\n * // Create the Matrix4:\n * // [1.0, 2.0, 3.0, 4.0]\n * // [1.0, 2.0, 3.0, 4.0]\n * // [1.0, 2.0, 3.0, 4.0]\n * // [1.0, 2.0, 3.0, 4.0]\n *\n * var v = [1.0, 1.0, 1.0, 1.0, 2.0, 2.0, 2.0, 2.0, 3.0, 3.0, 3.0, 3.0, 4.0, 4.0, 4.0, 4.0];\n * var m = Cesium.Matrix4.fromArray(v);\n *\n * // Create same Matrix4 with using an offset into an array\n * var v2 = [0.0, 0.0, 1.0, 1.0, 1.0, 1.0, 2.0, 2.0, 2.0, 2.0, 3.0, 3.0, 3.0, 3.0, 4.0, 4.0, 4.0, 4.0];\n * var m2 = Cesium.Matrix4.fromArray(v2, 2);\n */\nMatrix4.fromArray = Matrix4.unpack;\n\n/**\n * Computes a Matrix4 instance from a column-major order array.\n *\n * @param {Number[]} values The column-major order array.\n * @param {Matrix4} [result] The object in which the result will be stored, if undefined a new instance will be created.\n * @returns {Matrix4} The modified result parameter, or a new Matrix4 instance if one was not provided.\n */\nMatrix4.fromColumnMajorArray = function (values, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"values\", values);\n  //>>includeEnd('debug');\n\n  return Matrix4.clone(values, result);\n};\n\n/**\n * Computes a Matrix4 instance from a row-major order array.\n * The resulting matrix will be in column-major order.\n *\n * @param {Number[]} values The row-major order array.\n * @param {Matrix4} [result] The object in which the result will be stored, if undefined a new instance will be created.\n * @returns {Matrix4} The modified result parameter, or a new Matrix4 instance if one was not provided.\n */\nMatrix4.fromRowMajorArray = function (values, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"values\", values);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    return new Matrix4(\n      values[0],\n      values[1],\n      values[2],\n      values[3],\n      values[4],\n      values[5],\n      values[6],\n      values[7],\n      values[8],\n      values[9],\n      values[10],\n      values[11],\n      values[12],\n      values[13],\n      values[14],\n      values[15]\n    );\n  }\n  result[0] = values[0];\n  result[1] = values[4];\n  result[2] = values[8];\n  result[3] = values[12];\n  result[4] = values[1];\n  result[5] = values[5];\n  result[6] = values[9];\n  result[7] = values[13];\n  result[8] = values[2];\n  result[9] = values[6];\n  result[10] = values[10];\n  result[11] = values[14];\n  result[12] = values[3];\n  result[13] = values[7];\n  result[14] = values[11];\n  result[15] = values[15];\n  return result;\n};\n\n/**\n * Computes a Matrix4 instance from a Matrix3 representing the rotation\n * and a Cartesian3 representing the translation.\n *\n * @param {Matrix3} rotation The upper left portion of the matrix representing the rotation.\n * @param {Cartesian3} [translation=Cartesian3.ZERO] The upper right portion of the matrix representing the translation.\n * @param {Matrix4} [result] The object in which the result will be stored, if undefined a new instance will be created.\n * @returns {Matrix4} The modified result parameter, or a new Matrix4 instance if one was not provided.\n */\nMatrix4.fromRotationTranslation = function (rotation, translation, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"rotation\", rotation);\n  //>>includeEnd('debug');\n\n  translation = defaultValue(translation, Cartesian3.ZERO);\n\n  if (!defined(result)) {\n    return new Matrix4(\n      rotation[0],\n      rotation[3],\n      rotation[6],\n      translation.x,\n      rotation[1],\n      rotation[4],\n      rotation[7],\n      translation.y,\n      rotation[2],\n      rotation[5],\n      rotation[8],\n      translation.z,\n      0.0,\n      0.0,\n      0.0,\n      1.0\n    );\n  }\n\n  result[0] = rotation[0];\n  result[1] = rotation[1];\n  result[2] = rotation[2];\n  result[3] = 0.0;\n  result[4] = rotation[3];\n  result[5] = rotation[4];\n  result[6] = rotation[5];\n  result[7] = 0.0;\n  result[8] = rotation[6];\n  result[9] = rotation[7];\n  result[10] = rotation[8];\n  result[11] = 0.0;\n  result[12] = translation.x;\n  result[13] = translation.y;\n  result[14] = translation.z;\n  result[15] = 1.0;\n  return result;\n};\n\n/**\n * Computes a Matrix4 instance from a translation, rotation, and scale (TRS)\n * representation with the rotation represented as a quaternion.\n *\n * @param {Cartesian3} translation The translation transformation.\n * @param {Quaternion} rotation The rotation transformation.\n * @param {Cartesian3} scale The non-uniform scale transformation.\n * @param {Matrix4} [result] The object in which the result will be stored, if undefined a new instance will be created.\n * @returns {Matrix4} The modified result parameter, or a new Matrix4 instance if one was not provided.\n *\n * @example\n * var result = Cesium.Matrix4.fromTranslationQuaternionRotationScale(\n *   new Cesium.Cartesian3(1.0, 2.0, 3.0), // translation\n *   Cesium.Quaternion.IDENTITY,           // rotation\n *   new Cesium.Cartesian3(7.0, 8.0, 9.0), // scale\n *   result);\n */\nMatrix4.fromTranslationQuaternionRotationScale = function (\n  translation,\n  rotation,\n  scale,\n  result\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"translation\", translation);\n  Check.typeOf.object(\"rotation\", rotation);\n  Check.typeOf.object(\"scale\", scale);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Matrix4();\n  }\n\n  var scaleX = scale.x;\n  var scaleY = scale.y;\n  var scaleZ = scale.z;\n\n  var x2 = rotation.x * rotation.x;\n  var xy = rotation.x * rotation.y;\n  var xz = rotation.x * rotation.z;\n  var xw = rotation.x * rotation.w;\n  var y2 = rotation.y * rotation.y;\n  var yz = rotation.y * rotation.z;\n  var yw = rotation.y * rotation.w;\n  var z2 = rotation.z * rotation.z;\n  var zw = rotation.z * rotation.w;\n  var w2 = rotation.w * rotation.w;\n\n  var m00 = x2 - y2 - z2 + w2;\n  var m01 = 2.0 * (xy - zw);\n  var m02 = 2.0 * (xz + yw);\n\n  var m10 = 2.0 * (xy + zw);\n  var m11 = -x2 + y2 - z2 + w2;\n  var m12 = 2.0 * (yz - xw);\n\n  var m20 = 2.0 * (xz - yw);\n  var m21 = 2.0 * (yz + xw);\n  var m22 = -x2 - y2 + z2 + w2;\n\n  result[0] = m00 * scaleX;\n  result[1] = m10 * scaleX;\n  result[2] = m20 * scaleX;\n  result[3] = 0.0;\n  result[4] = m01 * scaleY;\n  result[5] = m11 * scaleY;\n  result[6] = m21 * scaleY;\n  result[7] = 0.0;\n  result[8] = m02 * scaleZ;\n  result[9] = m12 * scaleZ;\n  result[10] = m22 * scaleZ;\n  result[11] = 0.0;\n  result[12] = translation.x;\n  result[13] = translation.y;\n  result[14] = translation.z;\n  result[15] = 1.0;\n\n  return result;\n};\n\n/**\n * Creates a Matrix4 instance from a {@link TranslationRotationScale} instance.\n *\n * @param {TranslationRotationScale} translationRotationScale The instance.\n * @param {Matrix4} [result] The object in which the result will be stored, if undefined a new instance will be created.\n * @returns {Matrix4} The modified result parameter, or a new Matrix4 instance if one was not provided.\n */\nMatrix4.fromTranslationRotationScale = function (\n  translationRotationScale,\n  result\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"translationRotationScale\", translationRotationScale);\n  //>>includeEnd('debug');\n\n  return Matrix4.fromTranslationQuaternionRotationScale(\n    translationRotationScale.translation,\n    translationRotationScale.rotation,\n    translationRotationScale.scale,\n    result\n  );\n};\n\n/**\n * Creates a Matrix4 instance from a Cartesian3 representing the translation.\n *\n * @param {Cartesian3} translation The upper right portion of the matrix representing the translation.\n * @param {Matrix4} [result] The object in which the result will be stored, if undefined a new instance will be created.\n * @returns {Matrix4} The modified result parameter, or a new Matrix4 instance if one was not provided.\n *\n * @see Matrix4.multiplyByTranslation\n */\nMatrix4.fromTranslation = function (translation, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"translation\", translation);\n  //>>includeEnd('debug');\n\n  return Matrix4.fromRotationTranslation(Matrix3.IDENTITY, translation, result);\n};\n\n/**\n * Computes a Matrix4 instance representing a non-uniform scale.\n *\n * @param {Cartesian3} scale The x, y, and z scale factors.\n * @param {Matrix4} [result] The object in which the result will be stored, if undefined a new instance will be created.\n * @returns {Matrix4} The modified result parameter, or a new Matrix4 instance if one was not provided.\n *\n * @example\n * // Creates\n * //   [7.0, 0.0, 0.0, 0.0]\n * //   [0.0, 8.0, 0.0, 0.0]\n * //   [0.0, 0.0, 9.0, 0.0]\n * //   [0.0, 0.0, 0.0, 1.0]\n * var m = Cesium.Matrix4.fromScale(new Cesium.Cartesian3(7.0, 8.0, 9.0));\n */\nMatrix4.fromScale = function (scale, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"scale\", scale);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    return new Matrix4(\n      scale.x,\n      0.0,\n      0.0,\n      0.0,\n      0.0,\n      scale.y,\n      0.0,\n      0.0,\n      0.0,\n      0.0,\n      scale.z,\n      0.0,\n      0.0,\n      0.0,\n      0.0,\n      1.0\n    );\n  }\n\n  result[0] = scale.x;\n  result[1] = 0.0;\n  result[2] = 0.0;\n  result[3] = 0.0;\n  result[4] = 0.0;\n  result[5] = scale.y;\n  result[6] = 0.0;\n  result[7] = 0.0;\n  result[8] = 0.0;\n  result[9] = 0.0;\n  result[10] = scale.z;\n  result[11] = 0.0;\n  result[12] = 0.0;\n  result[13] = 0.0;\n  result[14] = 0.0;\n  result[15] = 1.0;\n  return result;\n};\n\n/**\n * Computes a Matrix4 instance representing a uniform scale.\n *\n * @param {Number} scale The uniform scale factor.\n * @param {Matrix4} [result] The object in which the result will be stored, if undefined a new instance will be created.\n * @returns {Matrix4} The modified result parameter, or a new Matrix4 instance if one was not provided.\n *\n * @example\n * // Creates\n * //   [2.0, 0.0, 0.0, 0.0]\n * //   [0.0, 2.0, 0.0, 0.0]\n * //   [0.0, 0.0, 2.0, 0.0]\n * //   [0.0, 0.0, 0.0, 1.0]\n * var m = Cesium.Matrix4.fromUniformScale(2.0);\n */\nMatrix4.fromUniformScale = function (scale, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"scale\", scale);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    return new Matrix4(\n      scale,\n      0.0,\n      0.0,\n      0.0,\n      0.0,\n      scale,\n      0.0,\n      0.0,\n      0.0,\n      0.0,\n      scale,\n      0.0,\n      0.0,\n      0.0,\n      0.0,\n      1.0\n    );\n  }\n\n  result[0] = scale;\n  result[1] = 0.0;\n  result[2] = 0.0;\n  result[3] = 0.0;\n  result[4] = 0.0;\n  result[5] = scale;\n  result[6] = 0.0;\n  result[7] = 0.0;\n  result[8] = 0.0;\n  result[9] = 0.0;\n  result[10] = scale;\n  result[11] = 0.0;\n  result[12] = 0.0;\n  result[13] = 0.0;\n  result[14] = 0.0;\n  result[15] = 1.0;\n  return result;\n};\n\nvar fromCameraF = new Cartesian3();\nvar fromCameraR = new Cartesian3();\nvar fromCameraU = new Cartesian3();\n\n/**\n * Computes a Matrix4 instance from a Camera.\n *\n * @param {Camera} camera The camera to use.\n * @param {Matrix4} [result] The object in which the result will be stored, if undefined a new instance will be created.\n * @returns {Matrix4} The modified result parameter, or a new Matrix4 instance if one was not provided.\n */\nMatrix4.fromCamera = function (camera, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"camera\", camera);\n  //>>includeEnd('debug');\n\n  var position = camera.position;\n  var direction = camera.direction;\n  var up = camera.up;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"camera.position\", position);\n  Check.typeOf.object(\"camera.direction\", direction);\n  Check.typeOf.object(\"camera.up\", up);\n  //>>includeEnd('debug');\n\n  Cartesian3.normalize(direction, fromCameraF);\n  Cartesian3.normalize(\n    Cartesian3.cross(fromCameraF, up, fromCameraR),\n    fromCameraR\n  );\n  Cartesian3.normalize(\n    Cartesian3.cross(fromCameraR, fromCameraF, fromCameraU),\n    fromCameraU\n  );\n\n  var sX = fromCameraR.x;\n  var sY = fromCameraR.y;\n  var sZ = fromCameraR.z;\n  var fX = fromCameraF.x;\n  var fY = fromCameraF.y;\n  var fZ = fromCameraF.z;\n  var uX = fromCameraU.x;\n  var uY = fromCameraU.y;\n  var uZ = fromCameraU.z;\n  var positionX = position.x;\n  var positionY = position.y;\n  var positionZ = position.z;\n  var t0 = sX * -positionX + sY * -positionY + sZ * -positionZ;\n  var t1 = uX * -positionX + uY * -positionY + uZ * -positionZ;\n  var t2 = fX * positionX + fY * positionY + fZ * positionZ;\n\n  // The code below this comment is an optimized\n  // version of the commented lines.\n  // Rather that create two matrices and then multiply,\n  // we just bake in the multiplcation as part of creation.\n  // var rotation = new Matrix4(\n  //                 sX,  sY,  sZ, 0.0,\n  //                 uX,  uY,  uZ, 0.0,\n  //                -fX, -fY, -fZ, 0.0,\n  //                 0.0,  0.0,  0.0, 1.0);\n  // var translation = new Matrix4(\n  //                 1.0, 0.0, 0.0, -position.x,\n  //                 0.0, 1.0, 0.0, -position.y,\n  //                 0.0, 0.0, 1.0, -position.z,\n  //                 0.0, 0.0, 0.0, 1.0);\n  // return rotation.multiply(translation);\n  if (!defined(result)) {\n    return new Matrix4(\n      sX,\n      sY,\n      sZ,\n      t0,\n      uX,\n      uY,\n      uZ,\n      t1,\n      -fX,\n      -fY,\n      -fZ,\n      t2,\n      0.0,\n      0.0,\n      0.0,\n      1.0\n    );\n  }\n  result[0] = sX;\n  result[1] = uX;\n  result[2] = -fX;\n  result[3] = 0.0;\n  result[4] = sY;\n  result[5] = uY;\n  result[6] = -fY;\n  result[7] = 0.0;\n  result[8] = sZ;\n  result[9] = uZ;\n  result[10] = -fZ;\n  result[11] = 0.0;\n  result[12] = t0;\n  result[13] = t1;\n  result[14] = t2;\n  result[15] = 1.0;\n  return result;\n};\n\n/**\n * Computes a Matrix4 instance representing a perspective transformation matrix.\n *\n * @param {Number} fovY The field of view along the Y axis in radians.\n * @param {Number} aspectRatio The aspect ratio.\n * @param {Number} near The distance to the near plane in meters.\n * @param {Number} far The distance to the far plane in meters.\n * @param {Matrix4} result The object in which the result will be stored.\n * @returns {Matrix4} The modified result parameter.\n *\n * @exception {DeveloperError} fovY must be in (0, PI].\n * @exception {DeveloperError} aspectRatio must be greater than zero.\n * @exception {DeveloperError} near must be greater than zero.\n * @exception {DeveloperError} far must be greater than zero.\n */\nMatrix4.computePerspectiveFieldOfView = function (\n  fovY,\n  aspectRatio,\n  near,\n  far,\n  result\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number.greaterThan(\"fovY\", fovY, 0.0);\n  Check.typeOf.number.lessThan(\"fovY\", fovY, Math.PI);\n  Check.typeOf.number.greaterThan(\"near\", near, 0.0);\n  Check.typeOf.number.greaterThan(\"far\", far, 0.0);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  var bottom = Math.tan(fovY * 0.5);\n\n  var column1Row1 = 1.0 / bottom;\n  var column0Row0 = column1Row1 / aspectRatio;\n  var column2Row2 = (far + near) / (near - far);\n  var column3Row2 = (2.0 * far * near) / (near - far);\n\n  result[0] = column0Row0;\n  result[1] = 0.0;\n  result[2] = 0.0;\n  result[3] = 0.0;\n  result[4] = 0.0;\n  result[5] = column1Row1;\n  result[6] = 0.0;\n  result[7] = 0.0;\n  result[8] = 0.0;\n  result[9] = 0.0;\n  result[10] = column2Row2;\n  result[11] = -1.0;\n  result[12] = 0.0;\n  result[13] = 0.0;\n  result[14] = column3Row2;\n  result[15] = 0.0;\n  return result;\n};\n\n/**\n * Computes a Matrix4 instance representing an orthographic transformation matrix.\n *\n * @param {Number} left The number of meters to the left of the camera that will be in view.\n * @param {Number} right The number of meters to the right of the camera that will be in view.\n * @param {Number} bottom The number of meters below of the camera that will be in view.\n * @param {Number} top The number of meters above of the camera that will be in view.\n * @param {Number} near The distance to the near plane in meters.\n * @param {Number} far The distance to the far plane in meters.\n * @param {Matrix4} result The object in which the result will be stored.\n * @returns {Matrix4} The modified result parameter.\n */\nMatrix4.computeOrthographicOffCenter = function (\n  left,\n  right,\n  bottom,\n  top,\n  near,\n  far,\n  result\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"left\", left);\n  Check.typeOf.number(\"right\", right);\n  Check.typeOf.number(\"bottom\", bottom);\n  Check.typeOf.number(\"top\", top);\n  Check.typeOf.number(\"near\", near);\n  Check.typeOf.number(\"far\", far);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  var a = 1.0 / (right - left);\n  var b = 1.0 / (top - bottom);\n  var c = 1.0 / (far - near);\n\n  var tx = -(right + left) * a;\n  var ty = -(top + bottom) * b;\n  var tz = -(far + near) * c;\n  a *= 2.0;\n  b *= 2.0;\n  c *= -2.0;\n\n  result[0] = a;\n  result[1] = 0.0;\n  result[2] = 0.0;\n  result[3] = 0.0;\n  result[4] = 0.0;\n  result[5] = b;\n  result[6] = 0.0;\n  result[7] = 0.0;\n  result[8] = 0.0;\n  result[9] = 0.0;\n  result[10] = c;\n  result[11] = 0.0;\n  result[12] = tx;\n  result[13] = ty;\n  result[14] = tz;\n  result[15] = 1.0;\n  return result;\n};\n\n/**\n * Computes a Matrix4 instance representing an off center perspective transformation.\n *\n * @param {Number} left The number of meters to the left of the camera that will be in view.\n * @param {Number} right The number of meters to the right of the camera that will be in view.\n * @param {Number} bottom The number of meters below of the camera that will be in view.\n * @param {Number} top The number of meters above of the camera that will be in view.\n * @param {Number} near The distance to the near plane in meters.\n * @param {Number} far The distance to the far plane in meters.\n * @param {Matrix4} result The object in which the result will be stored.\n * @returns {Matrix4} The modified result parameter.\n */\nMatrix4.computePerspectiveOffCenter = function (\n  left,\n  right,\n  bottom,\n  top,\n  near,\n  far,\n  result\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"left\", left);\n  Check.typeOf.number(\"right\", right);\n  Check.typeOf.number(\"bottom\", bottom);\n  Check.typeOf.number(\"top\", top);\n  Check.typeOf.number(\"near\", near);\n  Check.typeOf.number(\"far\", far);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  var column0Row0 = (2.0 * near) / (right - left);\n  var column1Row1 = (2.0 * near) / (top - bottom);\n  var column2Row0 = (right + left) / (right - left);\n  var column2Row1 = (top + bottom) / (top - bottom);\n  var column2Row2 = -(far + near) / (far - near);\n  var column2Row3 = -1.0;\n  var column3Row2 = (-2.0 * far * near) / (far - near);\n\n  result[0] = column0Row0;\n  result[1] = 0.0;\n  result[2] = 0.0;\n  result[3] = 0.0;\n  result[4] = 0.0;\n  result[5] = column1Row1;\n  result[6] = 0.0;\n  result[7] = 0.0;\n  result[8] = column2Row0;\n  result[9] = column2Row1;\n  result[10] = column2Row2;\n  result[11] = column2Row3;\n  result[12] = 0.0;\n  result[13] = 0.0;\n  result[14] = column3Row2;\n  result[15] = 0.0;\n  return result;\n};\n\n/**\n * Computes a Matrix4 instance representing an infinite off center perspective transformation.\n *\n * @param {Number} left The number of meters to the left of the camera that will be in view.\n * @param {Number} right The number of meters to the right of the camera that will be in view.\n * @param {Number} bottom The number of meters below of the camera that will be in view.\n * @param {Number} top The number of meters above of the camera that will be in view.\n * @param {Number} near The distance to the near plane in meters.\n * @param {Matrix4} result The object in which the result will be stored.\n * @returns {Matrix4} The modified result parameter.\n */\nMatrix4.computeInfinitePerspectiveOffCenter = function (\n  left,\n  right,\n  bottom,\n  top,\n  near,\n  result\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"left\", left);\n  Check.typeOf.number(\"right\", right);\n  Check.typeOf.number(\"bottom\", bottom);\n  Check.typeOf.number(\"top\", top);\n  Check.typeOf.number(\"near\", near);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  var column0Row0 = (2.0 * near) / (right - left);\n  var column1Row1 = (2.0 * near) / (top - bottom);\n  var column2Row0 = (right + left) / (right - left);\n  var column2Row1 = (top + bottom) / (top - bottom);\n  var column2Row2 = -1.0;\n  var column2Row3 = -1.0;\n  var column3Row2 = -2.0 * near;\n\n  result[0] = column0Row0;\n  result[1] = 0.0;\n  result[2] = 0.0;\n  result[3] = 0.0;\n  result[4] = 0.0;\n  result[5] = column1Row1;\n  result[6] = 0.0;\n  result[7] = 0.0;\n  result[8] = column2Row0;\n  result[9] = column2Row1;\n  result[10] = column2Row2;\n  result[11] = column2Row3;\n  result[12] = 0.0;\n  result[13] = 0.0;\n  result[14] = column3Row2;\n  result[15] = 0.0;\n  return result;\n};\n\n/**\n * Computes a Matrix4 instance that transforms from normalized device coordinates to window coordinates.\n *\n * @param {Object} [viewport = { x : 0.0, y : 0.0, width : 0.0, height : 0.0 }] The viewport's corners as shown in Example 1.\n * @param {Number} [nearDepthRange=0.0] The near plane distance in window coordinates.\n * @param {Number} [farDepthRange=1.0] The far plane distance in window coordinates.\n * @param {Matrix4} [result] The object in which the result will be stored.\n * @returns {Matrix4} The modified result parameter.\n *\n * @example\n * // Create viewport transformation using an explicit viewport and depth range.\n * var m = Cesium.Matrix4.computeViewportTransformation({\n *     x : 0.0,\n *     y : 0.0,\n *     width : 1024.0,\n *     height : 768.0\n * }, 0.0, 1.0, new Cesium.Matrix4());\n */\nMatrix4.computeViewportTransformation = function (\n  viewport,\n  nearDepthRange,\n  farDepthRange,\n  result\n) {\n  if (!defined(result)) {\n    result = new Matrix4();\n  }\n\n  viewport = defaultValue(viewport, defaultValue.EMPTY_OBJECT);\n  var x = defaultValue(viewport.x, 0.0);\n  var y = defaultValue(viewport.y, 0.0);\n  var width = defaultValue(viewport.width, 0.0);\n  var height = defaultValue(viewport.height, 0.0);\n  nearDepthRange = defaultValue(nearDepthRange, 0.0);\n  farDepthRange = defaultValue(farDepthRange, 1.0);\n\n  var halfWidth = width * 0.5;\n  var halfHeight = height * 0.5;\n  var halfDepth = (farDepthRange - nearDepthRange) * 0.5;\n\n  var column0Row0 = halfWidth;\n  var column1Row1 = halfHeight;\n  var column2Row2 = halfDepth;\n  var column3Row0 = x + halfWidth;\n  var column3Row1 = y + halfHeight;\n  var column3Row2 = nearDepthRange + halfDepth;\n  var column3Row3 = 1.0;\n\n  result[0] = column0Row0;\n  result[1] = 0.0;\n  result[2] = 0.0;\n  result[3] = 0.0;\n  result[4] = 0.0;\n  result[5] = column1Row1;\n  result[6] = 0.0;\n  result[7] = 0.0;\n  result[8] = 0.0;\n  result[9] = 0.0;\n  result[10] = column2Row2;\n  result[11] = 0.0;\n  result[12] = column3Row0;\n  result[13] = column3Row1;\n  result[14] = column3Row2;\n  result[15] = column3Row3;\n  return result;\n};\n\n/**\n * Computes a Matrix4 instance that transforms from world space to view space.\n *\n * @param {Cartesian3} position The position of the camera.\n * @param {Cartesian3} direction The forward direction.\n * @param {Cartesian3} up The up direction.\n * @param {Cartesian3} right The right direction.\n * @param {Matrix4} result The object in which the result will be stored.\n * @returns {Matrix4} The modified result parameter.\n */\nMatrix4.computeView = function (position, direction, up, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"position\", position);\n  Check.typeOf.object(\"direction\", direction);\n  Check.typeOf.object(\"up\", up);\n  Check.typeOf.object(\"right\", right);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result[0] = right.x;\n  result[1] = up.x;\n  result[2] = -direction.x;\n  result[3] = 0.0;\n  result[4] = right.y;\n  result[5] = up.y;\n  result[6] = -direction.y;\n  result[7] = 0.0;\n  result[8] = right.z;\n  result[9] = up.z;\n  result[10] = -direction.z;\n  result[11] = 0.0;\n  result[12] = -Cartesian3.dot(right, position);\n  result[13] = -Cartesian3.dot(up, position);\n  result[14] = Cartesian3.dot(direction, position);\n  result[15] = 1.0;\n  return result;\n};\n\n/**\n * Computes an Array from the provided Matrix4 instance.\n * The array will be in column-major order.\n *\n * @param {Matrix4} matrix The matrix to use..\n * @param {Number[]} [result] The Array onto which to store the result.\n * @returns {Number[]} The modified Array parameter or a new Array instance if one was not provided.\n *\n * @example\n * //create an array from an instance of Matrix4\n * // m = [10.0, 14.0, 18.0, 22.0]\n * //     [11.0, 15.0, 19.0, 23.0]\n * //     [12.0, 16.0, 20.0, 24.0]\n * //     [13.0, 17.0, 21.0, 25.0]\n * var a = Cesium.Matrix4.toArray(m);\n *\n * // m remains the same\n * //creates a = [10.0, 11.0, 12.0, 13.0, 14.0, 15.0, 16.0, 17.0, 18.0, 19.0, 20.0, 21.0, 22.0, 23.0, 24.0, 25.0]\n */\nMatrix4.toArray = function (matrix, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    return [\n      matrix[0],\n      matrix[1],\n      matrix[2],\n      matrix[3],\n      matrix[4],\n      matrix[5],\n      matrix[6],\n      matrix[7],\n      matrix[8],\n      matrix[9],\n      matrix[10],\n      matrix[11],\n      matrix[12],\n      matrix[13],\n      matrix[14],\n      matrix[15],\n    ];\n  }\n  result[0] = matrix[0];\n  result[1] = matrix[1];\n  result[2] = matrix[2];\n  result[3] = matrix[3];\n  result[4] = matrix[4];\n  result[5] = matrix[5];\n  result[6] = matrix[6];\n  result[7] = matrix[7];\n  result[8] = matrix[8];\n  result[9] = matrix[9];\n  result[10] = matrix[10];\n  result[11] = matrix[11];\n  result[12] = matrix[12];\n  result[13] = matrix[13];\n  result[14] = matrix[14];\n  result[15] = matrix[15];\n  return result;\n};\n\n/**\n * Computes the array index of the element at the provided row and column.\n *\n * @param {Number} row The zero-based index of the row.\n * @param {Number} column The zero-based index of the column.\n * @returns {Number} The index of the element at the provided row and column.\n *\n * @exception {DeveloperError} row must be 0, 1, 2, or 3.\n * @exception {DeveloperError} column must be 0, 1, 2, or 3.\n *\n * @example\n * var myMatrix = new Cesium.Matrix4();\n * var column1Row0Index = Cesium.Matrix4.getElementIndex(1, 0);\n * var column1Row0 = myMatrix[column1Row0Index];\n * myMatrix[column1Row0Index] = 10.0;\n */\nMatrix4.getElementIndex = function (column, row) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number.greaterThanOrEquals(\"row\", row, 0);\n  Check.typeOf.number.lessThanOrEquals(\"row\", row, 3);\n\n  Check.typeOf.number.greaterThanOrEquals(\"column\", column, 0);\n  Check.typeOf.number.lessThanOrEquals(\"column\", column, 3);\n  //>>includeEnd('debug');\n\n  return column * 4 + row;\n};\n\n/**\n * Retrieves a copy of the matrix column at the provided index as a Cartesian4 instance.\n *\n * @param {Matrix4} matrix The matrix to use.\n * @param {Number} index The zero-based index of the column to retrieve.\n * @param {Cartesian4} result The object onto which to store the result.\n * @returns {Cartesian4} The modified result parameter.\n *\n * @exception {DeveloperError} index must be 0, 1, 2, or 3.\n *\n * @example\n * //returns a Cartesian4 instance with values from the specified column\n * // m = [10.0, 11.0, 12.0, 13.0]\n * //     [14.0, 15.0, 16.0, 17.0]\n * //     [18.0, 19.0, 20.0, 21.0]\n * //     [22.0, 23.0, 24.0, 25.0]\n *\n * //Example 1: Creates an instance of Cartesian\n * var a = Cesium.Matrix4.getColumn(m, 2, new Cesium.Cartesian4());\n *\n * @example\n * //Example 2: Sets values for Cartesian instance\n * var a = new Cesium.Cartesian4();\n * Cesium.Matrix4.getColumn(m, 2, a);\n *\n * // a.x = 12.0; a.y = 16.0; a.z = 20.0; a.w = 24.0;\n */\nMatrix4.getColumn = function (matrix, index, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n\n  Check.typeOf.number.greaterThanOrEquals(\"index\", index, 0);\n  Check.typeOf.number.lessThanOrEquals(\"index\", index, 3);\n\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  var startIndex = index * 4;\n  var x = matrix[startIndex];\n  var y = matrix[startIndex + 1];\n  var z = matrix[startIndex + 2];\n  var w = matrix[startIndex + 3];\n\n  result.x = x;\n  result.y = y;\n  result.z = z;\n  result.w = w;\n  return result;\n};\n\n/**\n * Computes a new matrix that replaces the specified column in the provided matrix with the provided Cartesian4 instance.\n *\n * @param {Matrix4} matrix The matrix to use.\n * @param {Number} index The zero-based index of the column to set.\n * @param {Cartesian4} cartesian The Cartesian whose values will be assigned to the specified column.\n * @param {Matrix4} result The object onto which to store the result.\n * @returns {Matrix4} The modified result parameter.\n *\n * @exception {DeveloperError} index must be 0, 1, 2, or 3.\n *\n * @example\n * //creates a new Matrix4 instance with new column values from the Cartesian4 instance\n * // m = [10.0, 11.0, 12.0, 13.0]\n * //     [14.0, 15.0, 16.0, 17.0]\n * //     [18.0, 19.0, 20.0, 21.0]\n * //     [22.0, 23.0, 24.0, 25.0]\n *\n * var a = Cesium.Matrix4.setColumn(m, 2, new Cesium.Cartesian4(99.0, 98.0, 97.0, 96.0), new Cesium.Matrix4());\n *\n * // m remains the same\n * // a = [10.0, 11.0, 99.0, 13.0]\n * //     [14.0, 15.0, 98.0, 17.0]\n * //     [18.0, 19.0, 97.0, 21.0]\n * //     [22.0, 23.0, 96.0, 25.0]\n */\nMatrix4.setColumn = function (matrix, index, cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n\n  Check.typeOf.number.greaterThanOrEquals(\"index\", index, 0);\n  Check.typeOf.number.lessThanOrEquals(\"index\", index, 3);\n\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result = Matrix4.clone(matrix, result);\n  var startIndex = index * 4;\n  result[startIndex] = cartesian.x;\n  result[startIndex + 1] = cartesian.y;\n  result[startIndex + 2] = cartesian.z;\n  result[startIndex + 3] = cartesian.w;\n  return result;\n};\n\n/**\n * Computes a new matrix that replaces the translation in the rightmost column of the provided\n * matrix with the provided translation. This assumes the matrix is an affine transformation.\n *\n * @param {Matrix4} matrix The matrix to use.\n * @param {Cartesian3} translation The translation that replaces the translation of the provided matrix.\n * @param {Matrix4} result The object onto which to store the result.\n * @returns {Matrix4} The modified result parameter.\n */\nMatrix4.setTranslation = function (matrix, translation, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.object(\"translation\", translation);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result[0] = matrix[0];\n  result[1] = matrix[1];\n  result[2] = matrix[2];\n  result[3] = matrix[3];\n\n  result[4] = matrix[4];\n  result[5] = matrix[5];\n  result[6] = matrix[6];\n  result[7] = matrix[7];\n\n  result[8] = matrix[8];\n  result[9] = matrix[9];\n  result[10] = matrix[10];\n  result[11] = matrix[11];\n\n  result[12] = translation.x;\n  result[13] = translation.y;\n  result[14] = translation.z;\n  result[15] = matrix[15];\n\n  return result;\n};\n\nvar scaleScratch = new Cartesian3();\n/**\n * Computes a new matrix that replaces the scale with the provided scale.\n * This assumes the matrix is an affine transformation.\n *\n * @param {Matrix4} matrix The matrix to use.\n * @param {Cartesian3} scale The scale that replaces the scale of the provided matrix.\n * @param {Matrix4} result The object onto which to store the result.\n * @returns {Matrix4} The modified result parameter.\n */\nMatrix4.setScale = function (matrix, scale, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.object(\"scale\", scale);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  var existingScale = Matrix4.getScale(matrix, scaleScratch);\n  var newScale = Cartesian3.divideComponents(\n    scale,\n    existingScale,\n    scaleScratch\n  );\n  return Matrix4.multiplyByScale(matrix, newScale, result);\n};\n\n/**\n * Retrieves a copy of the matrix row at the provided index as a Cartesian4 instance.\n *\n * @param {Matrix4} matrix The matrix to use.\n * @param {Number} index The zero-based index of the row to retrieve.\n * @param {Cartesian4} result The object onto which to store the result.\n * @returns {Cartesian4} The modified result parameter.\n *\n * @exception {DeveloperError} index must be 0, 1, 2, or 3.\n *\n * @example\n * //returns a Cartesian4 instance with values from the specified column\n * // m = [10.0, 11.0, 12.0, 13.0]\n * //     [14.0, 15.0, 16.0, 17.0]\n * //     [18.0, 19.0, 20.0, 21.0]\n * //     [22.0, 23.0, 24.0, 25.0]\n *\n * //Example 1: Returns an instance of Cartesian\n * var a = Cesium.Matrix4.getRow(m, 2, new Cesium.Cartesian4());\n *\n * @example\n * //Example 2: Sets values for a Cartesian instance\n * var a = new Cesium.Cartesian4();\n * Cesium.Matrix4.getRow(m, 2, a);\n *\n * // a.x = 18.0; a.y = 19.0; a.z = 20.0; a.w = 21.0;\n */\nMatrix4.getRow = function (matrix, index, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n\n  Check.typeOf.number.greaterThanOrEquals(\"index\", index, 0);\n  Check.typeOf.number.lessThanOrEquals(\"index\", index, 3);\n\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  var x = matrix[index];\n  var y = matrix[index + 4];\n  var z = matrix[index + 8];\n  var w = matrix[index + 12];\n\n  result.x = x;\n  result.y = y;\n  result.z = z;\n  result.w = w;\n  return result;\n};\n\n/**\n * Computes a new matrix that replaces the specified row in the provided matrix with the provided Cartesian4 instance.\n *\n * @param {Matrix4} matrix The matrix to use.\n * @param {Number} index The zero-based index of the row to set.\n * @param {Cartesian4} cartesian The Cartesian whose values will be assigned to the specified row.\n * @param {Matrix4} result The object onto which to store the result.\n * @returns {Matrix4} The modified result parameter.\n *\n * @exception {DeveloperError} index must be 0, 1, 2, or 3.\n *\n * @example\n * //create a new Matrix4 instance with new row values from the Cartesian4 instance\n * // m = [10.0, 11.0, 12.0, 13.0]\n * //     [14.0, 15.0, 16.0, 17.0]\n * //     [18.0, 19.0, 20.0, 21.0]\n * //     [22.0, 23.0, 24.0, 25.0]\n *\n * var a = Cesium.Matrix4.setRow(m, 2, new Cesium.Cartesian4(99.0, 98.0, 97.0, 96.0), new Cesium.Matrix4());\n *\n * // m remains the same\n * // a = [10.0, 11.0, 12.0, 13.0]\n * //     [14.0, 15.0, 16.0, 17.0]\n * //     [99.0, 98.0, 97.0, 96.0]\n * //     [22.0, 23.0, 24.0, 25.0]\n */\nMatrix4.setRow = function (matrix, index, cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n\n  Check.typeOf.number.greaterThanOrEquals(\"index\", index, 0);\n  Check.typeOf.number.lessThanOrEquals(\"index\", index, 3);\n\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result = Matrix4.clone(matrix, result);\n  result[index] = cartesian.x;\n  result[index + 4] = cartesian.y;\n  result[index + 8] = cartesian.z;\n  result[index + 12] = cartesian.w;\n  return result;\n};\n\nvar scratchColumn = new Cartesian3();\n\n/**\n * Extracts the non-uniform scale assuming the matrix is an affine transformation.\n *\n * @param {Matrix4} matrix The matrix.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter\n */\nMatrix4.getScale = function (matrix, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = Cartesian3.magnitude(\n    Cartesian3.fromElements(matrix[0], matrix[1], matrix[2], scratchColumn)\n  );\n  result.y = Cartesian3.magnitude(\n    Cartesian3.fromElements(matrix[4], matrix[5], matrix[6], scratchColumn)\n  );\n  result.z = Cartesian3.magnitude(\n    Cartesian3.fromElements(matrix[8], matrix[9], matrix[10], scratchColumn)\n  );\n  return result;\n};\n\nvar scratchScale = new Cartesian3();\n\n/**\n * Computes the maximum scale assuming the matrix is an affine transformation.\n * The maximum scale is the maximum length of the column vectors in the upper-left\n * 3x3 matrix.\n *\n * @param {Matrix4} matrix The matrix.\n * @returns {Number} The maximum scale.\n */\nMatrix4.getMaximumScale = function (matrix) {\n  Matrix4.getScale(matrix, scratchScale);\n  return Cartesian3.maximumComponent(scratchScale);\n};\n\n/**\n * Computes the product of two matrices.\n *\n * @param {Matrix4} left The first matrix.\n * @param {Matrix4} right The second matrix.\n * @param {Matrix4} result The object onto which to store the result.\n * @returns {Matrix4} The modified result parameter.\n */\nMatrix4.multiply = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  var left0 = left[0];\n  var left1 = left[1];\n  var left2 = left[2];\n  var left3 = left[3];\n  var left4 = left[4];\n  var left5 = left[5];\n  var left6 = left[6];\n  var left7 = left[7];\n  var left8 = left[8];\n  var left9 = left[9];\n  var left10 = left[10];\n  var left11 = left[11];\n  var left12 = left[12];\n  var left13 = left[13];\n  var left14 = left[14];\n  var left15 = left[15];\n\n  var right0 = right[0];\n  var right1 = right[1];\n  var right2 = right[2];\n  var right3 = right[3];\n  var right4 = right[4];\n  var right5 = right[5];\n  var right6 = right[6];\n  var right7 = right[7];\n  var right8 = right[8];\n  var right9 = right[9];\n  var right10 = right[10];\n  var right11 = right[11];\n  var right12 = right[12];\n  var right13 = right[13];\n  var right14 = right[14];\n  var right15 = right[15];\n\n  var column0Row0 =\n    left0 * right0 + left4 * right1 + left8 * right2 + left12 * right3;\n  var column0Row1 =\n    left1 * right0 + left5 * right1 + left9 * right2 + left13 * right3;\n  var column0Row2 =\n    left2 * right0 + left6 * right1 + left10 * right2 + left14 * right3;\n  var column0Row3 =\n    left3 * right0 + left7 * right1 + left11 * right2 + left15 * right3;\n\n  var column1Row0 =\n    left0 * right4 + left4 * right5 + left8 * right6 + left12 * right7;\n  var column1Row1 =\n    left1 * right4 + left5 * right5 + left9 * right6 + left13 * right7;\n  var column1Row2 =\n    left2 * right4 + left6 * right5 + left10 * right6 + left14 * right7;\n  var column1Row3 =\n    left3 * right4 + left7 * right5 + left11 * right6 + left15 * right7;\n\n  var column2Row0 =\n    left0 * right8 + left4 * right9 + left8 * right10 + left12 * right11;\n  var column2Row1 =\n    left1 * right8 + left5 * right9 + left9 * right10 + left13 * right11;\n  var column2Row2 =\n    left2 * right8 + left6 * right9 + left10 * right10 + left14 * right11;\n  var column2Row3 =\n    left3 * right8 + left7 * right9 + left11 * right10 + left15 * right11;\n\n  var column3Row0 =\n    left0 * right12 + left4 * right13 + left8 * right14 + left12 * right15;\n  var column3Row1 =\n    left1 * right12 + left5 * right13 + left9 * right14 + left13 * right15;\n  var column3Row2 =\n    left2 * right12 + left6 * right13 + left10 * right14 + left14 * right15;\n  var column3Row3 =\n    left3 * right12 + left7 * right13 + left11 * right14 + left15 * right15;\n\n  result[0] = column0Row0;\n  result[1] = column0Row1;\n  result[2] = column0Row2;\n  result[3] = column0Row3;\n  result[4] = column1Row0;\n  result[5] = column1Row1;\n  result[6] = column1Row2;\n  result[7] = column1Row3;\n  result[8] = column2Row0;\n  result[9] = column2Row1;\n  result[10] = column2Row2;\n  result[11] = column2Row3;\n  result[12] = column3Row0;\n  result[13] = column3Row1;\n  result[14] = column3Row2;\n  result[15] = column3Row3;\n  return result;\n};\n\n/**\n * Computes the sum of two matrices.\n *\n * @param {Matrix4} left The first matrix.\n * @param {Matrix4} right The second matrix.\n * @param {Matrix4} result The object onto which to store the result.\n * @returns {Matrix4} The modified result parameter.\n */\nMatrix4.add = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result[0] = left[0] + right[0];\n  result[1] = left[1] + right[1];\n  result[2] = left[2] + right[2];\n  result[3] = left[3] + right[3];\n  result[4] = left[4] + right[4];\n  result[5] = left[5] + right[5];\n  result[6] = left[6] + right[6];\n  result[7] = left[7] + right[7];\n  result[8] = left[8] + right[8];\n  result[9] = left[9] + right[9];\n  result[10] = left[10] + right[10];\n  result[11] = left[11] + right[11];\n  result[12] = left[12] + right[12];\n  result[13] = left[13] + right[13];\n  result[14] = left[14] + right[14];\n  result[15] = left[15] + right[15];\n  return result;\n};\n\n/**\n * Computes the difference of two matrices.\n *\n * @param {Matrix4} left The first matrix.\n * @param {Matrix4} right The second matrix.\n * @param {Matrix4} result The object onto which to store the result.\n * @returns {Matrix4} The modified result parameter.\n */\nMatrix4.subtract = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result[0] = left[0] - right[0];\n  result[1] = left[1] - right[1];\n  result[2] = left[2] - right[2];\n  result[3] = left[3] - right[3];\n  result[4] = left[4] - right[4];\n  result[5] = left[5] - right[5];\n  result[6] = left[6] - right[6];\n  result[7] = left[7] - right[7];\n  result[8] = left[8] - right[8];\n  result[9] = left[9] - right[9];\n  result[10] = left[10] - right[10];\n  result[11] = left[11] - right[11];\n  result[12] = left[12] - right[12];\n  result[13] = left[13] - right[13];\n  result[14] = left[14] - right[14];\n  result[15] = left[15] - right[15];\n  return result;\n};\n\n/**\n * Computes the product of two matrices assuming the matrices are affine transformation matrices,\n * where the upper left 3x3 elements are any matrix, and\n * the upper three elements in the fourth column are the translation.\n * The bottom row is assumed to be [0, 0, 0, 1].\n * The matrix is not verified to be in the proper form.\n * This method is faster than computing the product for general 4x4\n * matrices using {@link Matrix4.multiply}.\n *\n * @param {Matrix4} left The first matrix.\n * @param {Matrix4} right The second matrix.\n * @param {Matrix4} result The object onto which to store the result.\n * @returns {Matrix4} The modified result parameter.\n *\n * @example\n * var m1 = new Cesium.Matrix4(1.0, 6.0, 7.0, 0.0, 2.0, 5.0, 8.0, 0.0, 3.0, 4.0, 9.0, 0.0, 0.0, 0.0, 0.0, 1.0);\n * var m2 = Cesium.Transforms.eastNorthUpToFixedFrame(new Cesium.Cartesian3(1.0, 1.0, 1.0));\n * var m3 = Cesium.Matrix4.multiplyTransformation(m1, m2, new Cesium.Matrix4());\n */\nMatrix4.multiplyTransformation = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  var left0 = left[0];\n  var left1 = left[1];\n  var left2 = left[2];\n  var left4 = left[4];\n  var left5 = left[5];\n  var left6 = left[6];\n  var left8 = left[8];\n  var left9 = left[9];\n  var left10 = left[10];\n  var left12 = left[12];\n  var left13 = left[13];\n  var left14 = left[14];\n\n  var right0 = right[0];\n  var right1 = right[1];\n  var right2 = right[2];\n  var right4 = right[4];\n  var right5 = right[5];\n  var right6 = right[6];\n  var right8 = right[8];\n  var right9 = right[9];\n  var right10 = right[10];\n  var right12 = right[12];\n  var right13 = right[13];\n  var right14 = right[14];\n\n  var column0Row0 = left0 * right0 + left4 * right1 + left8 * right2;\n  var column0Row1 = left1 * right0 + left5 * right1 + left9 * right2;\n  var column0Row2 = left2 * right0 + left6 * right1 + left10 * right2;\n\n  var column1Row0 = left0 * right4 + left4 * right5 + left8 * right6;\n  var column1Row1 = left1 * right4 + left5 * right5 + left9 * right6;\n  var column1Row2 = left2 * right4 + left6 * right5 + left10 * right6;\n\n  var column2Row0 = left0 * right8 + left4 * right9 + left8 * right10;\n  var column2Row1 = left1 * right8 + left5 * right9 + left9 * right10;\n  var column2Row2 = left2 * right8 + left6 * right9 + left10 * right10;\n\n  var column3Row0 =\n    left0 * right12 + left4 * right13 + left8 * right14 + left12;\n  var column3Row1 =\n    left1 * right12 + left5 * right13 + left9 * right14 + left13;\n  var column3Row2 =\n    left2 * right12 + left6 * right13 + left10 * right14 + left14;\n\n  result[0] = column0Row0;\n  result[1] = column0Row1;\n  result[2] = column0Row2;\n  result[3] = 0.0;\n  result[4] = column1Row0;\n  result[5] = column1Row1;\n  result[6] = column1Row2;\n  result[7] = 0.0;\n  result[8] = column2Row0;\n  result[9] = column2Row1;\n  result[10] = column2Row2;\n  result[11] = 0.0;\n  result[12] = column3Row0;\n  result[13] = column3Row1;\n  result[14] = column3Row2;\n  result[15] = 1.0;\n  return result;\n};\n\n/**\n * Multiplies a transformation matrix (with a bottom row of <code>[0.0, 0.0, 0.0, 1.0]</code>)\n * by a 3x3 rotation matrix.  This is an optimization\n * for <code>Matrix4.multiply(m, Matrix4.fromRotationTranslation(rotation), m);</code> with less allocations and arithmetic operations.\n *\n * @param {Matrix4} matrix The matrix on the left-hand side.\n * @param {Matrix3} rotation The 3x3 rotation matrix on the right-hand side.\n * @param {Matrix4} result The object onto which to store the result.\n * @returns {Matrix4} The modified result parameter.\n *\n * @example\n * // Instead of Cesium.Matrix4.multiply(m, Cesium.Matrix4.fromRotationTranslation(rotation), m);\n * Cesium.Matrix4.multiplyByMatrix3(m, rotation, m);\n */\nMatrix4.multiplyByMatrix3 = function (matrix, rotation, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.object(\"rotation\", rotation);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  var left0 = matrix[0];\n  var left1 = matrix[1];\n  var left2 = matrix[2];\n  var left4 = matrix[4];\n  var left5 = matrix[5];\n  var left6 = matrix[6];\n  var left8 = matrix[8];\n  var left9 = matrix[9];\n  var left10 = matrix[10];\n\n  var right0 = rotation[0];\n  var right1 = rotation[1];\n  var right2 = rotation[2];\n  var right4 = rotation[3];\n  var right5 = rotation[4];\n  var right6 = rotation[5];\n  var right8 = rotation[6];\n  var right9 = rotation[7];\n  var right10 = rotation[8];\n\n  var column0Row0 = left0 * right0 + left4 * right1 + left8 * right2;\n  var column0Row1 = left1 * right0 + left5 * right1 + left9 * right2;\n  var column0Row2 = left2 * right0 + left6 * right1 + left10 * right2;\n\n  var column1Row0 = left0 * right4 + left4 * right5 + left8 * right6;\n  var column1Row1 = left1 * right4 + left5 * right5 + left9 * right6;\n  var column1Row2 = left2 * right4 + left6 * right5 + left10 * right6;\n\n  var column2Row0 = left0 * right8 + left4 * right9 + left8 * right10;\n  var column2Row1 = left1 * right8 + left5 * right9 + left9 * right10;\n  var column2Row2 = left2 * right8 + left6 * right9 + left10 * right10;\n\n  result[0] = column0Row0;\n  result[1] = column0Row1;\n  result[2] = column0Row2;\n  result[3] = 0.0;\n  result[4] = column1Row0;\n  result[5] = column1Row1;\n  result[6] = column1Row2;\n  result[7] = 0.0;\n  result[8] = column2Row0;\n  result[9] = column2Row1;\n  result[10] = column2Row2;\n  result[11] = 0.0;\n  result[12] = matrix[12];\n  result[13] = matrix[13];\n  result[14] = matrix[14];\n  result[15] = matrix[15];\n  return result;\n};\n\n/**\n * Multiplies a transformation matrix (with a bottom row of <code>[0.0, 0.0, 0.0, 1.0]</code>)\n * by an implicit translation matrix defined by a {@link Cartesian3}.  This is an optimization\n * for <code>Matrix4.multiply(m, Matrix4.fromTranslation(position), m);</code> with less allocations and arithmetic operations.\n *\n * @param {Matrix4} matrix The matrix on the left-hand side.\n * @param {Cartesian3} translation The translation on the right-hand side.\n * @param {Matrix4} result The object onto which to store the result.\n * @returns {Matrix4} The modified result parameter.\n *\n * @example\n * // Instead of Cesium.Matrix4.multiply(m, Cesium.Matrix4.fromTranslation(position), m);\n * Cesium.Matrix4.multiplyByTranslation(m, position, m);\n */\nMatrix4.multiplyByTranslation = function (matrix, translation, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.object(\"translation\", translation);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  var x = translation.x;\n  var y = translation.y;\n  var z = translation.z;\n\n  var tx = x * matrix[0] + y * matrix[4] + z * matrix[8] + matrix[12];\n  var ty = x * matrix[1] + y * matrix[5] + z * matrix[9] + matrix[13];\n  var tz = x * matrix[2] + y * matrix[6] + z * matrix[10] + matrix[14];\n\n  result[0] = matrix[0];\n  result[1] = matrix[1];\n  result[2] = matrix[2];\n  result[3] = matrix[3];\n  result[4] = matrix[4];\n  result[5] = matrix[5];\n  result[6] = matrix[6];\n  result[7] = matrix[7];\n  result[8] = matrix[8];\n  result[9] = matrix[9];\n  result[10] = matrix[10];\n  result[11] = matrix[11];\n  result[12] = tx;\n  result[13] = ty;\n  result[14] = tz;\n  result[15] = matrix[15];\n  return result;\n};\n\nvar uniformScaleScratch = new Cartesian3();\n\n/**\n * Multiplies an affine transformation matrix (with a bottom row of <code>[0.0, 0.0, 0.0, 1.0]</code>)\n * by an implicit uniform scale matrix.  This is an optimization\n * for <code>Matrix4.multiply(m, Matrix4.fromUniformScale(scale), m);</code>, where\n * <code>m</code> must be an affine matrix.\n * This function performs fewer allocations and arithmetic operations.\n *\n * @param {Matrix4} matrix The affine matrix on the left-hand side.\n * @param {Number} scale The uniform scale on the right-hand side.\n * @param {Matrix4} result The object onto which to store the result.\n * @returns {Matrix4} The modified result parameter.\n *\n *\n * @example\n * // Instead of Cesium.Matrix4.multiply(m, Cesium.Matrix4.fromUniformScale(scale), m);\n * Cesium.Matrix4.multiplyByUniformScale(m, scale, m);\n *\n * @see Matrix4.fromUniformScale\n * @see Matrix4.multiplyByScale\n */\nMatrix4.multiplyByUniformScale = function (matrix, scale, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.number(\"scale\", scale);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  uniformScaleScratch.x = scale;\n  uniformScaleScratch.y = scale;\n  uniformScaleScratch.z = scale;\n  return Matrix4.multiplyByScale(matrix, uniformScaleScratch, result);\n};\n\n/**\n * Multiplies an affine transformation matrix (with a bottom row of <code>[0.0, 0.0, 0.0, 1.0]</code>)\n * by an implicit non-uniform scale matrix. This is an optimization\n * for <code>Matrix4.multiply(m, Matrix4.fromUniformScale(scale), m);</code>, where\n * <code>m</code> must be an affine matrix.\n * This function performs fewer allocations and arithmetic operations.\n *\n * @param {Matrix4} matrix The affine matrix on the left-hand side.\n * @param {Cartesian3} scale The non-uniform scale on the right-hand side.\n * @param {Matrix4} result The object onto which to store the result.\n * @returns {Matrix4} The modified result parameter.\n *\n *\n * @example\n * // Instead of Cesium.Matrix4.multiply(m, Cesium.Matrix4.fromScale(scale), m);\n * Cesium.Matrix4.multiplyByScale(m, scale, m);\n *\n * @see Matrix4.fromScale\n * @see Matrix4.multiplyByUniformScale\n */\nMatrix4.multiplyByScale = function (matrix, scale, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.object(\"scale\", scale);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  var scaleX = scale.x;\n  var scaleY = scale.y;\n  var scaleZ = scale.z;\n\n  // Faster than Cartesian3.equals\n  if (scaleX === 1.0 && scaleY === 1.0 && scaleZ === 1.0) {\n    return Matrix4.clone(matrix, result);\n  }\n\n  result[0] = scaleX * matrix[0];\n  result[1] = scaleX * matrix[1];\n  result[2] = scaleX * matrix[2];\n  result[3] = 0.0;\n  result[4] = scaleY * matrix[4];\n  result[5] = scaleY * matrix[5];\n  result[6] = scaleY * matrix[6];\n  result[7] = 0.0;\n  result[8] = scaleZ * matrix[8];\n  result[9] = scaleZ * matrix[9];\n  result[10] = scaleZ * matrix[10];\n  result[11] = 0.0;\n  result[12] = matrix[12];\n  result[13] = matrix[13];\n  result[14] = matrix[14];\n  result[15] = 1.0;\n  return result;\n};\n\n/**\n * Computes the product of a matrix and a column vector.\n *\n * @param {Matrix4} matrix The matrix.\n * @param {Cartesian4} cartesian The vector.\n * @param {Cartesian4} result The object onto which to store the result.\n * @returns {Cartesian4} The modified result parameter.\n */\nMatrix4.multiplyByVector = function (matrix, cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  var vX = cartesian.x;\n  var vY = cartesian.y;\n  var vZ = cartesian.z;\n  var vW = cartesian.w;\n\n  var x = matrix[0] * vX + matrix[4] * vY + matrix[8] * vZ + matrix[12] * vW;\n  var y = matrix[1] * vX + matrix[5] * vY + matrix[9] * vZ + matrix[13] * vW;\n  var z = matrix[2] * vX + matrix[6] * vY + matrix[10] * vZ + matrix[14] * vW;\n  var w = matrix[3] * vX + matrix[7] * vY + matrix[11] * vZ + matrix[15] * vW;\n\n  result.x = x;\n  result.y = y;\n  result.z = z;\n  result.w = w;\n  return result;\n};\n\n/**\n * Computes the product of a matrix and a {@link Cartesian3}.  This is equivalent to calling {@link Matrix4.multiplyByVector}\n * with a {@link Cartesian4} with a <code>w</code> component of zero.\n *\n * @param {Matrix4} matrix The matrix.\n * @param {Cartesian3} cartesian The point.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter.\n *\n * @example\n * var p = new Cesium.Cartesian3(1.0, 2.0, 3.0);\n * var result = Cesium.Matrix4.multiplyByPointAsVector(matrix, p, new Cesium.Cartesian3());\n * // A shortcut for\n * //   Cartesian3 p = ...\n * //   Cesium.Matrix4.multiplyByVector(matrix, new Cesium.Cartesian4(p.x, p.y, p.z, 0.0), result);\n */\nMatrix4.multiplyByPointAsVector = function (matrix, cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  var vX = cartesian.x;\n  var vY = cartesian.y;\n  var vZ = cartesian.z;\n\n  var x = matrix[0] * vX + matrix[4] * vY + matrix[8] * vZ;\n  var y = matrix[1] * vX + matrix[5] * vY + matrix[9] * vZ;\n  var z = matrix[2] * vX + matrix[6] * vY + matrix[10] * vZ;\n\n  result.x = x;\n  result.y = y;\n  result.z = z;\n  return result;\n};\n\n/**\n * Computes the product of a matrix and a {@link Cartesian3}. This is equivalent to calling {@link Matrix4.multiplyByVector}\n * with a {@link Cartesian4} with a <code>w</code> component of 1, but returns a {@link Cartesian3} instead of a {@link Cartesian4}.\n *\n * @param {Matrix4} matrix The matrix.\n * @param {Cartesian3} cartesian The point.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter.\n *\n * @example\n * var p = new Cesium.Cartesian3(1.0, 2.0, 3.0);\n * var result = Cesium.Matrix4.multiplyByPoint(matrix, p, new Cesium.Cartesian3());\n */\nMatrix4.multiplyByPoint = function (matrix, cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  var vX = cartesian.x;\n  var vY = cartesian.y;\n  var vZ = cartesian.z;\n\n  var x = matrix[0] * vX + matrix[4] * vY + matrix[8] * vZ + matrix[12];\n  var y = matrix[1] * vX + matrix[5] * vY + matrix[9] * vZ + matrix[13];\n  var z = matrix[2] * vX + matrix[6] * vY + matrix[10] * vZ + matrix[14];\n\n  result.x = x;\n  result.y = y;\n  result.z = z;\n  return result;\n};\n\n/**\n * Computes the product of a matrix and a scalar.\n *\n * @param {Matrix4} matrix The matrix.\n * @param {Number} scalar The number to multiply by.\n * @param {Matrix4} result The object onto which to store the result.\n * @returns {Matrix4} The modified result parameter.\n *\n * @example\n * //create a Matrix4 instance which is a scaled version of the supplied Matrix4\n * // m = [10.0, 11.0, 12.0, 13.0]\n * //     [14.0, 15.0, 16.0, 17.0]\n * //     [18.0, 19.0, 20.0, 21.0]\n * //     [22.0, 23.0, 24.0, 25.0]\n *\n * var a = Cesium.Matrix4.multiplyByScalar(m, -2, new Cesium.Matrix4());\n *\n * // m remains the same\n * // a = [-20.0, -22.0, -24.0, -26.0]\n * //     [-28.0, -30.0, -32.0, -34.0]\n * //     [-36.0, -38.0, -40.0, -42.0]\n * //     [-44.0, -46.0, -48.0, -50.0]\n */\nMatrix4.multiplyByScalar = function (matrix, scalar, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.number(\"scalar\", scalar);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result[0] = matrix[0] * scalar;\n  result[1] = matrix[1] * scalar;\n  result[2] = matrix[2] * scalar;\n  result[3] = matrix[3] * scalar;\n  result[4] = matrix[4] * scalar;\n  result[5] = matrix[5] * scalar;\n  result[6] = matrix[6] * scalar;\n  result[7] = matrix[7] * scalar;\n  result[8] = matrix[8] * scalar;\n  result[9] = matrix[9] * scalar;\n  result[10] = matrix[10] * scalar;\n  result[11] = matrix[11] * scalar;\n  result[12] = matrix[12] * scalar;\n  result[13] = matrix[13] * scalar;\n  result[14] = matrix[14] * scalar;\n  result[15] = matrix[15] * scalar;\n  return result;\n};\n\n/**\n * Computes a negated copy of the provided matrix.\n *\n * @param {Matrix4} matrix The matrix to negate.\n * @param {Matrix4} result The object onto which to store the result.\n * @returns {Matrix4} The modified result parameter.\n *\n * @example\n * //create a new Matrix4 instance which is a negation of a Matrix4\n * // m = [10.0, 11.0, 12.0, 13.0]\n * //     [14.0, 15.0, 16.0, 17.0]\n * //     [18.0, 19.0, 20.0, 21.0]\n * //     [22.0, 23.0, 24.0, 25.0]\n *\n * var a = Cesium.Matrix4.negate(m, new Cesium.Matrix4());\n *\n * // m remains the same\n * // a = [-10.0, -11.0, -12.0, -13.0]\n * //     [-14.0, -15.0, -16.0, -17.0]\n * //     [-18.0, -19.0, -20.0, -21.0]\n * //     [-22.0, -23.0, -24.0, -25.0]\n */\nMatrix4.negate = function (matrix, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result[0] = -matrix[0];\n  result[1] = -matrix[1];\n  result[2] = -matrix[2];\n  result[3] = -matrix[3];\n  result[4] = -matrix[4];\n  result[5] = -matrix[5];\n  result[6] = -matrix[6];\n  result[7] = -matrix[7];\n  result[8] = -matrix[8];\n  result[9] = -matrix[9];\n  result[10] = -matrix[10];\n  result[11] = -matrix[11];\n  result[12] = -matrix[12];\n  result[13] = -matrix[13];\n  result[14] = -matrix[14];\n  result[15] = -matrix[15];\n  return result;\n};\n\n/**\n * Computes the transpose of the provided matrix.\n *\n * @param {Matrix4} matrix The matrix to transpose.\n * @param {Matrix4} result The object onto which to store the result.\n * @returns {Matrix4} The modified result parameter.\n *\n * @example\n * //returns transpose of a Matrix4\n * // m = [10.0, 11.0, 12.0, 13.0]\n * //     [14.0, 15.0, 16.0, 17.0]\n * //     [18.0, 19.0, 20.0, 21.0]\n * //     [22.0, 23.0, 24.0, 25.0]\n *\n * var a = Cesium.Matrix4.transpose(m, new Cesium.Matrix4());\n *\n * // m remains the same\n * // a = [10.0, 14.0, 18.0, 22.0]\n * //     [11.0, 15.0, 19.0, 23.0]\n * //     [12.0, 16.0, 20.0, 24.0]\n * //     [13.0, 17.0, 21.0, 25.0]\n */\nMatrix4.transpose = function (matrix, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  var matrix1 = matrix[1];\n  var matrix2 = matrix[2];\n  var matrix3 = matrix[3];\n  var matrix6 = matrix[6];\n  var matrix7 = matrix[7];\n  var matrix11 = matrix[11];\n\n  result[0] = matrix[0];\n  result[1] = matrix[4];\n  result[2] = matrix[8];\n  result[3] = matrix[12];\n  result[4] = matrix1;\n  result[5] = matrix[5];\n  result[6] = matrix[9];\n  result[7] = matrix[13];\n  result[8] = matrix2;\n  result[9] = matrix6;\n  result[10] = matrix[10];\n  result[11] = matrix[14];\n  result[12] = matrix3;\n  result[13] = matrix7;\n  result[14] = matrix11;\n  result[15] = matrix[15];\n  return result;\n};\n\n/**\n * Computes a matrix, which contains the absolute (unsigned) values of the provided matrix's elements.\n *\n * @param {Matrix4} matrix The matrix with signed elements.\n * @param {Matrix4} result The object onto which to store the result.\n * @returns {Matrix4} The modified result parameter.\n */\nMatrix4.abs = function (matrix, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result[0] = Math.abs(matrix[0]);\n  result[1] = Math.abs(matrix[1]);\n  result[2] = Math.abs(matrix[2]);\n  result[3] = Math.abs(matrix[3]);\n  result[4] = Math.abs(matrix[4]);\n  result[5] = Math.abs(matrix[5]);\n  result[6] = Math.abs(matrix[6]);\n  result[7] = Math.abs(matrix[7]);\n  result[8] = Math.abs(matrix[8]);\n  result[9] = Math.abs(matrix[9]);\n  result[10] = Math.abs(matrix[10]);\n  result[11] = Math.abs(matrix[11]);\n  result[12] = Math.abs(matrix[12]);\n  result[13] = Math.abs(matrix[13]);\n  result[14] = Math.abs(matrix[14]);\n  result[15] = Math.abs(matrix[15]);\n\n  return result;\n};\n\n/**\n * Compares the provided matrices componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {Matrix4} [left] The first matrix.\n * @param {Matrix4} [right] The second matrix.\n * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n *\n * @example\n * //compares two Matrix4 instances\n *\n * // a = [10.0, 14.0, 18.0, 22.0]\n * //     [11.0, 15.0, 19.0, 23.0]\n * //     [12.0, 16.0, 20.0, 24.0]\n * //     [13.0, 17.0, 21.0, 25.0]\n *\n * // b = [10.0, 14.0, 18.0, 22.0]\n * //     [11.0, 15.0, 19.0, 23.0]\n * //     [12.0, 16.0, 20.0, 24.0]\n * //     [13.0, 17.0, 21.0, 25.0]\n *\n * if(Cesium.Matrix4.equals(a,b)) {\n *      console.log(\"Both matrices are equal\");\n * } else {\n *      console.log(\"They are not equal\");\n * }\n *\n * //Prints \"Both matrices are equal\" on the console\n */\nMatrix4.equals = function (left, right) {\n  // Given that most matrices will be transformation matrices, the elements\n  // are tested in order such that the test is likely to fail as early\n  // as possible.  I _think_ this is just as friendly to the L1 cache\n  // as testing in index order.  It is certainty faster in practice.\n  return (\n    left === right ||\n    (defined(left) &&\n      defined(right) &&\n      // Translation\n      left[12] === right[12] &&\n      left[13] === right[13] &&\n      left[14] === right[14] &&\n      // Rotation/scale\n      left[0] === right[0] &&\n      left[1] === right[1] &&\n      left[2] === right[2] &&\n      left[4] === right[4] &&\n      left[5] === right[5] &&\n      left[6] === right[6] &&\n      left[8] === right[8] &&\n      left[9] === right[9] &&\n      left[10] === right[10] &&\n      // Bottom row\n      left[3] === right[3] &&\n      left[7] === right[7] &&\n      left[11] === right[11] &&\n      left[15] === right[15])\n  );\n};\n\n/**\n * Compares the provided matrices componentwise and returns\n * <code>true</code> if they are within the provided epsilon,\n * <code>false</code> otherwise.\n *\n * @param {Matrix4} [left] The first matrix.\n * @param {Matrix4} [right] The second matrix.\n * @param {Number} [epsilon=0] The epsilon to use for equality testing.\n * @returns {Boolean} <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.\n *\n * @example\n * //compares two Matrix4 instances\n *\n * // a = [10.5, 14.5, 18.5, 22.5]\n * //     [11.5, 15.5, 19.5, 23.5]\n * //     [12.5, 16.5, 20.5, 24.5]\n * //     [13.5, 17.5, 21.5, 25.5]\n *\n * // b = [10.0, 14.0, 18.0, 22.0]\n * //     [11.0, 15.0, 19.0, 23.0]\n * //     [12.0, 16.0, 20.0, 24.0]\n * //     [13.0, 17.0, 21.0, 25.0]\n *\n * if(Cesium.Matrix4.equalsEpsilon(a,b,0.1)){\n *      console.log(\"Difference between both the matrices is less than 0.1\");\n * } else {\n *      console.log(\"Difference between both the matrices is not less than 0.1\");\n * }\n *\n * //Prints \"Difference between both the matrices is not less than 0.1\" on the console\n */\nMatrix4.equalsEpsilon = function (left, right, epsilon) {\n  epsilon = defaultValue(epsilon, 0);\n\n  return (\n    left === right ||\n    (defined(left) &&\n      defined(right) &&\n      Math.abs(left[0] - right[0]) <= epsilon &&\n      Math.abs(left[1] - right[1]) <= epsilon &&\n      Math.abs(left[2] - right[2]) <= epsilon &&\n      Math.abs(left[3] - right[3]) <= epsilon &&\n      Math.abs(left[4] - right[4]) <= epsilon &&\n      Math.abs(left[5] - right[5]) <= epsilon &&\n      Math.abs(left[6] - right[6]) <= epsilon &&\n      Math.abs(left[7] - right[7]) <= epsilon &&\n      Math.abs(left[8] - right[8]) <= epsilon &&\n      Math.abs(left[9] - right[9]) <= epsilon &&\n      Math.abs(left[10] - right[10]) <= epsilon &&\n      Math.abs(left[11] - right[11]) <= epsilon &&\n      Math.abs(left[12] - right[12]) <= epsilon &&\n      Math.abs(left[13] - right[13]) <= epsilon &&\n      Math.abs(left[14] - right[14]) <= epsilon &&\n      Math.abs(left[15] - right[15]) <= epsilon)\n  );\n};\n\n/**\n * Gets the translation portion of the provided matrix, assuming the matrix is an affine transformation matrix.\n *\n * @param {Matrix4} matrix The matrix to use.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter.\n */\nMatrix4.getTranslation = function (matrix, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = matrix[12];\n  result.y = matrix[13];\n  result.z = matrix[14];\n  return result;\n};\n\n/**\n * Gets the upper left 3x3 matrix of the provided matrix.\n *\n * @param {Matrix4} matrix The matrix to use.\n * @param {Matrix3} result The object onto which to store the result.\n * @returns {Matrix3} The modified result parameter.\n *\n * @example\n * // returns a Matrix3 instance from a Matrix4 instance\n *\n * // m = [10.0, 14.0, 18.0, 22.0]\n * //     [11.0, 15.0, 19.0, 23.0]\n * //     [12.0, 16.0, 20.0, 24.0]\n * //     [13.0, 17.0, 21.0, 25.0]\n *\n * var b = new Cesium.Matrix3();\n * Cesium.Matrix4.getMatrix3(m,b);\n *\n * // b = [10.0, 14.0, 18.0]\n * //     [11.0, 15.0, 19.0]\n * //     [12.0, 16.0, 20.0]\n */\nMatrix4.getMatrix3 = function (matrix, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result[0] = matrix[0];\n  result[1] = matrix[1];\n  result[2] = matrix[2];\n  result[3] = matrix[4];\n  result[4] = matrix[5];\n  result[5] = matrix[6];\n  result[6] = matrix[8];\n  result[7] = matrix[9];\n  result[8] = matrix[10];\n  return result;\n};\n\nvar scratchInverseRotation = new Matrix3();\nvar scratchMatrix3Zero = new Matrix3();\nvar scratchBottomRow = new Cartesian4();\nvar scratchExpectedBottomRow = new Cartesian4(0.0, 0.0, 0.0, 1.0);\n\n/**\n * Computes the inverse of the provided matrix using Cramers Rule.\n * If the determinant is zero, the matrix can not be inverted, and an exception is thrown.\n * If the matrix is a proper rigid transformation, it is more efficient\n * to invert it with {@link Matrix4.inverseTransformation}.\n *\n * @param {Matrix4} matrix The matrix to invert.\n * @param {Matrix4} result The object onto which to store the result.\n * @returns {Matrix4} The modified result parameter.\n *\n * @exception {RuntimeError} matrix is not invertible because its determinate is zero.\n */\nMatrix4.inverse = function (matrix, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n  //\n  // Ported from:\n  //   ftp://download.intel.com/design/PentiumIII/sml/24504301.pdf\n  //\n  var src0 = matrix[0];\n  var src1 = matrix[4];\n  var src2 = matrix[8];\n  var src3 = matrix[12];\n  var src4 = matrix[1];\n  var src5 = matrix[5];\n  var src6 = matrix[9];\n  var src7 = matrix[13];\n  var src8 = matrix[2];\n  var src9 = matrix[6];\n  var src10 = matrix[10];\n  var src11 = matrix[14];\n  var src12 = matrix[3];\n  var src13 = matrix[7];\n  var src14 = matrix[11];\n  var src15 = matrix[15];\n\n  // calculate pairs for first 8 elements (cofactors)\n  var tmp0 = src10 * src15;\n  var tmp1 = src11 * src14;\n  var tmp2 = src9 * src15;\n  var tmp3 = src11 * src13;\n  var tmp4 = src9 * src14;\n  var tmp5 = src10 * src13;\n  var tmp6 = src8 * src15;\n  var tmp7 = src11 * src12;\n  var tmp8 = src8 * src14;\n  var tmp9 = src10 * src12;\n  var tmp10 = src8 * src13;\n  var tmp11 = src9 * src12;\n\n  // calculate first 8 elements (cofactors)\n  var dst0 =\n    tmp0 * src5 +\n    tmp3 * src6 +\n    tmp4 * src7 -\n    (tmp1 * src5 + tmp2 * src6 + tmp5 * src7);\n  var dst1 =\n    tmp1 * src4 +\n    tmp6 * src6 +\n    tmp9 * src7 -\n    (tmp0 * src4 + tmp7 * src6 + tmp8 * src7);\n  var dst2 =\n    tmp2 * src4 +\n    tmp7 * src5 +\n    tmp10 * src7 -\n    (tmp3 * src4 + tmp6 * src5 + tmp11 * src7);\n  var dst3 =\n    tmp5 * src4 +\n    tmp8 * src5 +\n    tmp11 * src6 -\n    (tmp4 * src4 + tmp9 * src5 + tmp10 * src6);\n  var dst4 =\n    tmp1 * src1 +\n    tmp2 * src2 +\n    tmp5 * src3 -\n    (tmp0 * src1 + tmp3 * src2 + tmp4 * src3);\n  var dst5 =\n    tmp0 * src0 +\n    tmp7 * src2 +\n    tmp8 * src3 -\n    (tmp1 * src0 + tmp6 * src2 + tmp9 * src3);\n  var dst6 =\n    tmp3 * src0 +\n    tmp6 * src1 +\n    tmp11 * src3 -\n    (tmp2 * src0 + tmp7 * src1 + tmp10 * src3);\n  var dst7 =\n    tmp4 * src0 +\n    tmp9 * src1 +\n    tmp10 * src2 -\n    (tmp5 * src0 + tmp8 * src1 + tmp11 * src2);\n\n  // calculate pairs for second 8 elements (cofactors)\n  tmp0 = src2 * src7;\n  tmp1 = src3 * src6;\n  tmp2 = src1 * src7;\n  tmp3 = src3 * src5;\n  tmp4 = src1 * src6;\n  tmp5 = src2 * src5;\n  tmp6 = src0 * src7;\n  tmp7 = src3 * src4;\n  tmp8 = src0 * src6;\n  tmp9 = src2 * src4;\n  tmp10 = src0 * src5;\n  tmp11 = src1 * src4;\n\n  // calculate second 8 elements (cofactors)\n  var dst8 =\n    tmp0 * src13 +\n    tmp3 * src14 +\n    tmp4 * src15 -\n    (tmp1 * src13 + tmp2 * src14 + tmp5 * src15);\n  var dst9 =\n    tmp1 * src12 +\n    tmp6 * src14 +\n    tmp9 * src15 -\n    (tmp0 * src12 + tmp7 * src14 + tmp8 * src15);\n  var dst10 =\n    tmp2 * src12 +\n    tmp7 * src13 +\n    tmp10 * src15 -\n    (tmp3 * src12 + tmp6 * src13 + tmp11 * src15);\n  var dst11 =\n    tmp5 * src12 +\n    tmp8 * src13 +\n    tmp11 * src14 -\n    (tmp4 * src12 + tmp9 * src13 + tmp10 * src14);\n  var dst12 =\n    tmp2 * src10 +\n    tmp5 * src11 +\n    tmp1 * src9 -\n    (tmp4 * src11 + tmp0 * src9 + tmp3 * src10);\n  var dst13 =\n    tmp8 * src11 +\n    tmp0 * src8 +\n    tmp7 * src10 -\n    (tmp6 * src10 + tmp9 * src11 + tmp1 * src8);\n  var dst14 =\n    tmp6 * src9 +\n    tmp11 * src11 +\n    tmp3 * src8 -\n    (tmp10 * src11 + tmp2 * src8 + tmp7 * src9);\n  var dst15 =\n    tmp10 * src10 +\n    tmp4 * src8 +\n    tmp9 * src9 -\n    (tmp8 * src9 + tmp11 * src10 + tmp5 * src8);\n\n  // calculate determinant\n  var det = src0 * dst0 + src1 * dst1 + src2 * dst2 + src3 * dst3;\n\n  if (Math.abs(det) < CesiumMath.EPSILON21) {\n    // Special case for a zero scale matrix that can occur, for example,\n    // when a model's node has a [0, 0, 0] scale.\n    if (\n      Matrix3.equalsEpsilon(\n        Matrix4.getMatrix3(matrix, scratchInverseRotation),\n        scratchMatrix3Zero,\n        CesiumMath.EPSILON7\n      ) &&\n      Cartesian4.equals(\n        Matrix4.getRow(matrix, 3, scratchBottomRow),\n        scratchExpectedBottomRow\n      )\n    ) {\n      result[0] = 0.0;\n      result[1] = 0.0;\n      result[2] = 0.0;\n      result[3] = 0.0;\n      result[4] = 0.0;\n      result[5] = 0.0;\n      result[6] = 0.0;\n      result[7] = 0.0;\n      result[8] = 0.0;\n      result[9] = 0.0;\n      result[10] = 0.0;\n      result[11] = 0.0;\n      result[12] = -matrix[12];\n      result[13] = -matrix[13];\n      result[14] = -matrix[14];\n      result[15] = 1.0;\n      return result;\n    }\n\n    throw new RuntimeError(\n      \"matrix is not invertible because its determinate is zero.\"\n    );\n  }\n\n  // calculate matrix inverse\n  det = 1.0 / det;\n\n  result[0] = dst0 * det;\n  result[1] = dst1 * det;\n  result[2] = dst2 * det;\n  result[3] = dst3 * det;\n  result[4] = dst4 * det;\n  result[5] = dst5 * det;\n  result[6] = dst6 * det;\n  result[7] = dst7 * det;\n  result[8] = dst8 * det;\n  result[9] = dst9 * det;\n  result[10] = dst10 * det;\n  result[11] = dst11 * det;\n  result[12] = dst12 * det;\n  result[13] = dst13 * det;\n  result[14] = dst14 * det;\n  result[15] = dst15 * det;\n  return result;\n};\n\n/**\n * Computes the inverse of the provided matrix assuming it is a proper rigid matrix,\n * where the upper left 3x3 elements are a rotation matrix,\n * and the upper three elements in the fourth column are the translation.\n * The bottom row is assumed to be [0, 0, 0, 1].\n * The matrix is not verified to be in the proper form.\n * This method is faster than computing the inverse for a general 4x4\n * matrix using {@link Matrix4.inverse}.\n *\n * @param {Matrix4} matrix The matrix to invert.\n * @param {Matrix4} result The object onto which to store the result.\n * @returns {Matrix4} The modified result parameter.\n */\nMatrix4.inverseTransformation = function (matrix, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  //This function is an optimized version of the below 4 lines.\n  //var rT = Matrix3.transpose(Matrix4.getMatrix3(matrix));\n  //var rTN = Matrix3.negate(rT);\n  //var rTT = Matrix3.multiplyByVector(rTN, Matrix4.getTranslation(matrix));\n  //return Matrix4.fromRotationTranslation(rT, rTT, result);\n\n  var matrix0 = matrix[0];\n  var matrix1 = matrix[1];\n  var matrix2 = matrix[2];\n  var matrix4 = matrix[4];\n  var matrix5 = matrix[5];\n  var matrix6 = matrix[6];\n  var matrix8 = matrix[8];\n  var matrix9 = matrix[9];\n  var matrix10 = matrix[10];\n\n  var vX = matrix[12];\n  var vY = matrix[13];\n  var vZ = matrix[14];\n\n  var x = -matrix0 * vX - matrix1 * vY - matrix2 * vZ;\n  var y = -matrix4 * vX - matrix5 * vY - matrix6 * vZ;\n  var z = -matrix8 * vX - matrix9 * vY - matrix10 * vZ;\n\n  result[0] = matrix0;\n  result[1] = matrix4;\n  result[2] = matrix8;\n  result[3] = 0.0;\n  result[4] = matrix1;\n  result[5] = matrix5;\n  result[6] = matrix9;\n  result[7] = 0.0;\n  result[8] = matrix2;\n  result[9] = matrix6;\n  result[10] = matrix10;\n  result[11] = 0.0;\n  result[12] = x;\n  result[13] = y;\n  result[14] = z;\n  result[15] = 1.0;\n  return result;\n};\n\nvar scratchTransposeMatrix = new Matrix4();\n\n/**\n * Computes the inverse transpose of a matrix.\n *\n * @param {Matrix4} matrix The matrix to transpose and invert.\n * @param {Matrix4} result The object onto which to store the result.\n * @returns {Matrix4} The modified result parameter.\n */\nMatrix4.inverseTranspose = function (matrix, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  return Matrix4.inverse(\n    Matrix4.transpose(matrix, scratchTransposeMatrix),\n    result\n  );\n};\n\n/**\n * An immutable Matrix4 instance initialized to the identity matrix.\n *\n * @type {Matrix4}\n * @constant\n */\nMatrix4.IDENTITY = Object.freeze(\n  new Matrix4(\n    1.0,\n    0.0,\n    0.0,\n    0.0,\n    0.0,\n    1.0,\n    0.0,\n    0.0,\n    0.0,\n    0.0,\n    1.0,\n    0.0,\n    0.0,\n    0.0,\n    0.0,\n    1.0\n  )\n);\n\n/**\n * An immutable Matrix4 instance initialized to the zero matrix.\n *\n * @type {Matrix4}\n * @constant\n */\nMatrix4.ZERO = Object.freeze(\n  new Matrix4(\n    0.0,\n    0.0,\n    0.0,\n    0.0,\n    0.0,\n    0.0,\n    0.0,\n    0.0,\n    0.0,\n    0.0,\n    0.0,\n    0.0,\n    0.0,\n    0.0,\n    0.0,\n    0.0\n  )\n);\n\n/**\n * The index into Matrix4 for column 0, row 0.\n *\n * @type {Number}\n * @constant\n */\nMatrix4.COLUMN0ROW0 = 0;\n\n/**\n * The index into Matrix4 for column 0, row 1.\n *\n * @type {Number}\n * @constant\n */\nMatrix4.COLUMN0ROW1 = 1;\n\n/**\n * The index into Matrix4 for column 0, row 2.\n *\n * @type {Number}\n * @constant\n */\nMatrix4.COLUMN0ROW2 = 2;\n\n/**\n * The index into Matrix4 for column 0, row 3.\n *\n * @type {Number}\n * @constant\n */\nMatrix4.COLUMN0ROW3 = 3;\n\n/**\n * The index into Matrix4 for column 1, row 0.\n *\n * @type {Number}\n * @constant\n */\nMatrix4.COLUMN1ROW0 = 4;\n\n/**\n * The index into Matrix4 for column 1, row 1.\n *\n * @type {Number}\n * @constant\n */\nMatrix4.COLUMN1ROW1 = 5;\n\n/**\n * The index into Matrix4 for column 1, row 2.\n *\n * @type {Number}\n * @constant\n */\nMatrix4.COLUMN1ROW2 = 6;\n\n/**\n * The index into Matrix4 for column 1, row 3.\n *\n * @type {Number}\n * @constant\n */\nMatrix4.COLUMN1ROW3 = 7;\n\n/**\n * The index into Matrix4 for column 2, row 0.\n *\n * @type {Number}\n * @constant\n */\nMatrix4.COLUMN2ROW0 = 8;\n\n/**\n * The index into Matrix4 for column 2, row 1.\n *\n * @type {Number}\n * @constant\n */\nMatrix4.COLUMN2ROW1 = 9;\n\n/**\n * The index into Matrix4 for column 2, row 2.\n *\n * @type {Number}\n * @constant\n */\nMatrix4.COLUMN2ROW2 = 10;\n\n/**\n * The index into Matrix4 for column 2, row 3.\n *\n * @type {Number}\n * @constant\n */\nMatrix4.COLUMN2ROW3 = 11;\n\n/**\n * The index into Matrix4 for column 3, row 0.\n *\n * @type {Number}\n * @constant\n */\nMatrix4.COLUMN3ROW0 = 12;\n\n/**\n * The index into Matrix4 for column 3, row 1.\n *\n * @type {Number}\n * @constant\n */\nMatrix4.COLUMN3ROW1 = 13;\n\n/**\n * The index into Matrix4 for column 3, row 2.\n *\n * @type {Number}\n * @constant\n */\nMatrix4.COLUMN3ROW2 = 14;\n\n/**\n * The index into Matrix4 for column 3, row 3.\n *\n * @type {Number}\n * @constant\n */\nMatrix4.COLUMN3ROW3 = 15;\n\nObject.defineProperties(Matrix4.prototype, {\n  /**\n   * Gets the number of items in the collection.\n   * @memberof Matrix4.prototype\n   *\n   * @type {Number}\n   */\n  length: {\n    get: function () {\n      return Matrix4.packedLength;\n    },\n  },\n});\n\n/**\n * Duplicates the provided Matrix4 instance.\n *\n * @param {Matrix4} [result] The object onto which to store the result.\n * @returns {Matrix4} The modified result parameter or a new Matrix4 instance if one was not provided.\n */\nMatrix4.prototype.clone = function (result) {\n  return Matrix4.clone(this, result);\n};\n\n/**\n * Compares this matrix to the provided matrix componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {Matrix4} [right] The right hand side matrix.\n * @returns {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.\n */\nMatrix4.prototype.equals = function (right) {\n  return Matrix4.equals(this, right);\n};\n\n/**\n * @private\n */\nMatrix4.equalsArray = function (matrix, array, offset) {\n  return (\n    matrix[0] === array[offset] &&\n    matrix[1] === array[offset + 1] &&\n    matrix[2] === array[offset + 2] &&\n    matrix[3] === array[offset + 3] &&\n    matrix[4] === array[offset + 4] &&\n    matrix[5] === array[offset + 5] &&\n    matrix[6] === array[offset + 6] &&\n    matrix[7] === array[offset + 7] &&\n    matrix[8] === array[offset + 8] &&\n    matrix[9] === array[offset + 9] &&\n    matrix[10] === array[offset + 10] &&\n    matrix[11] === array[offset + 11] &&\n    matrix[12] === array[offset + 12] &&\n    matrix[13] === array[offset + 13] &&\n    matrix[14] === array[offset + 14] &&\n    matrix[15] === array[offset + 15]\n  );\n};\n\n/**\n * Compares this matrix to the provided matrix componentwise and returns\n * <code>true</code> if they are within the provided epsilon,\n * <code>false</code> otherwise.\n *\n * @param {Matrix4} [right] The right hand side matrix.\n * @param {Number} [epsilon=0] The epsilon to use for equality testing.\n * @returns {Boolean} <code>true</code> if they are within the provided epsilon, <code>false</code> otherwise.\n */\nMatrix4.prototype.equalsEpsilon = function (right, epsilon) {\n  return Matrix4.equalsEpsilon(this, right, epsilon);\n};\n\n/**\n * Computes a string representing this Matrix with each row being\n * on a separate line and in the format '(column0, column1, column2, column3)'.\n *\n * @returns {String} A string representing the provided Matrix with each row being on a separate line and in the format '(column0, column1, column2, column3)'.\n */\nMatrix4.prototype.toString = function () {\n  return (\n    \"(\" +\n    this[0] +\n    \", \" +\n    this[4] +\n    \", \" +\n    this[8] +\n    \", \" +\n    this[12] +\n    \")\\n\" +\n    \"(\" +\n    this[1] +\n    \", \" +\n    this[5] +\n    \", \" +\n    this[9] +\n    \", \" +\n    this[13] +\n    \")\\n\" +\n    \"(\" +\n    this[2] +\n    \", \" +\n    this[6] +\n    \", \" +\n    this[10] +\n    \", \" +\n    this[14] +\n    \")\\n\" +\n    \"(\" +\n    this[3] +\n    \", \" +\n    this[7] +\n    \", \" +\n    this[11] +\n    \", \" +\n    this[15] +\n    \")\"\n  );\n};\nexport default Matrix4;\n","import Cartographic from \"./Cartographic.js\";\nimport Check from \"./Check.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport CesiumMath from \"./Math.js\";\n\n/**\n * A two dimensional region specified as longitude and latitude coordinates.\n *\n * @alias Rectangle\n * @constructor\n *\n * @param {Number} [west=0.0] The westernmost longitude, in radians, in the range [-Pi, Pi].\n * @param {Number} [south=0.0] The southernmost latitude, in radians, in the range [-Pi/2, Pi/2].\n * @param {Number} [east=0.0] The easternmost longitude, in radians, in the range [-Pi, Pi].\n * @param {Number} [north=0.0] The northernmost latitude, in radians, in the range [-Pi/2, Pi/2].\n *\n * @see Packable\n */\nfunction Rectangle(west, south, east, north) {\n  /**\n   * The westernmost longitude in radians in the range [-Pi, Pi].\n   *\n   * @type {Number}\n   * @default 0.0\n   */\n  this.west = defaultValue(west, 0.0);\n\n  /**\n   * The southernmost latitude in radians in the range [-Pi/2, Pi/2].\n   *\n   * @type {Number}\n   * @default 0.0\n   */\n  this.south = defaultValue(south, 0.0);\n\n  /**\n   * The easternmost longitude in radians in the range [-Pi, Pi].\n   *\n   * @type {Number}\n   * @default 0.0\n   */\n  this.east = defaultValue(east, 0.0);\n\n  /**\n   * The northernmost latitude in radians in the range [-Pi/2, Pi/2].\n   *\n   * @type {Number}\n   * @default 0.0\n   */\n  this.north = defaultValue(north, 0.0);\n}\n\nObject.defineProperties(Rectangle.prototype, {\n  /**\n   * Gets the width of the rectangle in radians.\n   * @memberof Rectangle.prototype\n   * @type {Number}\n   * @readonly\n   */\n  width: {\n    get: function () {\n      return Rectangle.computeWidth(this);\n    },\n  },\n\n  /**\n   * Gets the height of the rectangle in radians.\n   * @memberof Rectangle.prototype\n   * @type {Number}\n   * @readonly\n   */\n  height: {\n    get: function () {\n      return Rectangle.computeHeight(this);\n    },\n  },\n});\n\n/**\n * The number of elements used to pack the object into an array.\n * @type {Number}\n */\nRectangle.packedLength = 4;\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {Rectangle} value The value to pack.\n * @param {Number[]} array The array to pack into.\n * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {Number[]} The array that was packed into\n */\nRectangle.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"value\", value);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  array[startingIndex++] = value.west;\n  array[startingIndex++] = value.south;\n  array[startingIndex++] = value.east;\n  array[startingIndex] = value.north;\n\n  return array;\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {Number[]} array The packed array.\n * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {Rectangle} [result] The object into which to store the result.\n * @returns {Rectangle} The modified result parameter or a new Rectangle instance if one was not provided.\n */\nRectangle.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  if (!defined(result)) {\n    result = new Rectangle();\n  }\n\n  result.west = array[startingIndex++];\n  result.south = array[startingIndex++];\n  result.east = array[startingIndex++];\n  result.north = array[startingIndex];\n  return result;\n};\n\n/**\n * Computes the width of a rectangle in radians.\n * @param {Rectangle} rectangle The rectangle to compute the width of.\n * @returns {Number} The width.\n */\nRectangle.computeWidth = function (rectangle) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"rectangle\", rectangle);\n  //>>includeEnd('debug');\n  var east = rectangle.east;\n  var west = rectangle.west;\n  if (east < west) {\n    east += CesiumMath.TWO_PI;\n  }\n  return east - west;\n};\n\n/**\n * Computes the height of a rectangle in radians.\n * @param {Rectangle} rectangle The rectangle to compute the height of.\n * @returns {Number} The height.\n */\nRectangle.computeHeight = function (rectangle) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"rectangle\", rectangle);\n  //>>includeEnd('debug');\n  return rectangle.north - rectangle.south;\n};\n\n/**\n * Creates a rectangle given the boundary longitude and latitude in degrees.\n *\n * @param {Number} [west=0.0] The westernmost longitude in degrees in the range [-180.0, 180.0].\n * @param {Number} [south=0.0] The southernmost latitude in degrees in the range [-90.0, 90.0].\n * @param {Number} [east=0.0] The easternmost longitude in degrees in the range [-180.0, 180.0].\n * @param {Number} [north=0.0] The northernmost latitude in degrees in the range [-90.0, 90.0].\n * @param {Rectangle} [result] The object onto which to store the result, or undefined if a new instance should be created.\n * @returns {Rectangle} The modified result parameter or a new Rectangle instance if none was provided.\n *\n * @example\n * var rectangle = Cesium.Rectangle.fromDegrees(0.0, 20.0, 10.0, 30.0);\n */\nRectangle.fromDegrees = function (west, south, east, north, result) {\n  west = CesiumMath.toRadians(defaultValue(west, 0.0));\n  south = CesiumMath.toRadians(defaultValue(south, 0.0));\n  east = CesiumMath.toRadians(defaultValue(east, 0.0));\n  north = CesiumMath.toRadians(defaultValue(north, 0.0));\n\n  if (!defined(result)) {\n    return new Rectangle(west, south, east, north);\n  }\n\n  result.west = west;\n  result.south = south;\n  result.east = east;\n  result.north = north;\n\n  return result;\n};\n\n/**\n * Creates a rectangle given the boundary longitude and latitude in radians.\n *\n * @param {Number} [west=0.0] The westernmost longitude in radians in the range [-Math.PI, Math.PI].\n * @param {Number} [south=0.0] The southernmost latitude in radians in the range [-Math.PI/2, Math.PI/2].\n * @param {Number} [east=0.0] The easternmost longitude in radians in the range [-Math.PI, Math.PI].\n * @param {Number} [north=0.0] The northernmost latitude in radians in the range [-Math.PI/2, Math.PI/2].\n * @param {Rectangle} [result] The object onto which to store the result, or undefined if a new instance should be created.\n * @returns {Rectangle} The modified result parameter or a new Rectangle instance if none was provided.\n *\n * @example\n * var rectangle = Cesium.Rectangle.fromRadians(0.0, Math.PI/4, Math.PI/8, 3*Math.PI/4);\n */\nRectangle.fromRadians = function (west, south, east, north, result) {\n  if (!defined(result)) {\n    return new Rectangle(west, south, east, north);\n  }\n\n  result.west = defaultValue(west, 0.0);\n  result.south = defaultValue(south, 0.0);\n  result.east = defaultValue(east, 0.0);\n  result.north = defaultValue(north, 0.0);\n\n  return result;\n};\n\n/**\n * Creates the smallest possible Rectangle that encloses all positions in the provided array.\n *\n * @param {Cartographic[]} cartographics The list of Cartographic instances.\n * @param {Rectangle} [result] The object onto which to store the result, or undefined if a new instance should be created.\n * @returns {Rectangle} The modified result parameter or a new Rectangle instance if none was provided.\n */\nRectangle.fromCartographicArray = function (cartographics, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"cartographics\", cartographics);\n  //>>includeEnd('debug');\n\n  var west = Number.MAX_VALUE;\n  var east = -Number.MAX_VALUE;\n  var westOverIDL = Number.MAX_VALUE;\n  var eastOverIDL = -Number.MAX_VALUE;\n  var south = Number.MAX_VALUE;\n  var north = -Number.MAX_VALUE;\n\n  for (var i = 0, len = cartographics.length; i < len; i++) {\n    var position = cartographics[i];\n    west = Math.min(west, position.longitude);\n    east = Math.max(east, position.longitude);\n    south = Math.min(south, position.latitude);\n    north = Math.max(north, position.latitude);\n\n    var lonAdjusted =\n      position.longitude >= 0\n        ? position.longitude\n        : position.longitude + CesiumMath.TWO_PI;\n    westOverIDL = Math.min(westOverIDL, lonAdjusted);\n    eastOverIDL = Math.max(eastOverIDL, lonAdjusted);\n  }\n\n  if (east - west > eastOverIDL - westOverIDL) {\n    west = westOverIDL;\n    east = eastOverIDL;\n\n    if (east > CesiumMath.PI) {\n      east = east - CesiumMath.TWO_PI;\n    }\n    if (west > CesiumMath.PI) {\n      west = west - CesiumMath.TWO_PI;\n    }\n  }\n\n  if (!defined(result)) {\n    return new Rectangle(west, south, east, north);\n  }\n\n  result.west = west;\n  result.south = south;\n  result.east = east;\n  result.north = north;\n  return result;\n};\n\n/**\n * Creates the smallest possible Rectangle that encloses all positions in the provided array.\n *\n * @param {Cartesian3[]} cartesians The list of Cartesian instances.\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid the cartesians are on.\n * @param {Rectangle} [result] The object onto which to store the result, or undefined if a new instance should be created.\n * @returns {Rectangle} The modified result parameter or a new Rectangle instance if none was provided.\n */\nRectangle.fromCartesianArray = function (cartesians, ellipsoid, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"cartesians\", cartesians);\n  //>>includeEnd('debug');\n  ellipsoid = defaultValue(ellipsoid, Ellipsoid.WGS84);\n\n  var west = Number.MAX_VALUE;\n  var east = -Number.MAX_VALUE;\n  var westOverIDL = Number.MAX_VALUE;\n  var eastOverIDL = -Number.MAX_VALUE;\n  var south = Number.MAX_VALUE;\n  var north = -Number.MAX_VALUE;\n\n  for (var i = 0, len = cartesians.length; i < len; i++) {\n    var position = ellipsoid.cartesianToCartographic(cartesians[i]);\n    west = Math.min(west, position.longitude);\n    east = Math.max(east, position.longitude);\n    south = Math.min(south, position.latitude);\n    north = Math.max(north, position.latitude);\n\n    var lonAdjusted =\n      position.longitude >= 0\n        ? position.longitude\n        : position.longitude + CesiumMath.TWO_PI;\n    westOverIDL = Math.min(westOverIDL, lonAdjusted);\n    eastOverIDL = Math.max(eastOverIDL, lonAdjusted);\n  }\n\n  if (east - west > eastOverIDL - westOverIDL) {\n    west = westOverIDL;\n    east = eastOverIDL;\n\n    if (east > CesiumMath.PI) {\n      east = east - CesiumMath.TWO_PI;\n    }\n    if (west > CesiumMath.PI) {\n      west = west - CesiumMath.TWO_PI;\n    }\n  }\n\n  if (!defined(result)) {\n    return new Rectangle(west, south, east, north);\n  }\n\n  result.west = west;\n  result.south = south;\n  result.east = east;\n  result.north = north;\n  return result;\n};\n\n/**\n * Duplicates a Rectangle.\n *\n * @param {Rectangle} rectangle The rectangle to clone.\n * @param {Rectangle} [result] The object onto which to store the result, or undefined if a new instance should be created.\n * @returns {Rectangle} The modified result parameter or a new Rectangle instance if none was provided. (Returns undefined if rectangle is undefined)\n */\nRectangle.clone = function (rectangle, result) {\n  if (!defined(rectangle)) {\n    return undefined;\n  }\n\n  if (!defined(result)) {\n    return new Rectangle(\n      rectangle.west,\n      rectangle.south,\n      rectangle.east,\n      rectangle.north\n    );\n  }\n\n  result.west = rectangle.west;\n  result.south = rectangle.south;\n  result.east = rectangle.east;\n  result.north = rectangle.north;\n  return result;\n};\n\n/**\n * Compares the provided Rectangles componentwise and returns\n * <code>true</code> if they pass an absolute or relative tolerance test,\n * <code>false</code> otherwise.\n *\n * @param {Rectangle} [left] The first Rectangle.\n * @param {Rectangle} [right] The second Rectangle.\n * @param {Number} [absoluteEpsilon=0] The absolute epsilon tolerance to use for equality testing.\n * @returns {Boolean} <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.\n */\nRectangle.equalsEpsilon = function (left, right, absoluteEpsilon) {\n  absoluteEpsilon = defaultValue(absoluteEpsilon, 0);\n\n  return (\n    left === right ||\n    (defined(left) &&\n      defined(right) &&\n      Math.abs(left.west - right.west) <= absoluteEpsilon &&\n      Math.abs(left.south - right.south) <= absoluteEpsilon &&\n      Math.abs(left.east - right.east) <= absoluteEpsilon &&\n      Math.abs(left.north - right.north) <= absoluteEpsilon)\n  );\n};\n\n/**\n * Duplicates this Rectangle.\n *\n * @param {Rectangle} [result] The object onto which to store the result.\n * @returns {Rectangle} The modified result parameter or a new Rectangle instance if none was provided.\n */\nRectangle.prototype.clone = function (result) {\n  return Rectangle.clone(this, result);\n};\n\n/**\n * Compares the provided Rectangle with this Rectangle componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {Rectangle} [other] The Rectangle to compare.\n * @returns {Boolean} <code>true</code> if the Rectangles are equal, <code>false</code> otherwise.\n */\nRectangle.prototype.equals = function (other) {\n  return Rectangle.equals(this, other);\n};\n\n/**\n * Compares the provided rectangles and returns <code>true</code> if they are equal,\n * <code>false</code> otherwise.\n *\n * @param {Rectangle} [left] The first Rectangle.\n * @param {Rectangle} [right] The second Rectangle.\n * @returns {Boolean} <code>true</code> if left and right are equal; otherwise <code>false</code>.\n */\nRectangle.equals = function (left, right) {\n  return (\n    left === right ||\n    (defined(left) &&\n      defined(right) &&\n      left.west === right.west &&\n      left.south === right.south &&\n      left.east === right.east &&\n      left.north === right.north)\n  );\n};\n\n/**\n * Compares the provided Rectangle with this Rectangle componentwise and returns\n * <code>true</code> if they are within the provided epsilon,\n * <code>false</code> otherwise.\n *\n * @param {Rectangle} [other] The Rectangle to compare.\n * @param {Number} [epsilon=0] The epsilon to use for equality testing.\n * @returns {Boolean} <code>true</code> if the Rectangles are within the provided epsilon, <code>false</code> otherwise.\n */\nRectangle.prototype.equalsEpsilon = function (other, epsilon) {\n  return Rectangle.equalsEpsilon(this, other, epsilon);\n};\n\n/**\n * Checks a Rectangle's properties and throws if they are not in valid ranges.\n *\n * @param {Rectangle} rectangle The rectangle to validate\n *\n * @exception {DeveloperError} <code>north</code> must be in the interval [<code>-Pi/2</code>, <code>Pi/2</code>].\n * @exception {DeveloperError} <code>south</code> must be in the interval [<code>-Pi/2</code>, <code>Pi/2</code>].\n * @exception {DeveloperError} <code>east</code> must be in the interval [<code>-Pi</code>, <code>Pi</code>].\n * @exception {DeveloperError} <code>west</code> must be in the interval [<code>-Pi</code>, <code>Pi</code>].\n */\nRectangle.validate = function (rectangle) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"rectangle\", rectangle);\n\n  var north = rectangle.north;\n  Check.typeOf.number.greaterThanOrEquals(\n    \"north\",\n    north,\n    -CesiumMath.PI_OVER_TWO\n  );\n  Check.typeOf.number.lessThanOrEquals(\"north\", north, CesiumMath.PI_OVER_TWO);\n\n  var south = rectangle.south;\n  Check.typeOf.number.greaterThanOrEquals(\n    \"south\",\n    south,\n    -CesiumMath.PI_OVER_TWO\n  );\n  Check.typeOf.number.lessThanOrEquals(\"south\", south, CesiumMath.PI_OVER_TWO);\n\n  var west = rectangle.west;\n  Check.typeOf.number.greaterThanOrEquals(\"west\", west, -Math.PI);\n  Check.typeOf.number.lessThanOrEquals(\"west\", west, Math.PI);\n\n  var east = rectangle.east;\n  Check.typeOf.number.greaterThanOrEquals(\"east\", east, -Math.PI);\n  Check.typeOf.number.lessThanOrEquals(\"east\", east, Math.PI);\n  //>>includeEnd('debug');\n};\n\n/**\n * Computes the southwest corner of a rectangle.\n *\n * @param {Rectangle} rectangle The rectangle for which to find the corner\n * @param {Cartographic} [result] The object onto which to store the result.\n * @returns {Cartographic} The modified result parameter or a new Cartographic instance if none was provided.\n */\nRectangle.southwest = function (rectangle, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"rectangle\", rectangle);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    return new Cartographic(rectangle.west, rectangle.south);\n  }\n  result.longitude = rectangle.west;\n  result.latitude = rectangle.south;\n  result.height = 0.0;\n  return result;\n};\n\n/**\n * Computes the northwest corner of a rectangle.\n *\n * @param {Rectangle} rectangle The rectangle for which to find the corner\n * @param {Cartographic} [result] The object onto which to store the result.\n * @returns {Cartographic} The modified result parameter or a new Cartographic instance if none was provided.\n */\nRectangle.northwest = function (rectangle, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"rectangle\", rectangle);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    return new Cartographic(rectangle.west, rectangle.north);\n  }\n  result.longitude = rectangle.west;\n  result.latitude = rectangle.north;\n  result.height = 0.0;\n  return result;\n};\n\n/**\n * Computes the northeast corner of a rectangle.\n *\n * @param {Rectangle} rectangle The rectangle for which to find the corner\n * @param {Cartographic} [result] The object onto which to store the result.\n * @returns {Cartographic} The modified result parameter or a new Cartographic instance if none was provided.\n */\nRectangle.northeast = function (rectangle, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"rectangle\", rectangle);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    return new Cartographic(rectangle.east, rectangle.north);\n  }\n  result.longitude = rectangle.east;\n  result.latitude = rectangle.north;\n  result.height = 0.0;\n  return result;\n};\n\n/**\n * Computes the southeast corner of a rectangle.\n *\n * @param {Rectangle} rectangle The rectangle for which to find the corner\n * @param {Cartographic} [result] The object onto which to store the result.\n * @returns {Cartographic} The modified result parameter or a new Cartographic instance if none was provided.\n */\nRectangle.southeast = function (rectangle, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"rectangle\", rectangle);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    return new Cartographic(rectangle.east, rectangle.south);\n  }\n  result.longitude = rectangle.east;\n  result.latitude = rectangle.south;\n  result.height = 0.0;\n  return result;\n};\n\n/**\n * Computes the center of a rectangle.\n *\n * @param {Rectangle} rectangle The rectangle for which to find the center\n * @param {Cartographic} [result] The object onto which to store the result.\n * @returns {Cartographic} The modified result parameter or a new Cartographic instance if none was provided.\n */\nRectangle.center = function (rectangle, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"rectangle\", rectangle);\n  //>>includeEnd('debug');\n\n  var east = rectangle.east;\n  var west = rectangle.west;\n\n  if (east < west) {\n    east += CesiumMath.TWO_PI;\n  }\n\n  var longitude = CesiumMath.negativePiToPi((west + east) * 0.5);\n  var latitude = (rectangle.south + rectangle.north) * 0.5;\n\n  if (!defined(result)) {\n    return new Cartographic(longitude, latitude);\n  }\n\n  result.longitude = longitude;\n  result.latitude = latitude;\n  result.height = 0.0;\n  return result;\n};\n\n/**\n * Computes the intersection of two rectangles.  This function assumes that the rectangle's coordinates are\n * latitude and longitude in radians and produces a correct intersection, taking into account the fact that\n * the same angle can be represented with multiple values as well as the wrapping of longitude at the\n * anti-meridian.  For a simple intersection that ignores these factors and can be used with projected\n * coordinates, see {@link Rectangle.simpleIntersection}.\n *\n * @param {Rectangle} rectangle On rectangle to find an intersection\n * @param {Rectangle} otherRectangle Another rectangle to find an intersection\n * @param {Rectangle} [result] The object onto which to store the result.\n * @returns {Rectangle|undefined} The modified result parameter, a new Rectangle instance if none was provided or undefined if there is no intersection.\n */\nRectangle.intersection = function (rectangle, otherRectangle, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"rectangle\", rectangle);\n  Check.typeOf.object(\"otherRectangle\", otherRectangle);\n  //>>includeEnd('debug');\n\n  var rectangleEast = rectangle.east;\n  var rectangleWest = rectangle.west;\n\n  var otherRectangleEast = otherRectangle.east;\n  var otherRectangleWest = otherRectangle.west;\n\n  if (rectangleEast < rectangleWest && otherRectangleEast > 0.0) {\n    rectangleEast += CesiumMath.TWO_PI;\n  } else if (otherRectangleEast < otherRectangleWest && rectangleEast > 0.0) {\n    otherRectangleEast += CesiumMath.TWO_PI;\n  }\n\n  if (rectangleEast < rectangleWest && otherRectangleWest < 0.0) {\n    otherRectangleWest += CesiumMath.TWO_PI;\n  } else if (otherRectangleEast < otherRectangleWest && rectangleWest < 0.0) {\n    rectangleWest += CesiumMath.TWO_PI;\n  }\n\n  var west = CesiumMath.negativePiToPi(\n    Math.max(rectangleWest, otherRectangleWest)\n  );\n  var east = CesiumMath.negativePiToPi(\n    Math.min(rectangleEast, otherRectangleEast)\n  );\n\n  if (\n    (rectangle.west < rectangle.east ||\n      otherRectangle.west < otherRectangle.east) &&\n    east <= west\n  ) {\n    return undefined;\n  }\n\n  var south = Math.max(rectangle.south, otherRectangle.south);\n  var north = Math.min(rectangle.north, otherRectangle.north);\n\n  if (south >= north) {\n    return undefined;\n  }\n\n  if (!defined(result)) {\n    return new Rectangle(west, south, east, north);\n  }\n  result.west = west;\n  result.south = south;\n  result.east = east;\n  result.north = north;\n  return result;\n};\n\n/**\n * Computes a simple intersection of two rectangles.  Unlike {@link Rectangle.intersection}, this function\n * does not attempt to put the angular coordinates into a consistent range or to account for crossing the\n * anti-meridian.  As such, it can be used for rectangles where the coordinates are not simply latitude\n * and longitude (i.e. projected coordinates).\n *\n * @param {Rectangle} rectangle On rectangle to find an intersection\n * @param {Rectangle} otherRectangle Another rectangle to find an intersection\n * @param {Rectangle} [result] The object onto which to store the result.\n * @returns {Rectangle|undefined} The modified result parameter, a new Rectangle instance if none was provided or undefined if there is no intersection.\n */\nRectangle.simpleIntersection = function (rectangle, otherRectangle, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"rectangle\", rectangle);\n  Check.typeOf.object(\"otherRectangle\", otherRectangle);\n  //>>includeEnd('debug');\n\n  var west = Math.max(rectangle.west, otherRectangle.west);\n  var south = Math.max(rectangle.south, otherRectangle.south);\n  var east = Math.min(rectangle.east, otherRectangle.east);\n  var north = Math.min(rectangle.north, otherRectangle.north);\n\n  if (south >= north || west >= east) {\n    return undefined;\n  }\n\n  if (!defined(result)) {\n    return new Rectangle(west, south, east, north);\n  }\n\n  result.west = west;\n  result.south = south;\n  result.east = east;\n  result.north = north;\n  return result;\n};\n\n/**\n * Computes a rectangle that is the union of two rectangles.\n *\n * @param {Rectangle} rectangle A rectangle to enclose in rectangle.\n * @param {Rectangle} otherRectangle A rectangle to enclose in a rectangle.\n * @param {Rectangle} [result] The object onto which to store the result.\n * @returns {Rectangle} The modified result parameter or a new Rectangle instance if none was provided.\n */\nRectangle.union = function (rectangle, otherRectangle, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"rectangle\", rectangle);\n  Check.typeOf.object(\"otherRectangle\", otherRectangle);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Rectangle();\n  }\n\n  var rectangleEast = rectangle.east;\n  var rectangleWest = rectangle.west;\n\n  var otherRectangleEast = otherRectangle.east;\n  var otherRectangleWest = otherRectangle.west;\n\n  if (rectangleEast < rectangleWest && otherRectangleEast > 0.0) {\n    rectangleEast += CesiumMath.TWO_PI;\n  } else if (otherRectangleEast < otherRectangleWest && rectangleEast > 0.0) {\n    otherRectangleEast += CesiumMath.TWO_PI;\n  }\n\n  if (rectangleEast < rectangleWest && otherRectangleWest < 0.0) {\n    otherRectangleWest += CesiumMath.TWO_PI;\n  } else if (otherRectangleEast < otherRectangleWest && rectangleWest < 0.0) {\n    rectangleWest += CesiumMath.TWO_PI;\n  }\n\n  var west = CesiumMath.negativePiToPi(\n    Math.min(rectangleWest, otherRectangleWest)\n  );\n  var east = CesiumMath.negativePiToPi(\n    Math.max(rectangleEast, otherRectangleEast)\n  );\n\n  result.west = west;\n  result.south = Math.min(rectangle.south, otherRectangle.south);\n  result.east = east;\n  result.north = Math.max(rectangle.north, otherRectangle.north);\n\n  return result;\n};\n\n/**\n * Computes a rectangle by enlarging the provided rectangle until it contains the provided cartographic.\n *\n * @param {Rectangle} rectangle A rectangle to expand.\n * @param {Cartographic} cartographic A cartographic to enclose in a rectangle.\n * @param {Rectangle} [result] The object onto which to store the result.\n * @returns {Rectangle} The modified result parameter or a new Rectangle instance if one was not provided.\n */\nRectangle.expand = function (rectangle, cartographic, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"rectangle\", rectangle);\n  Check.typeOf.object(\"cartographic\", cartographic);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Rectangle();\n  }\n\n  result.west = Math.min(rectangle.west, cartographic.longitude);\n  result.south = Math.min(rectangle.south, cartographic.latitude);\n  result.east = Math.max(rectangle.east, cartographic.longitude);\n  result.north = Math.max(rectangle.north, cartographic.latitude);\n\n  return result;\n};\n\n/**\n * Returns true if the cartographic is on or inside the rectangle, false otherwise.\n *\n * @param {Rectangle} rectangle The rectangle\n * @param {Cartographic} cartographic The cartographic to test.\n * @returns {Boolean} true if the provided cartographic is inside the rectangle, false otherwise.\n */\nRectangle.contains = function (rectangle, cartographic) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"rectangle\", rectangle);\n  Check.typeOf.object(\"cartographic\", cartographic);\n  //>>includeEnd('debug');\n\n  var longitude = cartographic.longitude;\n  var latitude = cartographic.latitude;\n\n  var west = rectangle.west;\n  var east = rectangle.east;\n\n  if (east < west) {\n    east += CesiumMath.TWO_PI;\n    if (longitude < 0.0) {\n      longitude += CesiumMath.TWO_PI;\n    }\n  }\n  return (\n    (longitude > west ||\n      CesiumMath.equalsEpsilon(longitude, west, CesiumMath.EPSILON14)) &&\n    (longitude < east ||\n      CesiumMath.equalsEpsilon(longitude, east, CesiumMath.EPSILON14)) &&\n    latitude >= rectangle.south &&\n    latitude <= rectangle.north\n  );\n};\n\nvar subsampleLlaScratch = new Cartographic();\n/**\n * Samples a rectangle so that it includes a list of Cartesian points suitable for passing to\n * {@link BoundingSphere#fromPoints}.  Sampling is necessary to account\n * for rectangles that cover the poles or cross the equator.\n *\n * @param {Rectangle} rectangle The rectangle to subsample.\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid to use.\n * @param {Number} [surfaceHeight=0.0] The height of the rectangle above the ellipsoid.\n * @param {Cartesian3[]} [result] The array of Cartesians onto which to store the result.\n * @returns {Cartesian3[]} The modified result parameter or a new Array of Cartesians instances if none was provided.\n */\nRectangle.subsample = function (rectangle, ellipsoid, surfaceHeight, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"rectangle\", rectangle);\n  //>>includeEnd('debug');\n\n  ellipsoid = defaultValue(ellipsoid, Ellipsoid.WGS84);\n  surfaceHeight = defaultValue(surfaceHeight, 0.0);\n\n  if (!defined(result)) {\n    result = [];\n  }\n  var length = 0;\n\n  var north = rectangle.north;\n  var south = rectangle.south;\n  var east = rectangle.east;\n  var west = rectangle.west;\n\n  var lla = subsampleLlaScratch;\n  lla.height = surfaceHeight;\n\n  lla.longitude = west;\n  lla.latitude = north;\n  result[length] = ellipsoid.cartographicToCartesian(lla, result[length]);\n  length++;\n\n  lla.longitude = east;\n  result[length] = ellipsoid.cartographicToCartesian(lla, result[length]);\n  length++;\n\n  lla.latitude = south;\n  result[length] = ellipsoid.cartographicToCartesian(lla, result[length]);\n  length++;\n\n  lla.longitude = west;\n  result[length] = ellipsoid.cartographicToCartesian(lla, result[length]);\n  length++;\n\n  if (north < 0.0) {\n    lla.latitude = north;\n  } else if (south > 0.0) {\n    lla.latitude = south;\n  } else {\n    lla.latitude = 0.0;\n  }\n\n  for (var i = 1; i < 8; ++i) {\n    lla.longitude = -Math.PI + i * CesiumMath.PI_OVER_TWO;\n    if (Rectangle.contains(rectangle, lla)) {\n      result[length] = ellipsoid.cartographicToCartesian(lla, result[length]);\n      length++;\n    }\n  }\n\n  if (lla.latitude === 0.0) {\n    lla.longitude = west;\n    result[length] = ellipsoid.cartographicToCartesian(lla, result[length]);\n    length++;\n    lla.longitude = east;\n    result[length] = ellipsoid.cartographicToCartesian(lla, result[length]);\n    length++;\n  }\n  result.length = length;\n  return result;\n};\n\n/**\n * The largest possible rectangle.\n *\n * @type {Rectangle}\n * @constant\n */\nRectangle.MAX_VALUE = Object.freeze(\n  new Rectangle(\n    -Math.PI,\n    -CesiumMath.PI_OVER_TWO,\n    Math.PI,\n    CesiumMath.PI_OVER_TWO\n  )\n);\nexport default Rectangle;\n","import Check from \"./Check.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport CesiumMath from \"./Math.js\";\n\n/**\n * A 2D Cartesian point.\n * @alias Cartesian2\n * @constructor\n *\n * @param {Number} [x=0.0] The X component.\n * @param {Number} [y=0.0] The Y component.\n *\n * @see Cartesian3\n * @see Cartesian4\n * @see Packable\n */\nfunction Cartesian2(x, y) {\n  /**\n   * The X component.\n   * @type {Number}\n   * @default 0.0\n   */\n  this.x = defaultValue(x, 0.0);\n\n  /**\n   * The Y component.\n   * @type {Number}\n   * @default 0.0\n   */\n  this.y = defaultValue(y, 0.0);\n}\n\n/**\n * Creates a Cartesian2 instance from x and y coordinates.\n *\n * @param {Number} x The x coordinate.\n * @param {Number} y The y coordinate.\n * @param {Cartesian2} [result] The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter or a new Cartesian2 instance if one was not provided.\n */\nCartesian2.fromElements = function (x, y, result) {\n  if (!defined(result)) {\n    return new Cartesian2(x, y);\n  }\n\n  result.x = x;\n  result.y = y;\n  return result;\n};\n\n/**\n * Duplicates a Cartesian2 instance.\n *\n * @param {Cartesian2} cartesian The Cartesian to duplicate.\n * @param {Cartesian2} [result] The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter or a new Cartesian2 instance if one was not provided. (Returns undefined if cartesian is undefined)\n */\nCartesian2.clone = function (cartesian, result) {\n  if (!defined(cartesian)) {\n    return undefined;\n  }\n  if (!defined(result)) {\n    return new Cartesian2(cartesian.x, cartesian.y);\n  }\n\n  result.x = cartesian.x;\n  result.y = cartesian.y;\n  return result;\n};\n\n/**\n * Creates a Cartesian2 instance from an existing Cartesian3.  This simply takes the\n * x and y properties of the Cartesian3 and drops z.\n * @function\n *\n * @param {Cartesian3} cartesian The Cartesian3 instance to create a Cartesian2 instance from.\n * @param {Cartesian2} [result] The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter or a new Cartesian2 instance if one was not provided.\n */\nCartesian2.fromCartesian3 = Cartesian2.clone;\n\n/**\n * Creates a Cartesian2 instance from an existing Cartesian4.  This simply takes the\n * x and y properties of the Cartesian4 and drops z and w.\n * @function\n *\n * @param {Cartesian4} cartesian The Cartesian4 instance to create a Cartesian2 instance from.\n * @param {Cartesian2} [result] The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter or a new Cartesian2 instance if one was not provided.\n */\nCartesian2.fromCartesian4 = Cartesian2.clone;\n\n/**\n * The number of elements used to pack the object into an array.\n * @type {Number}\n */\nCartesian2.packedLength = 2;\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {Cartesian2} value The value to pack.\n * @param {Number[]} array The array to pack into.\n * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {Number[]} The array that was packed into\n */\nCartesian2.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"value\", value);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  array[startingIndex++] = value.x;\n  array[startingIndex] = value.y;\n\n  return array;\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {Number[]} array The packed array.\n * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {Cartesian2} [result] The object into which to store the result.\n * @returns {Cartesian2} The modified result parameter or a new Cartesian2 instance if one was not provided.\n */\nCartesian2.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  if (!defined(result)) {\n    result = new Cartesian2();\n  }\n  result.x = array[startingIndex++];\n  result.y = array[startingIndex];\n  return result;\n};\n\n/**\n     * Flattens an array of Cartesian2s into and array of components.\n     *\n     * @param {Cartesian2[]} array The array of cartesians to pack.\n     * @param {Number[]} [result] The array onto which to store the result. If this is a typed array, it must have array.length * 2 components, else a {@link DeveloperError} will be thrown. If it is a regular array, it will be resized to have (array.length * 2) elements.\n\n     * @returns {Number[]} The packed array.\n     */\nCartesian2.packArray = function (array, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  var length = array.length;\n  var resultLength = length * 2;\n  if (!defined(result)) {\n    result = new Array(resultLength);\n  } else if (!Array.isArray(result) && result.length !== resultLength) {\n    throw new DeveloperError(\n      \"If result is a typed array, it must have exactly array.length * 2 elements\"\n    );\n  } else if (result.length !== resultLength) {\n    result.length = resultLength;\n  }\n\n  for (var i = 0; i < length; ++i) {\n    Cartesian2.pack(array[i], result, i * 2);\n  }\n  return result;\n};\n\n/**\n * Unpacks an array of cartesian components into and array of Cartesian2s.\n *\n * @param {Number[]} array The array of components to unpack.\n * @param {Cartesian2[]} [result] The array onto which to store the result.\n * @returns {Cartesian2[]} The unpacked array.\n */\nCartesian2.unpackArray = function (array, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  Check.typeOf.number.greaterThanOrEquals(\"array.length\", array.length, 2);\n  if (array.length % 2 !== 0) {\n    throw new DeveloperError(\"array length must be a multiple of 2.\");\n  }\n  //>>includeEnd('debug');\n\n  var length = array.length;\n  if (!defined(result)) {\n    result = new Array(length / 2);\n  } else {\n    result.length = length / 2;\n  }\n\n  for (var i = 0; i < length; i += 2) {\n    var index = i / 2;\n    result[index] = Cartesian2.unpack(array, i, result[index]);\n  }\n  return result;\n};\n\n/**\n * Creates a Cartesian2 from two consecutive elements in an array.\n * @function\n *\n * @param {Number[]} array The array whose two consecutive elements correspond to the x and y components, respectively.\n * @param {Number} [startingIndex=0] The offset into the array of the first element, which corresponds to the x component.\n * @param {Cartesian2} [result] The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter or a new Cartesian2 instance if one was not provided.\n *\n * @example\n * // Create a Cartesian2 with (1.0, 2.0)\n * var v = [1.0, 2.0];\n * var p = Cesium.Cartesian2.fromArray(v);\n *\n * // Create a Cartesian2 with (1.0, 2.0) using an offset into an array\n * var v2 = [0.0, 0.0, 1.0, 2.0];\n * var p2 = Cesium.Cartesian2.fromArray(v2, 2);\n */\nCartesian2.fromArray = Cartesian2.unpack;\n\n/**\n * Computes the value of the maximum component for the supplied Cartesian.\n *\n * @param {Cartesian2} cartesian The cartesian to use.\n * @returns {Number} The value of the maximum component.\n */\nCartesian2.maximumComponent = function (cartesian) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  //>>includeEnd('debug');\n\n  return Math.max(cartesian.x, cartesian.y);\n};\n\n/**\n * Computes the value of the minimum component for the supplied Cartesian.\n *\n * @param {Cartesian2} cartesian The cartesian to use.\n * @returns {Number} The value of the minimum component.\n */\nCartesian2.minimumComponent = function (cartesian) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  //>>includeEnd('debug');\n\n  return Math.min(cartesian.x, cartesian.y);\n};\n\n/**\n * Compares two Cartesians and computes a Cartesian which contains the minimum components of the supplied Cartesians.\n *\n * @param {Cartesian2} first A cartesian to compare.\n * @param {Cartesian2} second A cartesian to compare.\n * @param {Cartesian2} result The object into which to store the result.\n * @returns {Cartesian2} A cartesian with the minimum components.\n */\nCartesian2.minimumByComponent = function (first, second, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"first\", first);\n  Check.typeOf.object(\"second\", second);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = Math.min(first.x, second.x);\n  result.y = Math.min(first.y, second.y);\n\n  return result;\n};\n\n/**\n * Compares two Cartesians and computes a Cartesian which contains the maximum components of the supplied Cartesians.\n *\n * @param {Cartesian2} first A cartesian to compare.\n * @param {Cartesian2} second A cartesian to compare.\n * @param {Cartesian2} result The object into which to store the result.\n * @returns {Cartesian2} A cartesian with the maximum components.\n */\nCartesian2.maximumByComponent = function (first, second, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"first\", first);\n  Check.typeOf.object(\"second\", second);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = Math.max(first.x, second.x);\n  result.y = Math.max(first.y, second.y);\n  return result;\n};\n\n/**\n * Computes the provided Cartesian's squared magnitude.\n *\n * @param {Cartesian2} cartesian The Cartesian instance whose squared magnitude is to be computed.\n * @returns {Number} The squared magnitude.\n */\nCartesian2.magnitudeSquared = function (cartesian) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  //>>includeEnd('debug');\n\n  return cartesian.x * cartesian.x + cartesian.y * cartesian.y;\n};\n\n/**\n * Computes the Cartesian's magnitude (length).\n *\n * @param {Cartesian2} cartesian The Cartesian instance whose magnitude is to be computed.\n * @returns {Number} The magnitude.\n */\nCartesian2.magnitude = function (cartesian) {\n  return Math.sqrt(Cartesian2.magnitudeSquared(cartesian));\n};\n\nvar distanceScratch = new Cartesian2();\n\n/**\n * Computes the distance between two points.\n *\n * @param {Cartesian2} left The first point to compute the distance from.\n * @param {Cartesian2} right The second point to compute the distance to.\n * @returns {Number} The distance between two points.\n *\n * @example\n * // Returns 1.0\n * var d = Cesium.Cartesian2.distance(new Cesium.Cartesian2(1.0, 0.0), new Cesium.Cartesian2(2.0, 0.0));\n */\nCartesian2.distance = function (left, right) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  //>>includeEnd('debug');\n\n  Cartesian2.subtract(left, right, distanceScratch);\n  return Cartesian2.magnitude(distanceScratch);\n};\n\n/**\n * Computes the squared distance between two points.  Comparing squared distances\n * using this function is more efficient than comparing distances using {@link Cartesian2#distance}.\n *\n * @param {Cartesian2} left The first point to compute the distance from.\n * @param {Cartesian2} right The second point to compute the distance to.\n * @returns {Number} The distance between two points.\n *\n * @example\n * // Returns 4.0, not 2.0\n * var d = Cesium.Cartesian2.distance(new Cesium.Cartesian2(1.0, 0.0), new Cesium.Cartesian2(3.0, 0.0));\n */\nCartesian2.distanceSquared = function (left, right) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  //>>includeEnd('debug');\n\n  Cartesian2.subtract(left, right, distanceScratch);\n  return Cartesian2.magnitudeSquared(distanceScratch);\n};\n\n/**\n * Computes the normalized form of the supplied Cartesian.\n *\n * @param {Cartesian2} cartesian The Cartesian to be normalized.\n * @param {Cartesian2} result The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter.\n */\nCartesian2.normalize = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  var magnitude = Cartesian2.magnitude(cartesian);\n\n  result.x = cartesian.x / magnitude;\n  result.y = cartesian.y / magnitude;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (isNaN(result.x) || isNaN(result.y)) {\n    throw new DeveloperError(\"normalized result is not a number\");\n  }\n  //>>includeEnd('debug');\n\n  return result;\n};\n\n/**\n * Computes the dot (scalar) product of two Cartesians.\n *\n * @param {Cartesian2} left The first Cartesian.\n * @param {Cartesian2} right The second Cartesian.\n * @returns {Number} The dot product.\n */\nCartesian2.dot = function (left, right) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  //>>includeEnd('debug');\n\n  return left.x * right.x + left.y * right.y;\n};\n\n/**\n * Computes the magnitude of the cross product that would result from implicitly setting the Z coordinate of the input vectors to 0\n *\n * @param {Cartesian2} left The first Cartesian.\n * @param {Cartesian2} right The second Cartesian.\n * @returns {Number} The cross product.\n */\nCartesian2.cross = function (left, right) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  //>>includeEnd('debug');\n\n  return left.x * right.y - left.y * right.x;\n};\n\n/**\n * Computes the componentwise product of two Cartesians.\n *\n * @param {Cartesian2} left The first Cartesian.\n * @param {Cartesian2} right The second Cartesian.\n * @param {Cartesian2} result The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter.\n */\nCartesian2.multiplyComponents = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = left.x * right.x;\n  result.y = left.y * right.y;\n  return result;\n};\n\n/**\n * Computes the componentwise quotient of two Cartesians.\n *\n * @param {Cartesian2} left The first Cartesian.\n * @param {Cartesian2} right The second Cartesian.\n * @param {Cartesian2} result The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter.\n */\nCartesian2.divideComponents = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = left.x / right.x;\n  result.y = left.y / right.y;\n  return result;\n};\n\n/**\n * Computes the componentwise sum of two Cartesians.\n *\n * @param {Cartesian2} left The first Cartesian.\n * @param {Cartesian2} right The second Cartesian.\n * @param {Cartesian2} result The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter.\n */\nCartesian2.add = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = left.x + right.x;\n  result.y = left.y + right.y;\n  return result;\n};\n\n/**\n * Computes the componentwise difference of two Cartesians.\n *\n * @param {Cartesian2} left The first Cartesian.\n * @param {Cartesian2} right The second Cartesian.\n * @param {Cartesian2} result The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter.\n */\nCartesian2.subtract = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = left.x - right.x;\n  result.y = left.y - right.y;\n  return result;\n};\n\n/**\n * Multiplies the provided Cartesian componentwise by the provided scalar.\n *\n * @param {Cartesian2} cartesian The Cartesian to be scaled.\n * @param {Number} scalar The scalar to multiply with.\n * @param {Cartesian2} result The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter.\n */\nCartesian2.multiplyByScalar = function (cartesian, scalar, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.number(\"scalar\", scalar);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = cartesian.x * scalar;\n  result.y = cartesian.y * scalar;\n  return result;\n};\n\n/**\n * Divides the provided Cartesian componentwise by the provided scalar.\n *\n * @param {Cartesian2} cartesian The Cartesian to be divided.\n * @param {Number} scalar The scalar to divide by.\n * @param {Cartesian2} result The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter.\n */\nCartesian2.divideByScalar = function (cartesian, scalar, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.number(\"scalar\", scalar);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = cartesian.x / scalar;\n  result.y = cartesian.y / scalar;\n  return result;\n};\n\n/**\n * Negates the provided Cartesian.\n *\n * @param {Cartesian2} cartesian The Cartesian to be negated.\n * @param {Cartesian2} result The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter.\n */\nCartesian2.negate = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = -cartesian.x;\n  result.y = -cartesian.y;\n  return result;\n};\n\n/**\n * Computes the absolute value of the provided Cartesian.\n *\n * @param {Cartesian2} cartesian The Cartesian whose absolute value is to be computed.\n * @param {Cartesian2} result The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter.\n */\nCartesian2.abs = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = Math.abs(cartesian.x);\n  result.y = Math.abs(cartesian.y);\n  return result;\n};\n\nvar lerpScratch = new Cartesian2();\n/**\n * Computes the linear interpolation or extrapolation at t using the provided cartesians.\n *\n * @param {Cartesian2} start The value corresponding to t at 0.0.\n * @param {Cartesian2} end The value corresponding to t at 1.0.\n * @param {Number} t The point along t at which to interpolate.\n * @param {Cartesian2} result The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter.\n */\nCartesian2.lerp = function (start, end, t, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"start\", start);\n  Check.typeOf.object(\"end\", end);\n  Check.typeOf.number(\"t\", t);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  Cartesian2.multiplyByScalar(end, t, lerpScratch);\n  result = Cartesian2.multiplyByScalar(start, 1.0 - t, result);\n  return Cartesian2.add(lerpScratch, result, result);\n};\n\nvar angleBetweenScratch = new Cartesian2();\nvar angleBetweenScratch2 = new Cartesian2();\n/**\n * Returns the angle, in radians, between the provided Cartesians.\n *\n * @param {Cartesian2} left The first Cartesian.\n * @param {Cartesian2} right The second Cartesian.\n * @returns {Number} The angle between the Cartesians.\n */\nCartesian2.angleBetween = function (left, right) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  //>>includeEnd('debug');\n\n  Cartesian2.normalize(left, angleBetweenScratch);\n  Cartesian2.normalize(right, angleBetweenScratch2);\n  return CesiumMath.acosClamped(\n    Cartesian2.dot(angleBetweenScratch, angleBetweenScratch2)\n  );\n};\n\nvar mostOrthogonalAxisScratch = new Cartesian2();\n/**\n * Returns the axis that is most orthogonal to the provided Cartesian.\n *\n * @param {Cartesian2} cartesian The Cartesian on which to find the most orthogonal axis.\n * @param {Cartesian2} result The object onto which to store the result.\n * @returns {Cartesian2} The most orthogonal axis.\n */\nCartesian2.mostOrthogonalAxis = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  var f = Cartesian2.normalize(cartesian, mostOrthogonalAxisScratch);\n  Cartesian2.abs(f, f);\n\n  if (f.x <= f.y) {\n    result = Cartesian2.clone(Cartesian2.UNIT_X, result);\n  } else {\n    result = Cartesian2.clone(Cartesian2.UNIT_Y, result);\n  }\n\n  return result;\n};\n\n/**\n * Compares the provided Cartesians componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {Cartesian2} [left] The first Cartesian.\n * @param {Cartesian2} [right] The second Cartesian.\n * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n */\nCartesian2.equals = function (left, right) {\n  return (\n    left === right ||\n    (defined(left) &&\n      defined(right) &&\n      left.x === right.x &&\n      left.y === right.y)\n  );\n};\n\n/**\n * @private\n */\nCartesian2.equalsArray = function (cartesian, array, offset) {\n  return cartesian.x === array[offset] && cartesian.y === array[offset + 1];\n};\n\n/**\n * Compares the provided Cartesians componentwise and returns\n * <code>true</code> if they pass an absolute or relative tolerance test,\n * <code>false</code> otherwise.\n *\n * @param {Cartesian2} [left] The first Cartesian.\n * @param {Cartesian2} [right] The second Cartesian.\n * @param {Number} [relativeEpsilon=0] The relative epsilon tolerance to use for equality testing.\n * @param {Number} [absoluteEpsilon=relativeEpsilon] The absolute epsilon tolerance to use for equality testing.\n * @returns {Boolean} <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.\n */\nCartesian2.equalsEpsilon = function (\n  left,\n  right,\n  relativeEpsilon,\n  absoluteEpsilon\n) {\n  return (\n    left === right ||\n    (defined(left) &&\n      defined(right) &&\n      CesiumMath.equalsEpsilon(\n        left.x,\n        right.x,\n        relativeEpsilon,\n        absoluteEpsilon\n      ) &&\n      CesiumMath.equalsEpsilon(\n        left.y,\n        right.y,\n        relativeEpsilon,\n        absoluteEpsilon\n      ))\n  );\n};\n\n/**\n * An immutable Cartesian2 instance initialized to (0.0, 0.0).\n *\n * @type {Cartesian2}\n * @constant\n */\nCartesian2.ZERO = Object.freeze(new Cartesian2(0.0, 0.0));\n\n/**\n * An immutable Cartesian2 instance initialized to (1.0, 1.0).\n *\n * @type {Cartesian2}\n * @constant\n */\nCartesian2.ONE = Object.freeze(new Cartesian2(1.0, 1.0));\n\n/**\n * An immutable Cartesian2 instance initialized to (1.0, 0.0).\n *\n * @type {Cartesian2}\n * @constant\n */\nCartesian2.UNIT_X = Object.freeze(new Cartesian2(1.0, 0.0));\n\n/**\n * An immutable Cartesian2 instance initialized to (0.0, 1.0).\n *\n * @type {Cartesian2}\n * @constant\n */\nCartesian2.UNIT_Y = Object.freeze(new Cartesian2(0.0, 1.0));\n\n/**\n * Duplicates this Cartesian2 instance.\n *\n * @param {Cartesian2} [result] The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter or a new Cartesian2 instance if one was not provided.\n */\nCartesian2.prototype.clone = function (result) {\n  return Cartesian2.clone(this, result);\n};\n\n/**\n * Compares this Cartesian against the provided Cartesian componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {Cartesian2} [right] The right hand side Cartesian.\n * @returns {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.\n */\nCartesian2.prototype.equals = function (right) {\n  return Cartesian2.equals(this, right);\n};\n\n/**\n * Compares this Cartesian against the provided Cartesian componentwise and returns\n * <code>true</code> if they pass an absolute or relative tolerance test,\n * <code>false</code> otherwise.\n *\n * @param {Cartesian2} [right] The right hand side Cartesian.\n * @param {Number} [relativeEpsilon=0] The relative epsilon tolerance to use for equality testing.\n * @param {Number} [absoluteEpsilon=relativeEpsilon] The absolute epsilon tolerance to use for equality testing.\n * @returns {Boolean} <code>true</code> if they are within the provided epsilon, <code>false</code> otherwise.\n */\nCartesian2.prototype.equalsEpsilon = function (\n  right,\n  relativeEpsilon,\n  absoluteEpsilon\n) {\n  return Cartesian2.equalsEpsilon(\n    this,\n    right,\n    relativeEpsilon,\n    absoluteEpsilon\n  );\n};\n\n/**\n * Creates a string representing this Cartesian in the format '(x, y)'.\n *\n * @returns {String} A string representing the provided Cartesian in the format '(x, y)'.\n */\nCartesian2.prototype.toString = function () {\n  return \"(\" + this.x + \", \" + this.y + \")\";\n};\nexport default Cartesian2;\n","import Cartesian2 from \"./Cartesian2.js\";\nimport Check from \"./Check.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\n\n/**\n * A 2x2 matrix, indexable as a column-major order array.\n * Constructor parameters are in row-major order for code readability.\n * @alias Matrix2\n * @constructor\n * @implements {ArrayLike<number>}\n *\n * @param {Number} [column0Row0=0.0] The value for column 0, row 0.\n * @param {Number} [column1Row0=0.0] The value for column 1, row 0.\n * @param {Number} [column0Row1=0.0] The value for column 0, row 1.\n * @param {Number} [column1Row1=0.0] The value for column 1, row 1.\n *\n * @see Matrix2.fromColumnMajorArray\n * @see Matrix2.fromRowMajorArray\n * @see Matrix2.fromScale\n * @see Matrix2.fromUniformScale\n * @see Matrix3\n * @see Matrix4\n */\nfunction Matrix2(column0Row0, column1Row0, column0Row1, column1Row1) {\n  this[0] = defaultValue(column0Row0, 0.0);\n  this[1] = defaultValue(column0Row1, 0.0);\n  this[2] = defaultValue(column1Row0, 0.0);\n  this[3] = defaultValue(column1Row1, 0.0);\n}\n\n/**\n * The number of elements used to pack the object into an array.\n * @type {Number}\n */\nMatrix2.packedLength = 4;\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {Matrix2} value The value to pack.\n * @param {Number[]} array The array to pack into.\n * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {Number[]} The array that was packed into\n */\nMatrix2.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"value\", value);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  array[startingIndex++] = value[0];\n  array[startingIndex++] = value[1];\n  array[startingIndex++] = value[2];\n  array[startingIndex++] = value[3];\n\n  return array;\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {Number[]} array The packed array.\n * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {Matrix2} [result] The object into which to store the result.\n * @returns {Matrix2} The modified result parameter or a new Matrix2 instance if one was not provided.\n */\nMatrix2.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  if (!defined(result)) {\n    result = new Matrix2();\n  }\n\n  result[0] = array[startingIndex++];\n  result[1] = array[startingIndex++];\n  result[2] = array[startingIndex++];\n  result[3] = array[startingIndex++];\n  return result;\n};\n\n/**\n * Duplicates a Matrix2 instance.\n *\n * @param {Matrix2} matrix The matrix to duplicate.\n * @param {Matrix2} [result] The object onto which to store the result.\n * @returns {Matrix2} The modified result parameter or a new Matrix2 instance if one was not provided. (Returns undefined if matrix is undefined)\n */\nMatrix2.clone = function (matrix, result) {\n  if (!defined(matrix)) {\n    return undefined;\n  }\n  if (!defined(result)) {\n    return new Matrix2(matrix[0], matrix[2], matrix[1], matrix[3]);\n  }\n  result[0] = matrix[0];\n  result[1] = matrix[1];\n  result[2] = matrix[2];\n  result[3] = matrix[3];\n  return result;\n};\n\n/**\n * Creates a Matrix2 from 4 consecutive elements in an array.\n *\n * @param {Number[]} array The array whose 4 consecutive elements correspond to the positions of the matrix.  Assumes column-major order.\n * @param {Number} [startingIndex=0] The offset into the array of the first element, which corresponds to first column first row position in the matrix.\n * @param {Matrix2} [result] The object onto which to store the result.\n * @returns {Matrix2} The modified result parameter or a new Matrix2 instance if one was not provided.\n *\n * @example\n * // Create the Matrix2:\n * // [1.0, 2.0]\n * // [1.0, 2.0]\n *\n * var v = [1.0, 1.0, 2.0, 2.0];\n * var m = Cesium.Matrix2.fromArray(v);\n *\n * // Create same Matrix2 with using an offset into an array\n * var v2 = [0.0, 0.0, 1.0, 1.0, 2.0, 2.0];\n * var m2 = Cesium.Matrix2.fromArray(v2, 2);\n */\nMatrix2.fromArray = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  if (!defined(result)) {\n    result = new Matrix2();\n  }\n\n  result[0] = array[startingIndex];\n  result[1] = array[startingIndex + 1];\n  result[2] = array[startingIndex + 2];\n  result[3] = array[startingIndex + 3];\n  return result;\n};\n\n/**\n * Creates a Matrix2 instance from a column-major order array.\n *\n * @param {Number[]} values The column-major order array.\n * @param {Matrix2} [result] The object in which the result will be stored, if undefined a new instance will be created.\n * @returns {Matrix2} The modified result parameter, or a new Matrix2 instance if one was not provided.\n */\nMatrix2.fromColumnMajorArray = function (values, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"values\", values);\n  //>>includeEnd('debug');\n\n  return Matrix2.clone(values, result);\n};\n\n/**\n * Creates a Matrix2 instance from a row-major order array.\n * The resulting matrix will be in column-major order.\n *\n * @param {Number[]} values The row-major order array.\n * @param {Matrix2} [result] The object in which the result will be stored, if undefined a new instance will be created.\n * @returns {Matrix2} The modified result parameter, or a new Matrix2 instance if one was not provided.\n */\nMatrix2.fromRowMajorArray = function (values, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"values\", values);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    return new Matrix2(values[0], values[1], values[2], values[3]);\n  }\n  result[0] = values[0];\n  result[1] = values[2];\n  result[2] = values[1];\n  result[3] = values[3];\n  return result;\n};\n\n/**\n * Computes a Matrix2 instance representing a non-uniform scale.\n *\n * @param {Cartesian2} scale The x and y scale factors.\n * @param {Matrix2} [result] The object in which the result will be stored, if undefined a new instance will be created.\n * @returns {Matrix2} The modified result parameter, or a new Matrix2 instance if one was not provided.\n *\n * @example\n * // Creates\n * //   [7.0, 0.0]\n * //   [0.0, 8.0]\n * var m = Cesium.Matrix2.fromScale(new Cesium.Cartesian2(7.0, 8.0));\n */\nMatrix2.fromScale = function (scale, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"scale\", scale);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    return new Matrix2(scale.x, 0.0, 0.0, scale.y);\n  }\n\n  result[0] = scale.x;\n  result[1] = 0.0;\n  result[2] = 0.0;\n  result[3] = scale.y;\n  return result;\n};\n\n/**\n * Computes a Matrix2 instance representing a uniform scale.\n *\n * @param {Number} scale The uniform scale factor.\n * @param {Matrix2} [result] The object in which the result will be stored, if undefined a new instance will be created.\n * @returns {Matrix2} The modified result parameter, or a new Matrix2 instance if one was not provided.\n *\n * @example\n * // Creates\n * //   [2.0, 0.0]\n * //   [0.0, 2.0]\n * var m = Cesium.Matrix2.fromUniformScale(2.0);\n */\nMatrix2.fromUniformScale = function (scale, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"scale\", scale);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    return new Matrix2(scale, 0.0, 0.0, scale);\n  }\n\n  result[0] = scale;\n  result[1] = 0.0;\n  result[2] = 0.0;\n  result[3] = scale;\n  return result;\n};\n\n/**\n * Creates a rotation matrix.\n *\n * @param {Number} angle The angle, in radians, of the rotation.  Positive angles are counterclockwise.\n * @param {Matrix2} [result] The object in which the result will be stored, if undefined a new instance will be created.\n * @returns {Matrix2} The modified result parameter, or a new Matrix2 instance if one was not provided.\n *\n * @example\n * // Rotate a point 45 degrees counterclockwise.\n * var p = new Cesium.Cartesian2(5, 6);\n * var m = Cesium.Matrix2.fromRotation(Cesium.Math.toRadians(45.0));\n * var rotated = Cesium.Matrix2.multiplyByVector(m, p, new Cesium.Cartesian2());\n */\nMatrix2.fromRotation = function (angle, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"angle\", angle);\n  //>>includeEnd('debug');\n\n  var cosAngle = Math.cos(angle);\n  var sinAngle = Math.sin(angle);\n\n  if (!defined(result)) {\n    return new Matrix2(cosAngle, -sinAngle, sinAngle, cosAngle);\n  }\n  result[0] = cosAngle;\n  result[1] = sinAngle;\n  result[2] = -sinAngle;\n  result[3] = cosAngle;\n  return result;\n};\n\n/**\n * Creates an Array from the provided Matrix2 instance.\n * The array will be in column-major order.\n *\n * @param {Matrix2} matrix The matrix to use..\n * @param {Number[]} [result] The Array onto which to store the result.\n * @returns {Number[]} The modified Array parameter or a new Array instance if one was not provided.\n */\nMatrix2.toArray = function (matrix, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    return [matrix[0], matrix[1], matrix[2], matrix[3]];\n  }\n  result[0] = matrix[0];\n  result[1] = matrix[1];\n  result[2] = matrix[2];\n  result[3] = matrix[3];\n  return result;\n};\n\n/**\n * Computes the array index of the element at the provided row and column.\n *\n * @param {Number} row The zero-based index of the row.\n * @param {Number} column The zero-based index of the column.\n * @returns {Number} The index of the element at the provided row and column.\n *\n * @exception {DeveloperError} row must be 0 or 1.\n * @exception {DeveloperError} column must be 0 or 1.\n *\n * @example\n * var myMatrix = new Cesium.Matrix2();\n * var column1Row0Index = Cesium.Matrix2.getElementIndex(1, 0);\n * var column1Row0 = myMatrix[column1Row0Index]\n * myMatrix[column1Row0Index] = 10.0;\n */\nMatrix2.getElementIndex = function (column, row) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number.greaterThanOrEquals(\"row\", row, 0);\n  Check.typeOf.number.lessThanOrEquals(\"row\", row, 1);\n\n  Check.typeOf.number.greaterThanOrEquals(\"column\", column, 0);\n  Check.typeOf.number.lessThanOrEquals(\"column\", column, 1);\n  //>>includeEnd('debug');\n\n  return column * 2 + row;\n};\n\n/**\n * Retrieves a copy of the matrix column at the provided index as a Cartesian2 instance.\n *\n * @param {Matrix2} matrix The matrix to use.\n * @param {Number} index The zero-based index of the column to retrieve.\n * @param {Cartesian2} result The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter.\n *\n * @exception {DeveloperError} index must be 0 or 1.\n */\nMatrix2.getColumn = function (matrix, index, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n\n  Check.typeOf.number.greaterThanOrEquals(\"index\", index, 0);\n  Check.typeOf.number.lessThanOrEquals(\"index\", index, 1);\n\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  var startIndex = index * 2;\n  var x = matrix[startIndex];\n  var y = matrix[startIndex + 1];\n\n  result.x = x;\n  result.y = y;\n  return result;\n};\n\n/**\n * Computes a new matrix that replaces the specified column in the provided matrix with the provided Cartesian2 instance.\n *\n * @param {Matrix2} matrix The matrix to use.\n * @param {Number} index The zero-based index of the column to set.\n * @param {Cartesian2} cartesian The Cartesian whose values will be assigned to the specified column.\n * @param {Cartesian2} result The object onto which to store the result.\n * @returns {Matrix2} The modified result parameter.\n *\n * @exception {DeveloperError} index must be 0 or 1.\n */\nMatrix2.setColumn = function (matrix, index, cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n\n  Check.typeOf.number.greaterThanOrEquals(\"index\", index, 0);\n  Check.typeOf.number.lessThanOrEquals(\"index\", index, 1);\n\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result = Matrix2.clone(matrix, result);\n  var startIndex = index * 2;\n  result[startIndex] = cartesian.x;\n  result[startIndex + 1] = cartesian.y;\n  return result;\n};\n\n/**\n * Retrieves a copy of the matrix row at the provided index as a Cartesian2 instance.\n *\n * @param {Matrix2} matrix The matrix to use.\n * @param {Number} index The zero-based index of the row to retrieve.\n * @param {Cartesian2} result The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter.\n *\n * @exception {DeveloperError} index must be 0 or 1.\n */\nMatrix2.getRow = function (matrix, index, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n\n  Check.typeOf.number.greaterThanOrEquals(\"index\", index, 0);\n  Check.typeOf.number.lessThanOrEquals(\"index\", index, 1);\n\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  var x = matrix[index];\n  var y = matrix[index + 2];\n\n  result.x = x;\n  result.y = y;\n  return result;\n};\n\n/**\n * Computes a new matrix that replaces the specified row in the provided matrix with the provided Cartesian2 instance.\n *\n * @param {Matrix2} matrix The matrix to use.\n * @param {Number} index The zero-based index of the row to set.\n * @param {Cartesian2} cartesian The Cartesian whose values will be assigned to the specified row.\n * @param {Matrix2} result The object onto which to store the result.\n * @returns {Matrix2} The modified result parameter.\n *\n * @exception {DeveloperError} index must be 0 or 1.\n */\nMatrix2.setRow = function (matrix, index, cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n\n  Check.typeOf.number.greaterThanOrEquals(\"index\", index, 0);\n  Check.typeOf.number.lessThanOrEquals(\"index\", index, 1);\n\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result = Matrix2.clone(matrix, result);\n  result[index] = cartesian.x;\n  result[index + 2] = cartesian.y;\n  return result;\n};\n\nvar scratchColumn = new Cartesian2();\n\n/**\n * Extracts the non-uniform scale assuming the matrix is an affine transformation.\n *\n * @param {Matrix2} matrix The matrix.\n * @param {Cartesian2} result The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter.\n */\nMatrix2.getScale = function (matrix, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = Cartesian2.magnitude(\n    Cartesian2.fromElements(matrix[0], matrix[1], scratchColumn)\n  );\n  result.y = Cartesian2.magnitude(\n    Cartesian2.fromElements(matrix[2], matrix[3], scratchColumn)\n  );\n  return result;\n};\n\nvar scratchScale = new Cartesian2();\n\n/**\n * Computes the maximum scale assuming the matrix is an affine transformation.\n * The maximum scale is the maximum length of the column vectors.\n *\n * @param {Matrix2} matrix The matrix.\n * @returns {Number} The maximum scale.\n */\nMatrix2.getMaximumScale = function (matrix) {\n  Matrix2.getScale(matrix, scratchScale);\n  return Cartesian2.maximumComponent(scratchScale);\n};\n\n/**\n * Computes the product of two matrices.\n *\n * @param {Matrix2} left The first matrix.\n * @param {Matrix2} right The second matrix.\n * @param {Matrix2} result The object onto which to store the result.\n * @returns {Matrix2} The modified result parameter.\n */\nMatrix2.multiply = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  var column0Row0 = left[0] * right[0] + left[2] * right[1];\n  var column1Row0 = left[0] * right[2] + left[2] * right[3];\n  var column0Row1 = left[1] * right[0] + left[3] * right[1];\n  var column1Row1 = left[1] * right[2] + left[3] * right[3];\n\n  result[0] = column0Row0;\n  result[1] = column0Row1;\n  result[2] = column1Row0;\n  result[3] = column1Row1;\n  return result;\n};\n\n/**\n * Computes the sum of two matrices.\n *\n * @param {Matrix2} left The first matrix.\n * @param {Matrix2} right The second matrix.\n * @param {Matrix2} result The object onto which to store the result.\n * @returns {Matrix2} The modified result parameter.\n */\nMatrix2.add = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result[0] = left[0] + right[0];\n  result[1] = left[1] + right[1];\n  result[2] = left[2] + right[2];\n  result[3] = left[3] + right[3];\n  return result;\n};\n\n/**\n * Computes the difference of two matrices.\n *\n * @param {Matrix2} left The first matrix.\n * @param {Matrix2} right The second matrix.\n * @param {Matrix2} result The object onto which to store the result.\n * @returns {Matrix2} The modified result parameter.\n */\nMatrix2.subtract = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result[0] = left[0] - right[0];\n  result[1] = left[1] - right[1];\n  result[2] = left[2] - right[2];\n  result[3] = left[3] - right[3];\n  return result;\n};\n\n/**\n * Computes the product of a matrix and a column vector.\n *\n * @param {Matrix2} matrix The matrix.\n * @param {Cartesian2} cartesian The column.\n * @param {Cartesian2} result The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter.\n */\nMatrix2.multiplyByVector = function (matrix, cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  var x = matrix[0] * cartesian.x + matrix[2] * cartesian.y;\n  var y = matrix[1] * cartesian.x + matrix[3] * cartesian.y;\n\n  result.x = x;\n  result.y = y;\n  return result;\n};\n\n/**\n * Computes the product of a matrix and a scalar.\n *\n * @param {Matrix2} matrix The matrix.\n * @param {Number} scalar The number to multiply by.\n * @param {Matrix2} result The object onto which to store the result.\n * @returns {Matrix2} The modified result parameter.\n */\nMatrix2.multiplyByScalar = function (matrix, scalar, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.number(\"scalar\", scalar);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result[0] = matrix[0] * scalar;\n  result[1] = matrix[1] * scalar;\n  result[2] = matrix[2] * scalar;\n  result[3] = matrix[3] * scalar;\n  return result;\n};\n\n/**\n * Computes the product of a matrix times a (non-uniform) scale, as if the scale were a scale matrix.\n *\n * @param {Matrix2} matrix The matrix on the left-hand side.\n * @param {Cartesian2} scale The non-uniform scale on the right-hand side.\n * @param {Matrix2} result The object onto which to store the result.\n * @returns {Matrix2} The modified result parameter.\n *\n *\n * @example\n * // Instead of Cesium.Matrix2.multiply(m, Cesium.Matrix2.fromScale(scale), m);\n * Cesium.Matrix2.multiplyByScale(m, scale, m);\n *\n * @see Matrix2.fromScale\n * @see Matrix2.multiplyByUniformScale\n */\nMatrix2.multiplyByScale = function (matrix, scale, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.object(\"scale\", scale);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result[0] = matrix[0] * scale.x;\n  result[1] = matrix[1] * scale.x;\n  result[2] = matrix[2] * scale.y;\n  result[3] = matrix[3] * scale.y;\n  return result;\n};\n\n/**\n * Creates a negated copy of the provided matrix.\n *\n * @param {Matrix2} matrix The matrix to negate.\n * @param {Matrix2} result The object onto which to store the result.\n * @returns {Matrix2} The modified result parameter.\n */\nMatrix2.negate = function (matrix, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result[0] = -matrix[0];\n  result[1] = -matrix[1];\n  result[2] = -matrix[2];\n  result[3] = -matrix[3];\n  return result;\n};\n\n/**\n * Computes the transpose of the provided matrix.\n *\n * @param {Matrix2} matrix The matrix to transpose.\n * @param {Matrix2} result The object onto which to store the result.\n * @returns {Matrix2} The modified result parameter.\n */\nMatrix2.transpose = function (matrix, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  var column0Row0 = matrix[0];\n  var column0Row1 = matrix[2];\n  var column1Row0 = matrix[1];\n  var column1Row1 = matrix[3];\n\n  result[0] = column0Row0;\n  result[1] = column0Row1;\n  result[2] = column1Row0;\n  result[3] = column1Row1;\n  return result;\n};\n\n/**\n * Computes a matrix, which contains the absolute (unsigned) values of the provided matrix's elements.\n *\n * @param {Matrix2} matrix The matrix with signed elements.\n * @param {Matrix2} result The object onto which to store the result.\n * @returns {Matrix2} The modified result parameter.\n */\nMatrix2.abs = function (matrix, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result[0] = Math.abs(matrix[0]);\n  result[1] = Math.abs(matrix[1]);\n  result[2] = Math.abs(matrix[2]);\n  result[3] = Math.abs(matrix[3]);\n\n  return result;\n};\n\n/**\n * Compares the provided matrices componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {Matrix2} [left] The first matrix.\n * @param {Matrix2} [right] The second matrix.\n * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n */\nMatrix2.equals = function (left, right) {\n  return (\n    left === right ||\n    (defined(left) &&\n      defined(right) &&\n      left[0] === right[0] &&\n      left[1] === right[1] &&\n      left[2] === right[2] &&\n      left[3] === right[3])\n  );\n};\n\n/**\n * @private\n */\nMatrix2.equalsArray = function (matrix, array, offset) {\n  return (\n    matrix[0] === array[offset] &&\n    matrix[1] === array[offset + 1] &&\n    matrix[2] === array[offset + 2] &&\n    matrix[3] === array[offset + 3]\n  );\n};\n\n/**\n * Compares the provided matrices componentwise and returns\n * <code>true</code> if they are within the provided epsilon,\n * <code>false</code> otherwise.\n *\n * @param {Matrix2} [left] The first matrix.\n * @param {Matrix2} [right] The second matrix.\n * @param {Number} [epsilon=0] The epsilon to use for equality testing.\n * @returns {Boolean} <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.\n */\nMatrix2.equalsEpsilon = function (left, right, epsilon) {\n  epsilon = defaultValue(epsilon, 0);\n  return (\n    left === right ||\n    (defined(left) &&\n      defined(right) &&\n      Math.abs(left[0] - right[0]) <= epsilon &&\n      Math.abs(left[1] - right[1]) <= epsilon &&\n      Math.abs(left[2] - right[2]) <= epsilon &&\n      Math.abs(left[3] - right[3]) <= epsilon)\n  );\n};\n\n/**\n * An immutable Matrix2 instance initialized to the identity matrix.\n *\n * @type {Matrix2}\n * @constant\n */\nMatrix2.IDENTITY = Object.freeze(new Matrix2(1.0, 0.0, 0.0, 1.0));\n\n/**\n * An immutable Matrix2 instance initialized to the zero matrix.\n *\n * @type {Matrix2}\n * @constant\n */\nMatrix2.ZERO = Object.freeze(new Matrix2(0.0, 0.0, 0.0, 0.0));\n\n/**\n * The index into Matrix2 for column 0, row 0.\n *\n * @type {Number}\n * @constant\n *\n * @example\n * var matrix = new Cesium.Matrix2();\n * matrix[Cesium.Matrix2.COLUMN0ROW0] = 5.0; // set column 0, row 0 to 5.0\n */\nMatrix2.COLUMN0ROW0 = 0;\n\n/**\n * The index into Matrix2 for column 0, row 1.\n *\n * @type {Number}\n * @constant\n *\n * @example\n * var matrix = new Cesium.Matrix2();\n * matrix[Cesium.Matrix2.COLUMN0ROW1] = 5.0; // set column 0, row 1 to 5.0\n */\nMatrix2.COLUMN0ROW1 = 1;\n\n/**\n * The index into Matrix2 for column 1, row 0.\n *\n * @type {Number}\n * @constant\n *\n * @example\n * var matrix = new Cesium.Matrix2();\n * matrix[Cesium.Matrix2.COLUMN1ROW0] = 5.0; // set column 1, row 0 to 5.0\n */\nMatrix2.COLUMN1ROW0 = 2;\n\n/**\n * The index into Matrix2 for column 1, row 1.\n *\n * @type {Number}\n * @constant\n *\n * @example\n * var matrix = new Cesium.Matrix2();\n * matrix[Cesium.Matrix2.COLUMN1ROW1] = 5.0; // set column 1, row 1 to 5.0\n */\nMatrix2.COLUMN1ROW1 = 3;\n\nObject.defineProperties(Matrix2.prototype, {\n  /**\n   * Gets the number of items in the collection.\n   * @memberof Matrix2.prototype\n   *\n   * @type {Number}\n   */\n  length: {\n    get: function () {\n      return Matrix2.packedLength;\n    },\n  },\n});\n\n/**\n * Duplicates the provided Matrix2 instance.\n *\n * @param {Matrix2} [result] The object onto which to store the result.\n * @returns {Matrix2} The modified result parameter or a new Matrix2 instance if one was not provided.\n */\nMatrix2.prototype.clone = function (result) {\n  return Matrix2.clone(this, result);\n};\n\n/**\n * Compares this matrix to the provided matrix componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {Matrix2} [right] The right hand side matrix.\n * @returns {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.\n */\nMatrix2.prototype.equals = function (right) {\n  return Matrix2.equals(this, right);\n};\n\n/**\n * Compares this matrix to the provided matrix componentwise and returns\n * <code>true</code> if they are within the provided epsilon,\n * <code>false</code> otherwise.\n *\n * @param {Matrix2} [right] The right hand side matrix.\n * @param {Number} [epsilon=0] The epsilon to use for equality testing.\n * @returns {Boolean} <code>true</code> if they are within the provided epsilon, <code>false</code> otherwise.\n */\nMatrix2.prototype.equalsEpsilon = function (right, epsilon) {\n  return Matrix2.equalsEpsilon(this, right, epsilon);\n};\n\n/**\n * Creates a string representing this Matrix with each row being\n * on a separate line and in the format '(column0, column1)'.\n *\n * @returns {String} A string representing the provided Matrix with each row being on a separate line and in the format '(column0, column1)'.\n */\nMatrix2.prototype.toString = function () {\n  return (\n    \"(\" +\n    this[0] +\n    \", \" +\n    this[2] +\n    \")\\n\" +\n    \"(\" +\n    this[1] +\n    \", \" +\n    this[3] +\n    \")\"\n  );\n};\nexport default Matrix2;\n"],"names":["Cartesian3","x","y","z","this","defaultValue","fromSpherical","spherical","result","Check","typeOf","object","defined","clock","cone","magnitude","radial","Math","sin","cos","fromElements","clone","cartesian","fromCartesian4","packedLength","pack","value","array","startingIndex","unpack","packArray","length","resultLength","Array","isArray","DeveloperError","i","unpackArray","number","greaterThanOrEquals","index","fromArray","maximumComponent","max","minimumComponent","min","minimumByComponent","first","second","maximumByComponent","magnitudeSquared","sqrt","distanceScratch","distance","left","right","subtract","distanceSquared","normalize","isNaN","dot","multiplyComponents","divideComponents","add","multiplyByScalar","scalar","divideByScalar","negate","abs","lerpScratch","lerp","start","end","t","angleBetweenScratch","angleBetweenScratch2","angleBetween","cosine","sine","cross","atan2","mostOrthogonalAxisScratch","mostOrthogonalAxis","f","UNIT_X","UNIT_Z","UNIT_Y","projectVector","a","b","equals","equalsArray","offset","equalsEpsilon","relativeEpsilon","absoluteEpsilon","CesiumMath","leftX","leftY","leftZ","rightX","rightY","rightZ","midpoint","fromDegrees","longitude","latitude","height","ellipsoid","toRadians","fromRadians","scratchN","scratchK","wgs84RadiiSquared","radiiSquared","cosLatitude","gamma","fromDegreesArray","coordinates","fromRadiansArray","fromDegreesArrayHeights","fromRadiansArrayHeights","ZERO","Object","freeze","ONE","prototype","toString","scaleToGeodeticSurfaceIntersection","scaleToGeodeticSurfaceGradient","scaleToGeodeticSurface","oneOverRadii","oneOverRadiiSquared","centerToleranceSquared","positionX","positionY","positionZ","oneOverRadiiX","oneOverRadiiY","oneOverRadiiZ","x2","y2","z2","squaredNorm","ratio","intersection","isFinite","undefined","oneOverRadiiSquaredX","oneOverRadiiSquaredY","oneOverRadiiSquaredZ","gradient","func","xMultiplier","yMultiplier","zMultiplier","xMultiplier2","yMultiplier2","zMultiplier2","lambda","correction","EPSILON12","Cartographic","cartesianToCartographicN","cartesianToCartographicP","cartesianToCartographicH","wgs84OneOverRadii","wgs84OneOverRadiiSquared","wgs84CenterToleranceSquared","EPSILON1","initialize","_radii","_radiiSquared","_radiiToTheFourth","_oneOverRadii","_oneOverRadiiSquared","_minimumRadius","_maximumRadius","_centerToleranceSquared","_squaredXOverSquaredZ","Ellipsoid","fromCartesian","p","n","h","asin","sign","toCartesian","cartographic","epsilon","defineProperties","radii","get","radiiToTheFourth","minimumRadius","maximumRadius","fromCartesian3","WGS84","UNIT_SPHERE","MOON","LUNAR_RADIUS","geocentricSurfaceNormal","geodeticSurfaceNormalCartographic","geodeticSurfaceNormal","EPSILON14","cartographicToCartesianNormal","cartographicToCartesianK","cartographicToCartesian","k","cartographicArrayToCartesianArray","cartographics","cartesianToCartographic","cartesianArrayToCartographicArray","cartesians","scaleToGeocentricSurface","beta","transformPositionToScaledSpace","position","transformPositionFromScaledSpace","getSurfaceNormalIntersectionWithZAxis","buffer","EPSILON15","greaterThan","squaredXOverSquaredZ","abscissas","weights","gaussLegendreQuadrature","xMean","xRange","sum","dx","Matrix3","column0Row0","column1Row0","column2Row0","column0Row1","column1Row1","column2Row1","column0Row2","column1Row2","column2Row2","surfaceArea","rectangle","minLongitude","west","maxLongitude","east","minLatitude","south","maxLatitude","north","TWO_PI","a2","b2","c2","a2b2","lat","sinPhi","cosPhi","lon","cosTheta","sinTheta","matrix","fromColumnMajorArray","values","fromRowMajorArray","fromQuaternion","quaternion","xy","xz","xw","w","yz","yw","zw","w2","m00","m01","m02","m10","m11","m12","m20","m21","m22","fromHeadingPitchRoll","headingPitchRoll","pitch","cosPsi","heading","roll","sinPsi","fromScale","scale","fromUniformScale","fromCrossProduct","vector","fromRotationX","angle","cosAngle","sinAngle","fromRotationY","fromRotationZ","toArray","getElementIndex","column","row","lessThanOrEquals","getColumn","startIndex","setColumn","getRow","setRow","scratchColumn","getScale","scratchScale","getMaximumScale","multiply","multiplyByVector","vX","vY","vZ","multiplyByScale","transpose","UNIT","getRotation","inverseScale","rowVal","colVal","offDiagonalFrobeniusNorm","norm","temp","shurDecomposition","tolerance","maxDiagonal","rotAxis","c","s","q","tau","IDENTITY","jMatrix","jMatrixTranspose","computeEigenDecomposition","EPSILON20","count","sweep","unitaryMatrix","unitary","diagMatrix","diagonal","computeFrobeniusNorm","determinant","m31","m32","m13","m23","m33","inverse","scratchTransposeMatrix","Cartesian4","inverseTranspose","COLUMN0ROW0","COLUMN0ROW1","COLUMN0ROW2","COLUMN1ROW0","COLUMN1ROW1","COLUMN1ROW2","COLUMN2ROW0","COLUMN2ROW1","COLUMN2ROW2","fromColor","color","red","green","blue","alpha","UNIT_W","scratchF32Array","Float32Array","scratchU8Array","Uint8Array","testU32","Uint32Array","littleEndian","Matrix4","column3Row0","column3Row1","column3Row2","column0Row3","column1Row3","column2Row3","column3Row3","packFloat","unpackFloat","packedFloat","fromRotationTranslation","rotation","translation","fromTranslationQuaternionRotationScale","scaleX","scaleY","scaleZ","fromTranslationRotationScale","translationRotationScale","fromTranslation","fromCameraF","fromCameraR","fromCameraU","fromCamera","camera","direction","up","sX","sY","sZ","fX","fY","fZ","uX","uY","uZ","t0","t1","t2","computePerspectiveFieldOfView","fovY","aspectRatio","near","far","lessThan","PI","tan","computeOrthographicOffCenter","bottom","top","tx","ty","tz","computePerspectiveOffCenter","computeInfinitePerspectiveOffCenter","computeViewportTransformation","viewport","nearDepthRange","farDepthRange","EMPTY_OBJECT","width","halfWidth","halfHeight","halfDepth","computeView","setTranslation","scaleScratch","setScale","existingScale","newScale","left0","left1","left2","left3","left4","left5","left6","left7","left8","left9","left10","left11","left12","left13","left14","left15","right0","right1","right2","right3","right4","right5","right6","right7","right8","right9","right10","right11","right12","right13","right14","right15","multiplyTransformation","multiplyByMatrix3","multiplyByTranslation","uniformScaleScratch","multiplyByUniformScale","vW","multiplyByPointAsVector","multiplyByPoint","matrix1","matrix2","matrix3","matrix6","matrix7","matrix11","getTranslation","getMatrix3","scratchInverseRotation","scratchMatrix3Zero","scratchBottomRow","scratchExpectedBottomRow","src0","src1","src2","src3","src4","src5","src6","src7","src8","src9","src10","src11","src12","src13","src14","src15","tmp0","tmp1","tmp2","tmp3","tmp4","tmp5","tmp6","tmp7","tmp8","tmp9","tmp10","tmp11","dst0","dst1","dst2","dst3","dst4","dst5","dst6","dst7","dst8","dst9","dst10","dst11","dst12","dst13","dst14","dst15","det","EPSILON21","EPSILON7","RuntimeError","inverseTransformation","matrix0","matrix4","matrix5","matrix8","matrix9","matrix10","Rectangle","COLUMN0ROW3","COLUMN1ROW3","COLUMN2ROW3","COLUMN3ROW0","COLUMN3ROW1","COLUMN3ROW2","COLUMN3ROW3","computeWidth","computeHeight","fromCartographicArray","Number","MAX_VALUE","westOverIDL","eastOverIDL","len","lonAdjusted","fromCartesianArray","other","validate","PI_OVER_TWO","southwest","northwest","northeast","southeast","center","negativePiToPi","otherRectangle","rectangleEast","rectangleWest","otherRectangleEast","otherRectangleWest","simpleIntersection","union","expand","contains","subsampleLlaScratch","Cartesian2","subsample","surfaceHeight","lla","acosClamped","Matrix2","fromRotation"],"mappings":"8HAmBA,SAASA,EAAWC,EAAGC,EAAGC,GAMxBC,KAAKH,EAAII,eAAaJ,EAAG,GAOzBG,KAAKF,EAAIG,eAAaH,EAAG,GAOzBE,KAAKD,EAAIE,eAAaF,EAAG,GAU3BH,EAAWM,cAAgB,SAAUC,EAAWC,GAE9CC,QAAMC,OAAOC,OAAO,YAAaJ,GAG5BK,UAAQJ,KACXA,EAAS,IAAIR,GAGf,IAAIa,EAAQN,EAAUM,MAClBC,EAAOP,EAAUO,KACjBC,EAAYV,eAAaE,EAAUQ,UAAW,GAC9CC,EAASD,EAAYE,KAAKC,IAAIJ,GAIlC,OAHAN,EAAOP,EAAIe,EAASC,KAAKE,IAAIN,GAC7BL,EAAON,EAAIc,EAASC,KAAKC,IAAIL,GAC7BL,EAAOL,EAAIY,EAAYE,KAAKE,IAAIL,GACzBN,GAYTR,EAAWoB,aAAe,SAAUnB,EAAGC,EAAGC,EAAGK,GAC3C,OAAKI,UAAQJ,IAIbA,EAAOP,EAAIA,EACXO,EAAON,EAAIA,EACXM,EAAOL,EAAIA,EACJK,GANE,IAAIR,EAAWC,EAAGC,EAAGC,IAgBhCH,EAAWqB,MAAQ,SAAUC,EAAWd,GACtC,GAAKI,UAAQU,GAGb,OAAKV,UAAQJ,IAIbA,EAAOP,EAAIqB,EAAUrB,EACrBO,EAAON,EAAIoB,EAAUpB,EACrBM,EAAOL,EAAImB,EAAUnB,EACdK,GANE,IAAIR,EAAWsB,EAAUrB,EAAGqB,EAAUpB,EAAGoB,EAAUnB,IAkB9DH,EAAWuB,eAAiBvB,EAAWqB,MAMvCrB,EAAWwB,aAAe,EAW1BxB,EAAWyB,KAAO,SAAUC,EAAOC,EAAOC,GAYxC,OAVAnB,QAAMC,OAAOC,OAAO,QAASe,GAC7BjB,QAAMG,QAAQ,QAASe,GAGvBC,EAAgBvB,eAAauB,EAAe,GAE5CD,EAAMC,KAAmBF,EAAMzB,EAC/B0B,EAAMC,KAAmBF,EAAMxB,EAC/ByB,EAAMC,GAAiBF,EAAMvB,EAEtBwB,GAWT3B,EAAW6B,OAAS,SAAUF,EAAOC,EAAepB,GAalD,OAXAC,QAAMG,QAAQ,QAASe,GAGvBC,EAAgBvB,eAAauB,EAAe,GAEvChB,UAAQJ,KACXA,EAAS,IAAIR,GAEfQ,EAAOP,EAAI0B,EAAMC,KACjBpB,EAAON,EAAIyB,EAAMC,KACjBpB,EAAOL,EAAIwB,EAAMC,GACVpB,GAUTR,EAAW8B,UAAY,SAAUH,EAAOnB,GAEtCC,QAAMG,QAAQ,QAASe,GAGvB,IAAII,EAASJ,EAAMI,OACfC,EAAwB,EAATD,EACnB,GAAKnB,UAAQJ,GAEN,CAAA,IAAKyB,MAAMC,QAAQ1B,IAAWA,EAAOuB,SAAWC,EACrD,MAAM,IAAIG,iBACR,8EAEO3B,EAAOuB,SAAWC,IAC3BxB,EAAOuB,OAASC,QANhBxB,EAAS,IAAIyB,MAAMD,GASrB,IAAK,IAAII,EAAI,EAAGA,EAAIL,IAAUK,EAC5BpC,EAAWyB,KAAKE,EAAMS,GAAI5B,EAAY,EAAJ4B,GAEpC,OAAO5B,GAUTR,EAAWqC,YAAc,SAAUV,EAAOnB,GAIxC,GAFAC,QAAMG,QAAQ,QAASe,GACvBlB,QAAMC,OAAO4B,OAAOC,oBAAoB,eAAgBZ,EAAMI,OAAQ,GAClEJ,EAAMI,OAAS,GAAM,EACvB,MAAM,IAAII,iBAAe,yCAI3B,IAAIJ,EAASJ,EAAMI,OACdnB,UAAQJ,GAGXA,EAAOuB,OAASA,EAAS,EAFzBvB,EAAS,IAAIyB,MAAMF,EAAS,GAK9B,IAAK,IAAIK,EAAI,EAAGA,EAAIL,EAAQK,GAAK,EAAG,CAClC,IAAII,EAAQJ,EAAI,EAChB5B,EAAOgC,GAASxC,EAAW6B,OAAOF,EAAOS,EAAG5B,EAAOgC,IAErD,OAAOhC,GAqBTR,EAAWyC,UAAYzC,EAAW6B,OAQlC7B,EAAW0C,iBAAmB,SAAUpB,GAKtC,OAHAb,QAAMC,OAAOC,OAAO,YAAaW,GAG1BL,KAAK0B,IAAIrB,EAAUrB,EAAGqB,EAAUpB,EAAGoB,EAAUnB,IAStDH,EAAW4C,iBAAmB,SAAUtB,GAKtC,OAHAb,QAAMC,OAAOC,OAAO,YAAaW,GAG1BL,KAAK4B,IAAIvB,EAAUrB,EAAGqB,EAAUpB,EAAGoB,EAAUnB,IAWtDH,EAAW8C,mBAAqB,SAAUC,EAAOC,EAAQxC,GAWvD,OATAC,QAAMC,OAAOC,OAAO,QAASoC,GAC7BtC,QAAMC,OAAOC,OAAO,SAAUqC,GAC9BvC,QAAMC,OAAOC,OAAO,SAAUH,GAG9BA,EAAOP,EAAIgB,KAAK4B,IAAIE,EAAM9C,EAAG+C,EAAO/C,GACpCO,EAAON,EAAIe,KAAK4B,IAAIE,EAAM7C,EAAG8C,EAAO9C,GACpCM,EAAOL,EAAIc,KAAK4B,IAAIE,EAAM5C,EAAG6C,EAAO7C,GAE7BK,GAWTR,EAAWiD,mBAAqB,SAAUF,EAAOC,EAAQxC,GAUvD,OARAC,QAAMC,OAAOC,OAAO,QAASoC,GAC7BtC,QAAMC,OAAOC,OAAO,SAAUqC,GAC9BvC,QAAMC,OAAOC,OAAO,SAAUH,GAG9BA,EAAOP,EAAIgB,KAAK0B,IAAII,EAAM9C,EAAG+C,EAAO/C,GACpCO,EAAON,EAAIe,KAAK0B,IAAII,EAAM7C,EAAG8C,EAAO9C,GACpCM,EAAOL,EAAIc,KAAK0B,IAAII,EAAM5C,EAAG6C,EAAO7C,GAC7BK,GASTR,EAAWkD,iBAAmB,SAAU5B,GAKtC,OAHAb,QAAMC,OAAOC,OAAO,YAAaW,GAI/BA,EAAUrB,EAAIqB,EAAUrB,EACxBqB,EAAUpB,EAAIoB,EAAUpB,EACxBoB,EAAUnB,EAAImB,EAAUnB,GAU5BH,EAAWe,UAAY,SAAUO,GAC/B,OAAOL,KAAKkC,KAAKnD,EAAWkD,iBAAiB5B,KAG/C,IAAI8B,EAAkB,IAAIpD,EAa1BA,EAAWqD,SAAW,SAAUC,EAAMC,GAOpC,OALA9C,QAAMC,OAAOC,OAAO,OAAQ2C,GAC5B7C,QAAMC,OAAOC,OAAO,QAAS4C,GAG7BvD,EAAWwD,SAASF,EAAMC,EAAOH,GAC1BpD,EAAWe,UAAUqC,IAe9BpD,EAAWyD,gBAAkB,SAAUH,EAAMC,GAO3C,OALA9C,QAAMC,OAAOC,OAAO,OAAQ2C,GAC5B7C,QAAMC,OAAOC,OAAO,QAAS4C,GAG7BvD,EAAWwD,SAASF,EAAMC,EAAOH,GAC1BpD,EAAWkD,iBAAiBE,IAUrCpD,EAAW0D,UAAY,SAAUpC,EAAWd,GAE1CC,QAAMC,OAAOC,OAAO,YAAaW,GACjCb,QAAMC,OAAOC,OAAO,SAAUH,GAG9B,IAAIO,EAAYf,EAAWe,UAAUO,GAOrC,GALAd,EAAOP,EAAIqB,EAAUrB,EAAIc,EACzBP,EAAON,EAAIoB,EAAUpB,EAAIa,EACzBP,EAAOL,EAAImB,EAAUnB,EAAIY,EAGrB4C,MAAMnD,EAAOP,IAAM0D,MAAMnD,EAAON,IAAMyD,MAAMnD,EAAOL,GACrD,MAAM,IAAIgC,iBAAe,qCAI3B,OAAO3B,GAUTR,EAAW4D,IAAM,SAAUN,EAAMC,GAM/B,OAJA9C,QAAMC,OAAOC,OAAO,OAAQ2C,GAC5B7C,QAAMC,OAAOC,OAAO,QAAS4C,GAGtBD,EAAKrD,EAAIsD,EAAMtD,EAAIqD,EAAKpD,EAAIqD,EAAMrD,EAAIoD,EAAKnD,EAAIoD,EAAMpD,GAW9DH,EAAW6D,mBAAqB,SAAUP,EAAMC,EAAO/C,GAUrD,OARAC,QAAMC,OAAOC,OAAO,OAAQ2C,GAC5B7C,QAAMC,OAAOC,OAAO,QAAS4C,GAC7B9C,QAAMC,OAAOC,OAAO,SAAUH,GAG9BA,EAAOP,EAAIqD,EAAKrD,EAAIsD,EAAMtD,EAC1BO,EAAON,EAAIoD,EAAKpD,EAAIqD,EAAMrD,EAC1BM,EAAOL,EAAImD,EAAKnD,EAAIoD,EAAMpD,EACnBK,GAWTR,EAAW8D,iBAAmB,SAAUR,EAAMC,EAAO/C,GAUnD,OARAC,QAAMC,OAAOC,OAAO,OAAQ2C,GAC5B7C,QAAMC,OAAOC,OAAO,QAAS4C,GAC7B9C,QAAMC,OAAOC,OAAO,SAAUH,GAG9BA,EAAOP,EAAIqD,EAAKrD,EAAIsD,EAAMtD,EAC1BO,EAAON,EAAIoD,EAAKpD,EAAIqD,EAAMrD,EAC1BM,EAAOL,EAAImD,EAAKnD,EAAIoD,EAAMpD,EACnBK,GAWTR,EAAW+D,IAAM,SAAUT,EAAMC,EAAO/C,GAUtC,OARAC,QAAMC,OAAOC,OAAO,OAAQ2C,GAC5B7C,QAAMC,OAAOC,OAAO,QAAS4C,GAC7B9C,QAAMC,OAAOC,OAAO,SAAUH,GAG9BA,EAAOP,EAAIqD,EAAKrD,EAAIsD,EAAMtD,EAC1BO,EAAON,EAAIoD,EAAKpD,EAAIqD,EAAMrD,EAC1BM,EAAOL,EAAImD,EAAKnD,EAAIoD,EAAMpD,EACnBK,GAWTR,EAAWwD,SAAW,SAAUF,EAAMC,EAAO/C,GAU3C,OARAC,QAAMC,OAAOC,OAAO,OAAQ2C,GAC5B7C,QAAMC,OAAOC,OAAO,QAAS4C,GAC7B9C,QAAMC,OAAOC,OAAO,SAAUH,GAG9BA,EAAOP,EAAIqD,EAAKrD,EAAIsD,EAAMtD,EAC1BO,EAAON,EAAIoD,EAAKpD,EAAIqD,EAAMrD,EAC1BM,EAAOL,EAAImD,EAAKnD,EAAIoD,EAAMpD,EACnBK,GAWTR,EAAWgE,iBAAmB,SAAU1C,EAAW2C,EAAQzD,GAUzD,OARAC,QAAMC,OAAOC,OAAO,YAAaW,GACjCb,QAAMC,OAAO4B,OAAO,SAAU2B,GAC9BxD,QAAMC,OAAOC,OAAO,SAAUH,GAG9BA,EAAOP,EAAIqB,EAAUrB,EAAIgE,EACzBzD,EAAON,EAAIoB,EAAUpB,EAAI+D,EACzBzD,EAAOL,EAAImB,EAAUnB,EAAI8D,EAClBzD,GAWTR,EAAWkE,eAAiB,SAAU5C,EAAW2C,EAAQzD,GAUvD,OARAC,QAAMC,OAAOC,OAAO,YAAaW,GACjCb,QAAMC,OAAO4B,OAAO,SAAU2B,GAC9BxD,QAAMC,OAAOC,OAAO,SAAUH,GAG9BA,EAAOP,EAAIqB,EAAUrB,EAAIgE,EACzBzD,EAAON,EAAIoB,EAAUpB,EAAI+D,EACzBzD,EAAOL,EAAImB,EAAUnB,EAAI8D,EAClBzD,GAUTR,EAAWmE,OAAS,SAAU7C,EAAWd,GASvC,OAPAC,QAAMC,OAAOC,OAAO,YAAaW,GACjCb,QAAMC,OAAOC,OAAO,SAAUH,GAG9BA,EAAOP,GAAKqB,EAAUrB,EACtBO,EAAON,GAAKoB,EAAUpB,EACtBM,EAAOL,GAAKmB,EAAUnB,EACfK,GAUTR,EAAWoE,IAAM,SAAU9C,EAAWd,GASpC,OAPAC,QAAMC,OAAOC,OAAO,YAAaW,GACjCb,QAAMC,OAAOC,OAAO,SAAUH,GAG9BA,EAAOP,EAAIgB,KAAKmD,IAAI9C,EAAUrB,GAC9BO,EAAON,EAAIe,KAAKmD,IAAI9C,EAAUpB,GAC9BM,EAAOL,EAAIc,KAAKmD,IAAI9C,EAAUnB,GACvBK,GAGT,IAAI6D,EAAc,IAAIrE,EAUtBA,EAAWsE,KAAO,SAAUC,EAAOC,EAAKC,EAAGjE,GAUzC,OARAC,QAAMC,OAAOC,OAAO,QAAS4D,GAC7B9D,QAAMC,OAAOC,OAAO,MAAO6D,GAC3B/D,QAAMC,OAAO4B,OAAO,IAAKmC,GACzBhE,QAAMC,OAAOC,OAAO,SAAUH,GAG9BR,EAAWgE,iBAAiBQ,EAAKC,EAAGJ,GACpC7D,EAASR,EAAWgE,iBAAiBO,EAAO,EAAME,EAAGjE,GAC9CR,EAAW+D,IAAIM,EAAa7D,EAAQA,IAG7C,IAAIkE,EAAsB,IAAI1E,EAC1B2E,EAAuB,IAAI3E,EAQ/BA,EAAW4E,aAAe,SAAUtB,EAAMC,GAExC9C,QAAMC,OAAOC,OAAO,OAAQ2C,GAC5B7C,QAAMC,OAAOC,OAAO,QAAS4C,GAG7BvD,EAAW0D,UAAUJ,EAAMoB,GAC3B1E,EAAW0D,UAAUH,EAAOoB,GAC5B,IAAIE,EAAS7E,EAAW4D,IAAIc,EAAqBC,GAC7CG,EAAO9E,EAAWe,UACpBf,EAAW+E,MACTL,EACAC,EACAD,IAGJ,OAAOzD,KAAK+D,MAAMF,EAAMD,IAG1B,IAAII,EAA4B,IAAIjF,EAQpCA,EAAWkF,mBAAqB,SAAU5D,EAAWd,GAEnDC,QAAMC,OAAOC,OAAO,YAAaW,GACjCb,QAAMC,OAAOC,OAAO,SAAUH,GAG9B,IAAI2E,EAAInF,EAAW0D,UAAUpC,EAAW2D,GAexC,OAdAjF,EAAWoE,IAAIe,EAAGA,GAId3E,EAFA2E,EAAElF,GAAKkF,EAAEjF,EACPiF,EAAElF,GAAKkF,EAAEhF,EACFH,EAAWqB,MAAMrB,EAAWoF,OAAQ5E,GAEpCR,EAAWqB,MAAMrB,EAAWqF,OAAQ7E,GAEtC2E,EAAEjF,GAAKiF,EAAEhF,EACTH,EAAWqB,MAAMrB,EAAWsF,OAAQ9E,GAEpCR,EAAWqB,MAAMrB,EAAWqF,OAAQ7E,IAajDR,EAAWuF,cAAgB,SAAUC,EAAGC,EAAGjF,GAEzCC,QAAMG,QAAQ,IAAK4E,GACnB/E,QAAMG,QAAQ,IAAK6E,GACnBhF,QAAMG,QAAQ,SAAUJ,GAGxB,IAAIyD,EAASjE,EAAW4D,IAAI4B,EAAGC,GAAKzF,EAAW4D,IAAI6B,EAAGA,GACtD,OAAOzF,EAAWgE,iBAAiByB,EAAGxB,EAAQzD,IAWhDR,EAAW0F,OAAS,SAAUpC,EAAMC,GAClC,OACED,IAASC,GACR3C,UAAQ0C,IACP1C,UAAQ2C,IACRD,EAAKrD,IAAMsD,EAAMtD,GACjBqD,EAAKpD,IAAMqD,EAAMrD,GACjBoD,EAAKnD,IAAMoD,EAAMpD,GAOvBH,EAAW2F,YAAc,SAAUrE,EAAWK,EAAOiE,GACnD,OACEtE,EAAUrB,IAAM0B,EAAMiE,IACtBtE,EAAUpB,IAAMyB,EAAMiE,EAAS,IAC/BtE,EAAUnB,IAAMwB,EAAMiE,EAAS,IAenC5F,EAAW6F,cAAgB,SACzBvC,EACAC,EACAuC,EACAC,GAEA,OACEzC,IAASC,GACR3C,UAAQ0C,IACP1C,UAAQ2C,IACRyC,aAAWH,cACTvC,EAAKrD,EACLsD,EAAMtD,EACN6F,EACAC,IAEFC,aAAWH,cACTvC,EAAKpD,EACLqD,EAAMrD,EACN4F,EACAC,IAEFC,aAAWH,cACTvC,EAAKnD,EACLoD,EAAMpD,EACN2F,EACAC,IAaR/F,EAAW+E,MAAQ,SAAUzB,EAAMC,EAAO/C,GAExCC,QAAMC,OAAOC,OAAO,OAAQ2C,GAC5B7C,QAAMC,OAAOC,OAAO,QAAS4C,GAC7B9C,QAAMC,OAAOC,OAAO,SAAUH,GAG9B,IAAIyF,EAAQ3C,EAAKrD,EACbiG,EAAQ5C,EAAKpD,EACbiG,EAAQ7C,EAAKnD,EACbiG,EAAS7C,EAAMtD,EACfoG,EAAS9C,EAAMrD,EACfoG,EAAS/C,EAAMpD,EAEfF,EAAIiG,EAAQI,EAASH,EAAQE,EAC7BnG,EAAIiG,EAAQC,EAASH,EAAQK,EAC7BnG,EAAI8F,EAAQI,EAASH,EAAQE,EAKjC,OAHA5F,EAAOP,EAAIA,EACXO,EAAON,EAAIA,EACXM,EAAOL,EAAIA,EACJK,GAUTR,EAAWuG,SAAW,SAAUjD,EAAMC,EAAO/C,GAW3C,OATAC,QAAMC,OAAOC,OAAO,OAAQ2C,GAC5B7C,QAAMC,OAAOC,OAAO,QAAS4C,GAC7B9C,QAAMC,OAAOC,OAAO,SAAUH,GAG9BA,EAAOP,EAAyB,IAApBqD,EAAKrD,EAAIsD,EAAMtD,GAC3BO,EAAON,EAAyB,IAApBoD,EAAKpD,EAAIqD,EAAMrD,GAC3BM,EAAOL,EAAyB,IAApBmD,EAAKnD,EAAIoD,EAAMpD,GAEpBK,GAgBTR,EAAWwG,YAAc,SACvBC,EACAC,EACAC,EACAC,EACApG,GASA,OANAC,QAAMC,OAAO4B,OAAO,YAAamE,GACjChG,QAAMC,OAAO4B,OAAO,WAAYoE,GAGhCD,EAAYT,aAAWa,UAAUJ,GACjCC,EAAWV,aAAWa,UAAUH,GACzB1G,EAAW8G,YAAYL,EAAWC,EAAUC,EAAQC,EAAWpG,IAGxE,IAAIuG,EAAW,IAAI/G,EACfgH,EAAW,IAAIhH,EACfiH,EAAoB,IAAIjH,EAC1B,eACA,eACA,oBAgBFA,EAAW8G,YAAc,SACvBL,EACAC,EACAC,EACAC,EACApG,GAGAC,QAAMC,OAAO4B,OAAO,YAAamE,GACjChG,QAAMC,OAAO4B,OAAO,WAAYoE,GAGhCC,EAAStG,eAAasG,EAAQ,GAC9B,IAAIO,EAAetG,UAAQgG,GACvBA,EAAUM,aACVD,EAEAE,EAAclG,KAAKE,IAAIuF,GAC3BK,EAAS9G,EAAIkH,EAAclG,KAAKE,IAAIsF,GACpCM,EAAS7G,EAAIiH,EAAclG,KAAKC,IAAIuF,GACpCM,EAAS5G,EAAIc,KAAKC,IAAIwF,GACtBK,EAAW/G,EAAW0D,UAAUqD,EAAUA,GAE1C/G,EAAW6D,mBAAmBqD,EAAcH,EAAUC,GACtD,IAAII,EAAQnG,KAAKkC,KAAKnD,EAAW4D,IAAImD,EAAUC,IAO/C,OANAA,EAAWhH,EAAWkE,eAAe8C,EAAUI,EAAOJ,GACtDD,EAAW/G,EAAWgE,iBAAiB+C,EAAUJ,EAAQI,GAEpDnG,UAAQJ,KACXA,EAAS,IAAIR,GAERA,EAAW+D,IAAIiD,EAAUD,EAAUvG,IAc5CR,EAAWqH,iBAAmB,SAAUC,EAAaV,EAAWpG,GAG9D,GADAC,QAAMG,QAAQ,cAAe0G,GACzBA,EAAYvF,OAAS,GAAKuF,EAAYvF,OAAS,GAAM,EACvD,MAAM,IAAII,iBACR,oEAKJ,IAAIJ,EAASuF,EAAYvF,OACpBnB,UAAQJ,GAGXA,EAAOuB,OAASA,EAAS,EAFzBvB,EAAS,IAAIyB,MAAMF,EAAS,GAK9B,IAAK,IAAIK,EAAI,EAAGA,EAAIL,EAAQK,GAAK,EAAG,CAClC,IAAIqE,EAAYa,EAAYlF,GACxBsE,EAAWY,EAAYlF,EAAI,GAC3BI,EAAQJ,EAAI,EAChB5B,EAAOgC,GAASxC,EAAWwG,YACzBC,EACAC,EACA,EACAE,EACApG,EAAOgC,IAIX,OAAOhC,GAcTR,EAAWuH,iBAAmB,SAAUD,EAAaV,EAAWpG,GAG9D,GADAC,QAAMG,QAAQ,cAAe0G,GACzBA,EAAYvF,OAAS,GAAKuF,EAAYvF,OAAS,GAAM,EACvD,MAAM,IAAII,iBACR,oEAKJ,IAAIJ,EAASuF,EAAYvF,OACpBnB,UAAQJ,GAGXA,EAAOuB,OAASA,EAAS,EAFzBvB,EAAS,IAAIyB,MAAMF,EAAS,GAK9B,IAAK,IAAIK,EAAI,EAAGA,EAAIL,EAAQK,GAAK,EAAG,CAClC,IAAIqE,EAAYa,EAAYlF,GACxBsE,EAAWY,EAAYlF,EAAI,GAC3BI,EAAQJ,EAAI,EAChB5B,EAAOgC,GAASxC,EAAW8G,YACzBL,EACAC,EACA,EACAE,EACApG,EAAOgC,IAIX,OAAOhC,GAcTR,EAAWwH,wBAA0B,SAAUF,EAAaV,EAAWpG,GAGrE,GADAC,QAAMG,QAAQ,cAAe0G,GACzBA,EAAYvF,OAAS,GAAKuF,EAAYvF,OAAS,GAAM,EACvD,MAAM,IAAII,iBACR,oEAKJ,IAAIJ,EAASuF,EAAYvF,OACpBnB,UAAQJ,GAGXA,EAAOuB,OAASA,EAAS,EAFzBvB,EAAS,IAAIyB,MAAMF,EAAS,GAK9B,IAAK,IAAIK,EAAI,EAAGA,EAAIL,EAAQK,GAAK,EAAG,CAClC,IAAIqE,EAAYa,EAAYlF,GACxBsE,EAAWY,EAAYlF,EAAI,GAC3BuE,EAASW,EAAYlF,EAAI,GACzBI,EAAQJ,EAAI,EAChB5B,EAAOgC,GAASxC,EAAWwG,YACzBC,EACAC,EACAC,EACAC,EACApG,EAAOgC,IAIX,OAAOhC,GAcTR,EAAWyH,wBAA0B,SAAUH,EAAaV,EAAWpG,GAGrE,GADAC,QAAMG,QAAQ,cAAe0G,GACzBA,EAAYvF,OAAS,GAAKuF,EAAYvF,OAAS,GAAM,EACvD,MAAM,IAAII,iBACR,oEAKJ,IAAIJ,EAASuF,EAAYvF,OACpBnB,UAAQJ,GAGXA,EAAOuB,OAASA,EAAS,EAFzBvB,EAAS,IAAIyB,MAAMF,EAAS,GAK9B,IAAK,IAAIK,EAAI,EAAGA,EAAIL,EAAQK,GAAK,EAAG,CAClC,IAAIqE,EAAYa,EAAYlF,GACxBsE,EAAWY,EAAYlF,EAAI,GAC3BuE,EAASW,EAAYlF,EAAI,GACzBI,EAAQJ,EAAI,EAChB5B,EAAOgC,GAASxC,EAAW8G,YACzBL,EACAC,EACAC,EACAC,EACApG,EAAOgC,IAIX,OAAOhC,GASTR,EAAW0H,KAAOC,OAAOC,OAAO,IAAI5H,EAAW,EAAK,EAAK,IAQzDA,EAAW6H,IAAMF,OAAOC,OAAO,IAAI5H,EAAW,EAAK,EAAK,IAQxDA,EAAWoF,OAASuC,OAAOC,OAAO,IAAI5H,EAAW,EAAK,EAAK,IAQ3DA,EAAWsF,OAASqC,OAAOC,OAAO,IAAI5H,EAAW,EAAK,EAAK,IAQ3DA,EAAWqF,OAASsC,OAAOC,OAAO,IAAI5H,EAAW,EAAK,EAAK,IAQ3DA,EAAW8H,UAAUzG,MAAQ,SAAUb,GACrC,OAAOR,EAAWqB,MAAMjB,KAAMI,IAUhCR,EAAW8H,UAAUpC,OAAS,SAAUnC,GACtC,OAAOvD,EAAW0F,OAAOtF,KAAMmD,IAajCvD,EAAW8H,UAAUjC,cAAgB,SACnCtC,EACAuC,EACAC,GAEA,OAAO/F,EAAW6F,cAChBzF,KACAmD,EACAuC,EACAC,IASJ/F,EAAW8H,UAAUC,SAAW,WAC9B,MAAO,IAAM3H,KAAKH,EAAI,KAAOG,KAAKF,EAAI,KAAOE,KAAKD,EAAI,KC5pCxD,IAAI6H,EAAqC,IAAIhI,EACzCiI,EAAiC,IAAIjI,EAkBzC,SAASkI,EACP5G,EACA6G,EACAC,EACAC,EACA7H,GAGA,IAAKI,UAAQU,GACX,MAAM,IAAIa,iBAAe,0BAE3B,IAAKvB,UAAQuH,GACX,MAAM,IAAIhG,iBAAe,6BAE3B,IAAKvB,UAAQwH,GACX,MAAM,IAAIjG,iBAAe,oCAE3B,IAAKvB,UAAQyH,GACX,MAAM,IAAIlG,iBAAe,uCAI3B,IAAImG,EAAYhH,EAAUrB,EACtBsI,EAAYjH,EAAUpB,EACtBsI,EAAYlH,EAAUnB,EAEtBsI,EAAgBN,EAAalI,EAC7ByI,EAAgBP,EAAajI,EAC7ByI,EAAgBR,EAAahI,EAE7ByI,EAAKN,EAAYA,EAAYG,EAAgBA,EAC7CI,EAAKN,EAAYA,EAAYG,EAAgBA,EAC7CI,EAAKN,EAAYA,EAAYG,EAAgBA,EAG7CI,EAAcH,EAAKC,EAAKC,EACxBE,EAAQ/H,KAAKkC,KAAK,EAAM4F,GAGxBE,EAAejJ,EAAWgE,iBAC5B1C,EACA0H,EACAhB,GAIF,GAAIe,EAAcV,EAChB,OAAQa,SAASF,GAEbhJ,EAAWqB,MAAM4H,EAAczI,QAD/B2I,EAIN,IAAIC,EAAuBhB,EAAoBnI,EAC3CoJ,EAAuBjB,EAAoBlI,EAC3CoJ,EAAuBlB,EAAoBjI,EAI3CoJ,EAAWtB,EACfsB,EAAStJ,EAAIgJ,EAAahJ,EAAImJ,EAAuB,EACrDG,EAASrJ,EAAI+I,EAAa/I,EAAImJ,EAAuB,EACrDE,EAASpJ,EAAI8I,EAAa9I,EAAImJ,EAAuB,EAGrD,IAKIE,EAEAC,EACAC,EACAC,EACAC,EACAC,EACAC,EAZAC,GACA,EAAMf,GAAShJ,EAAWe,UAAUO,IACrC,GAAMtB,EAAWe,UAAUwI,IAC1BS,EAAa,EAcjB,EAAG,CA0BDA,GAXAR,EAAOZ,GARPgB,GAJAH,EAAc,GAAO,GAFrBM,GAAUC,GAE0BZ,IAIPK,GAQFZ,GAP3BgB,GAJAH,EAAc,GAAO,EAAMK,EAASV,IAIPK,GAOkBZ,GAN/CgB,GAJAH,EAAc,GAAO,EAAMI,EAAST,IAIPK,GAMsC,KASjD,GAJhBf,GATagB,EAAeH,GASRL,EACpBP,GATagB,EAAeH,GASRL,EACpBP,GATagB,EAAeH,GASRL,UAKfrI,KAAKmD,IAAIoF,GAAQxD,aAAWiE,WAErC,OAAKrJ,UAAQJ,IAObA,EAAOP,EAAIqI,EAAYmB,EACvBjJ,EAAON,EAAIqI,EAAYmB,EACvBlJ,EAAOL,EAAIqI,EAAYmB,EAChBnJ,GATE,IAAIR,EACTsI,EAAYmB,EACZlB,EAAYmB,EACZlB,EAAYmB,GCxHlB,SAASO,EAAazD,EAAWC,EAAUC,GAMzCvG,KAAKqG,UAAYpG,eAAaoG,EAAW,GAOzCrG,KAAKsG,SAAWrG,eAAaqG,EAAU,GAOvCtG,KAAKuG,OAAStG,eAAasG,EAAQ,GAarCuD,EAAapD,YAAc,SAAUL,EAAWC,EAAUC,EAAQnG,GAQhE,OANAC,QAAMC,OAAO4B,OAAO,YAAamE,GACjChG,QAAMC,OAAO4B,OAAO,WAAYoE,GAGhCC,EAAStG,eAAasG,EAAQ,GAEzB/F,UAAQJ,IAIbA,EAAOiG,UAAYA,EACnBjG,EAAOkG,SAAWA,EAClBlG,EAAOmG,OAASA,EACTnG,GANE,IAAI0J,EAAazD,EAAWC,EAAUC,IAoBjDuD,EAAa1D,YAAc,SAAUC,EAAWC,EAAUC,EAAQnG,GAQhE,OANAC,QAAMC,OAAO4B,OAAO,YAAamE,GACjChG,QAAMC,OAAO4B,OAAO,WAAYoE,GAEhCD,EAAYT,aAAWa,UAAUJ,GACjCC,EAAWV,aAAWa,UAAUH,GAEzBwD,EAAapD,YAAYL,EAAWC,EAAUC,EAAQnG,IAG/D,IAAI2J,EAA2B,IAAInK,EAC/BoK,EAA2B,IAAIpK,EAC/BqK,EAA2B,IAAIrK,EAC/BsK,EAAoB,IAAItK,EAC1B,EAAM,QACN,EAAM,QACN,EAAM,mBAEJuK,EAA2B,IAAIvK,EACjC,iBACA,iBACA,sBAEEwK,EAA8BxE,aAAWyE,SC/F7C,SAASC,EAAW9D,EAAW3G,EAAGC,EAAGC,GACnCF,EAAII,eAAaJ,EAAG,GACpBC,EAAIG,eAAaH,EAAG,GACpBC,EAAIE,eAAaF,EAAG,GAGpBM,QAAMC,OAAO4B,OAAOC,oBAAoB,IAAKtC,EAAG,GAChDQ,QAAMC,OAAO4B,OAAOC,oBAAoB,IAAKrC,EAAG,GAChDO,QAAMC,OAAO4B,OAAOC,oBAAoB,IAAKpC,EAAG,GAGhDyG,EAAU+D,OAAS,IAAI3K,EAAWC,EAAGC,EAAGC,GAExCyG,EAAUgE,cAAgB,IAAI5K,EAAWC,EAAIA,EAAGC,EAAIA,EAAGC,EAAIA,GAE3DyG,EAAUiE,kBAAoB,IAAI7K,EAChCC,EAAIA,EAAIA,EAAIA,EACZC,EAAIA,EAAIA,EAAIA,EACZC,EAAIA,EAAIA,EAAIA,GAGdyG,EAAUkE,cAAgB,IAAI9K,EACtB,IAANC,EAAY,EAAM,EAAMA,EAClB,IAANC,EAAY,EAAM,EAAMA,EAClB,IAANC,EAAY,EAAM,EAAMA,GAG1ByG,EAAUmE,qBAAuB,IAAI/K,EAC7B,IAANC,EAAY,EAAM,GAAOA,EAAIA,GACvB,IAANC,EAAY,EAAM,GAAOA,EAAIA,GACvB,IAANC,EAAY,EAAM,GAAOA,EAAIA,IAG/ByG,EAAUoE,eAAiB/J,KAAK4B,IAAI5C,EAAGC,EAAGC,GAE1CyG,EAAUqE,eAAiBhK,KAAK0B,IAAI1C,EAAGC,EAAGC,GAE1CyG,EAAUsE,wBAA0BlF,aAAWyE,SAEb,IAA9B7D,EAAUgE,cAAczK,IAC1ByG,EAAUuE,sBACRvE,EAAUgE,cAAc3K,EAAI2G,EAAUgE,cAAczK,GAwB1D,SAASiL,EAAUnL,EAAGC,EAAGC,GACvBC,KAAKuK,YAASxB,EACd/I,KAAKwK,mBAAgBzB,EACrB/I,KAAKyK,uBAAoB1B,EACzB/I,KAAK0K,mBAAgB3B,EACrB/I,KAAK2K,0BAAuB5B,EAC5B/I,KAAK4K,oBAAiB7B,EACtB/I,KAAK6K,oBAAiB9B,EACtB/I,KAAK8K,6BAA0B/B,EAC/B/I,KAAK+K,2BAAwBhC,EAE7BuB,EAAWtK,KAAMH,EAAGC,EAAGC,GD8BzB+J,EAAamB,cAAgB,SAAU/J,EAAWsF,EAAWpG,GAC3D,IAAI2H,EAAevH,UAAQgG,GACvBA,EAAUuB,aACVmC,EACAlC,EAAsBxH,UAAQgG,GAC9BA,EAAUwB,oBACVmC,EAMAe,EAAIpD,EACN5G,EACA6G,EACAC,EAR2BxH,UAAQgG,GACjCA,EAAUsE,wBACVV,EAQFJ,GAGF,GAAKxJ,UAAQ0K,GAAb,CAIA,IAAIC,EAAIvL,EAAW6D,mBACjByH,EACAlD,EACA+B,GAEFoB,EAAIvL,EAAW0D,UAAU6H,EAAGA,GAE5B,IAAIC,EAAIxL,EAAWwD,SAASlC,EAAWgK,EAAGjB,GAEtC5D,EAAYxF,KAAK+D,MAAMuG,EAAErL,EAAGqL,EAAEtL,GAC9ByG,EAAWzF,KAAKwK,KAAKF,EAAEpL,GACvBwG,EACFX,aAAW0F,KAAK1L,EAAW4D,IAAI4H,EAAGlK,IAActB,EAAWe,UAAUyK,GAEvE,OAAK5K,UAAQJ,IAGbA,EAAOiG,UAAYA,EACnBjG,EAAOkG,SAAWA,EAClBlG,EAAOmG,OAASA,EACTnG,GALE,IAAI0J,EAAazD,EAAWC,EAAUC,KAiBjDuD,EAAayB,YAAc,SAAUC,EAAchF,EAAWpG,GAK5D,OAHAC,QAAMG,QAAQ,eAAgBgL,GAGvB5L,EAAW8G,YAChB8E,EAAanF,UACbmF,EAAalF,SACbkF,EAAajF,OACbC,EACApG,IAWJ0J,EAAa7I,MAAQ,SAAUuK,EAAcpL,GAC3C,GAAKI,UAAQgL,GAGb,OAAKhL,UAAQJ,IAObA,EAAOiG,UAAYmF,EAAanF,UAChCjG,EAAOkG,SAAWkF,EAAalF,SAC/BlG,EAAOmG,OAASiF,EAAajF,OACtBnG,GATE,IAAI0J,EACT0B,EAAanF,UACbmF,EAAalF,SACbkF,EAAajF,SAiBnBuD,EAAaxE,OAAS,SAAUpC,EAAMC,GACpC,OACED,IAASC,GACR3C,UAAQ0C,IACP1C,UAAQ2C,IACRD,EAAKmD,YAAclD,EAAMkD,WACzBnD,EAAKoD,WAAanD,EAAMmD,UACxBpD,EAAKqD,SAAWpD,EAAMoD,QAc5BuD,EAAarE,cAAgB,SAAUvC,EAAMC,EAAOsI,GAGlD,OAFAA,EAAUxL,eAAawL,EAAS,GAG9BvI,IAASC,GACR3C,UAAQ0C,IACP1C,UAAQ2C,IACRtC,KAAKmD,IAAId,EAAKmD,UAAYlD,EAAMkD,YAAcoF,GAC9C5K,KAAKmD,IAAId,EAAKoD,SAAWnD,EAAMmD,WAAamF,GAC5C5K,KAAKmD,IAAId,EAAKqD,OAASpD,EAAMoD,SAAWkF,GAU9C3B,EAAaxC,KAAOC,OAAOC,OAAO,IAAIsC,EAAa,EAAK,EAAK,IAQ7DA,EAAapC,UAAUzG,MAAQ,SAAUb,GACvC,OAAO0J,EAAa7I,MAAMjB,KAAMI,IAUlC0J,EAAapC,UAAUpC,OAAS,SAAUnC,GACxC,OAAO2G,EAAaxE,OAAOtF,KAAMmD,IAYnC2G,EAAapC,UAAUjC,cAAgB,SAAUtC,EAAOsI,GACtD,OAAO3B,EAAarE,cAAczF,KAAMmD,EAAOsI,IAQjD3B,EAAapC,UAAUC,SAAW,WAChC,MAAO,IAAM3H,KAAKqG,UAAY,KAAOrG,KAAKsG,SAAW,KAAOtG,KAAKuG,OAAS,KCnN5EgB,OAAOmE,iBAAiBV,EAAUtD,UAAW,CAO3CiE,MAAO,CACLC,IAAK,WACH,OAAO5L,KAAKuK,SAShBzD,aAAc,CACZ8E,IAAK,WACH,OAAO5L,KAAKwK,gBAShBqB,iBAAkB,CAChBD,IAAK,WACH,OAAO5L,KAAKyK,oBAShB1C,aAAc,CACZ6D,IAAK,WACH,OAAO5L,KAAK0K,gBAShB1C,oBAAqB,CACnB4D,IAAK,WACH,OAAO5L,KAAK2K,uBAShBmB,cAAe,CACbF,IAAK,WACH,OAAO5L,KAAK4K,iBAShBmB,cAAe,CACbH,IAAK,WACH,OAAO5L,KAAK6K,mBAalBG,EAAU/J,MAAQ,SAAUuF,EAAWpG,GACrC,GAAKI,UAAQgG,GAAb,CAGA,IAAImF,EAAQnF,EAAU+D,OAEtB,OAAK/J,UAAQJ,IAIbR,EAAWqB,MAAM0K,EAAOvL,EAAOmK,QAC/B3K,EAAWqB,MAAMuF,EAAUgE,cAAepK,EAAOoK,eACjD5K,EAAWqB,MAAMuF,EAAUiE,kBAAmBrK,EAAOqK,mBACrD7K,EAAWqB,MAAMuF,EAAUkE,cAAetK,EAAOsK,eACjD9K,EAAWqB,MAAMuF,EAAUmE,qBAAsBvK,EAAOuK,sBACxDvK,EAAOwK,eAAiBpE,EAAUoE,eAClCxK,EAAOyK,eAAiBrE,EAAUqE,eAClCzK,EAAO0K,wBAA0BtE,EAAUsE,wBAEpC1K,GAZE,IAAI4K,EAAUW,EAAM9L,EAAG8L,EAAM7L,EAAG6L,EAAM5L,KA4BjDiL,EAAUgB,eAAiB,SAAU9K,EAAWd,GAK9C,OAJKI,UAAQJ,KACXA,EAAS,IAAI4K,GAGVxK,UAAQU,IAIboJ,EAAWlK,EAAQc,EAAUrB,EAAGqB,EAAUpB,EAAGoB,EAAUnB,GAChDK,GAJEA,GAaX4K,EAAUiB,MAAQ1E,OAAOC,OACvB,IAAIwD,EAAU,QAAW,QAAW,oBAStCA,EAAUkB,YAAc3E,OAAOC,OAAO,IAAIwD,EAAU,EAAK,EAAK,IAQ9DA,EAAUmB,KAAO5E,OAAOC,OACtB,IAAIwD,EACFpF,aAAWwG,aACXxG,aAAWwG,aACXxG,aAAWwG,eAWfpB,EAAUtD,UAAUzG,MAAQ,SAAUb,GACpC,OAAO4K,EAAU/J,MAAMjB,KAAMI,IAO/B4K,EAAU5J,aAAexB,EAAWwB,aAWpC4J,EAAU3J,KAAO,SAAUC,EAAOC,EAAOC,GAUvC,OARAnB,QAAMC,OAAOC,OAAO,QAASe,GAC7BjB,QAAMG,QAAQ,QAASe,GAGvBC,EAAgBvB,eAAauB,EAAe,GAE5C5B,EAAWyB,KAAKC,EAAMiJ,OAAQhJ,EAAOC,GAE9BD,GAWTyJ,EAAUvJ,OAAS,SAAUF,EAAOC,EAAepB,GAEjDC,QAAMG,QAAQ,QAASe,GAGvBC,EAAgBvB,eAAauB,EAAe,GAE5C,IAAImK,EAAQ/L,EAAW6B,OAAOF,EAAOC,GACrC,OAAOwJ,EAAUgB,eAAeL,EAAOvL,IAWzC4K,EAAUtD,UAAU2E,wBAA0BzM,EAAW0D,UASzD0H,EAAUtD,UAAU4E,kCAAoC,SACtDd,EACApL,GAGAC,QAAMC,OAAOC,OAAO,eAAgBiL,GAGpC,IAAInF,EAAYmF,EAAanF,UACzBC,EAAWkF,EAAalF,SACxBS,EAAclG,KAAKE,IAAIuF,GAEvBzG,EAAIkH,EAAclG,KAAKE,IAAIsF,GAC3BvG,EAAIiH,EAAclG,KAAKC,IAAIuF,GAC3BtG,EAAIc,KAAKC,IAAIwF,GAQjB,OANK9F,UAAQJ,KACXA,EAAS,IAAIR,GAEfQ,EAAOP,EAAIA,EACXO,EAAON,EAAIA,EACXM,EAAOL,EAAIA,EACJH,EAAW0D,UAAUlD,EAAQA,IAUtC4K,EAAUtD,UAAU6E,sBAAwB,SAAUrL,EAAWd,GAC/D,IACER,EAAW6F,cAAcvE,EAAWtB,EAAW0H,KAAM1B,aAAW4G,WAYlE,OARKhM,UAAQJ,KACXA,EAAS,IAAIR,GAEfQ,EAASR,EAAW6D,mBAClBvC,EACAlB,KAAK2K,qBACLvK,GAEKR,EAAW0D,UAAUlD,EAAQA,IAGtC,IAAIqM,EAAgC,IAAI7M,EACpC8M,EAA2B,IAAI9M,EAcnCoL,EAAUtD,UAAUiF,wBAA0B,SAAUnB,EAAcpL,GAEpE,IAAI+K,EAAIsB,EACJG,EAAIF,EACR1M,KAAKsM,kCAAkCd,EAAcL,GACrDvL,EAAW6D,mBAAmBzD,KAAKwK,cAAeW,EAAGyB,GACrD,IAAI5F,EAAQnG,KAAKkC,KAAKnD,EAAW4D,IAAI2H,EAAGyB,IAOxC,OANAhN,EAAWkE,eAAe8I,EAAG5F,EAAO4F,GACpChN,EAAWgE,iBAAiBuH,EAAGK,EAAajF,OAAQ4E,GAE/C3K,UAAQJ,KACXA,EAAS,IAAIR,GAERA,EAAW+D,IAAIiJ,EAAGzB,EAAG/K,IAiB9B4K,EAAUtD,UAAUmF,kCAAoC,SACtDC,EACA1M,GAGAC,QAAMG,QAAQ,gBAAiBsM,GAG/B,IAAInL,EAASmL,EAAcnL,OACtBnB,UAAQJ,GAGXA,EAAOuB,OAASA,EAFhBvB,EAAS,IAAIyB,MAAMF,GAIrB,IAAK,IAAIK,EAAI,EAAGA,EAAIL,EAAQK,IAC1B5B,EAAO4B,GAAKhC,KAAK2M,wBAAwBG,EAAc9K,GAAI5B,EAAO4B,IAEpE,OAAO5B,GAGT,IAAI2J,EAA2B,IAAInK,EAC/BoK,EAA2B,IAAIpK,EAC/BqK,EAA2B,IAAIrK,EAenCoL,EAAUtD,UAAUqF,wBAA0B,SAAU7L,EAAWd,GAEjE,IAAI8K,EAAIlL,KAAK8H,uBAAuB5G,EAAW8I,GAE/C,GAAKxJ,UAAQ0K,GAAb,CAIA,IAAIC,EAAInL,KAAKuM,sBAAsBrB,EAAGnB,GAClCqB,EAAIxL,EAAWwD,SAASlC,EAAWgK,EAAGjB,GAEtC5D,EAAYxF,KAAK+D,MAAMuG,EAAErL,EAAGqL,EAAEtL,GAC9ByG,EAAWzF,KAAKwK,KAAKF,EAAEpL,GACvBwG,EACFX,aAAW0F,KAAK1L,EAAW4D,IAAI4H,EAAGlK,IAActB,EAAWe,UAAUyK,GAEvE,OAAK5K,UAAQJ,IAGbA,EAAOiG,UAAYA,EACnBjG,EAAOkG,SAAWA,EAClBlG,EAAOmG,OAASA,EACTnG,GALE,IAAI0J,EAAazD,EAAWC,EAAUC,KAsBjDyE,EAAUtD,UAAUsF,kCAAoC,SACtDC,EACA7M,GAGAC,QAAMG,QAAQ,aAAcyM,GAG5B,IAAItL,EAASsL,EAAWtL,OACnBnB,UAAQJ,GAGXA,EAAOuB,OAASA,EAFhBvB,EAAS,IAAIyB,MAAMF,GAIrB,IAAK,IAAIK,EAAI,EAAGA,EAAIL,IAAUK,EAC5B5B,EAAO4B,GAAKhC,KAAK+M,wBAAwBE,EAAWjL,GAAI5B,EAAO4B,IAEjE,OAAO5B,GAYT4K,EAAUtD,UAAUI,uBAAyB,SAAU5G,EAAWd,GAChE,OAAO0H,EACL5G,EACAlB,KAAK0K,cACL1K,KAAK2K,qBACL3K,KAAK8K,wBACL1K,IAYJ4K,EAAUtD,UAAUwF,yBAA2B,SAAUhM,EAAWd,GAElEC,QAAMC,OAAOC,OAAO,YAAaW,GAG5BV,UAAQJ,KACXA,EAAS,IAAIR,GAGf,IAAIsI,EAAYhH,EAAUrB,EACtBsI,EAAYjH,EAAUpB,EACtBsI,EAAYlH,EAAUnB,EACtBiI,EAAsBhI,KAAK2K,qBAE3BwC,EACF,EACAtM,KAAKkC,KACHmF,EAAYA,EAAYF,EAAoBnI,EAC1CsI,EAAYA,EAAYH,EAAoBlI,EAC5CsI,EAAYA,EAAYJ,EAAoBjI,GAGlD,OAAOH,EAAWgE,iBAAiB1C,EAAWiM,EAAM/M,IAatD4K,EAAUtD,UAAU0F,+BAAiC,SACnDC,EACAjN,GAMA,OAJKI,UAAQJ,KACXA,EAAS,IAAIR,GAGRA,EAAW6D,mBAAmB4J,EAAUrN,KAAK0K,cAAetK,IAarE4K,EAAUtD,UAAU4F,iCAAmC,SACrDD,EACAjN,GAMA,OAJKI,UAAQJ,KACXA,EAAS,IAAIR,GAGRA,EAAW6D,mBAAmB4J,EAAUrN,KAAKuK,OAAQnK,IAU9D4K,EAAUtD,UAAUpC,OAAS,SAAUnC,GACrC,OACEnD,OAASmD,GACR3C,UAAQ2C,IAAUvD,EAAW0F,OAAOtF,KAAKuK,OAAQpH,EAAMoH,SAS5DS,EAAUtD,UAAUC,SAAW,WAC7B,OAAO3H,KAAKuK,OAAO5C,YAmBrBqD,EAAUtD,UAAU6F,sCAAwC,SAC1DF,EACAG,EACApN,GAKA,GAFAC,QAAMC,OAAOC,OAAO,WAAY8M,IAG7BzH,aAAWH,cACVzF,KAAKuK,OAAO1K,EACZG,KAAKuK,OAAOzK,EACZ8F,aAAW6H,WAGb,MAAM,IAAI1L,iBACR,qEAIJ1B,QAAMC,OAAO4B,OAAOwL,YAAY,oBAAqB1N,KAAKuK,OAAOxK,EAAG,GAGpEyN,EAASvN,eAAauN,EAAQ,GAE9B,IAAIG,EAAuB3N,KAAK+K,sBAUhC,GARKvK,UAAQJ,KACXA,EAAS,IAAIR,GAGfQ,EAAOP,EAAI,EACXO,EAAON,EAAI,EACXM,EAAOL,EAAIsN,EAAStN,GAAK,EAAI4N,KAEzB9M,KAAKmD,IAAI5D,EAAOL,IAAMC,KAAKuK,OAAOxK,EAAIyN,GAI1C,OAAOpN,GAGT,IAAIwN,EAAY,CACd,gBACA,gBACA,gBACA,gBACA,gBACA,GAEEC,EAAU,CACZ,gBACA,gBACA,gBACA,gBACA,iBACA,GAaF,SAASC,EAAwB1I,EAAGC,EAAG+D,GAErC/I,QAAMC,OAAO4B,OAAO,IAAKkD,GACzB/E,QAAMC,OAAO4B,OAAO,IAAKmD,GACzBhF,QAAMC,OAAO8I,KAAK,OAAQA,GAS1B,IAJA,IAAI2E,EAAQ,IAAO1I,EAAID,GACnB4I,EAAS,IAAO3I,EAAID,GAEpB6I,EAAM,EACDjM,EAAI,EAAGA,EAAI,EAAGA,IAAK,CAC1B,IAAIkM,EAAKF,EAASJ,EAAU5L,GAC5BiM,GAAOJ,EAAQ7L,IAAMoH,EAAK2E,EAAQG,GAAM9E,EAAK2E,EAAQG,IAKvD,OADAD,GAAOD,ECtsBT,SAASG,EACPC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,GAEA5O,KAAK,GAAKC,eAAamO,EAAa,GACpCpO,KAAK,GAAKC,eAAasO,EAAa,GACpCvO,KAAK,GAAKC,eAAayO,EAAa,GACpC1O,KAAK,GAAKC,eAAaoO,EAAa,GACpCrO,KAAK,GAAKC,eAAauO,EAAa,GACpCxO,KAAK,GAAKC,eAAa0O,EAAa,GACpC3O,KAAK,GAAKC,eAAaqO,EAAa,GACpCtO,KAAK,GAAKC,eAAawO,EAAa,GACpCzO,KAAK,GAAKC,eAAa2O,EAAa,GDwsBtC5D,EAAUtD,UAAUmH,YAAc,SAAUC,GAE1CzO,QAAMC,OAAOC,OAAO,YAAauO,GAOjC,IALA,IAAIC,EAAeD,EAAUE,KACzBC,EAAeH,EAAUI,KACzBC,EAAcL,EAAUM,MACxBC,EAAcP,EAAUQ,MAErBL,EAAeF,GACpBE,GAAgBrJ,aAAW2J,OAG7B,IAAIzI,EAAe9G,KAAKwK,cACpBgF,EAAK1I,EAAajH,EAClB4P,EAAK3I,EAAahH,EAClB4P,EAAK5I,EAAa/G,EAClB4P,EAAOH,EAAKC,EAChB,OAAO3B,EAAwBqB,EAAaE,GAAa,SAAUO,GAGjE,IAAIC,EAAShP,KAAKE,IAAI6O,GAClBE,EAASjP,KAAKC,IAAI8O,GACtB,OACE/O,KAAKE,IAAI6O,GACT9B,EAAwBiB,EAAcE,GAAc,SAAUc,GAC5D,IAAIC,EAAWnP,KAAKE,IAAIgP,GACpBE,EAAWpP,KAAKC,IAAIiP,GACxB,OAAOlP,KAAKkC,KACV4M,EAAOG,EAASA,EACdJ,GACGD,EAAKO,EAAWA,EAAWR,EAAKS,EAAWA,GAC5CJ,EACAA,UCluBd1B,EAAQ/M,aAAe,EAWvB+M,EAAQ9M,KAAO,SAAUC,EAAOC,EAAOC,GAkBrC,OAhBAnB,QAAMC,OAAOC,OAAO,QAASe,GAC7BjB,QAAMG,QAAQ,QAASe,GAGvBC,EAAgBvB,eAAauB,EAAe,GAE5CD,EAAMC,KAAmBF,EAAM,GAC/BC,EAAMC,KAAmBF,EAAM,GAC/BC,EAAMC,KAAmBF,EAAM,GAC/BC,EAAMC,KAAmBF,EAAM,GAC/BC,EAAMC,KAAmBF,EAAM,GAC/BC,EAAMC,KAAmBF,EAAM,GAC/BC,EAAMC,KAAmBF,EAAM,GAC/BC,EAAMC,KAAmBF,EAAM,GAC/BC,EAAMC,KAAmBF,EAAM,GAExBC,GAWT4M,EAAQ1M,OAAS,SAAUF,EAAOC,EAAepB,GAoB/C,OAlBAC,QAAMG,QAAQ,QAASe,GAGvBC,EAAgBvB,eAAauB,EAAe,GAEvChB,UAAQJ,KACXA,EAAS,IAAI+N,GAGf/N,EAAO,GAAKmB,EAAMC,KAClBpB,EAAO,GAAKmB,EAAMC,KAClBpB,EAAO,GAAKmB,EAAMC,KAClBpB,EAAO,GAAKmB,EAAMC,KAClBpB,EAAO,GAAKmB,EAAMC,KAClBpB,EAAO,GAAKmB,EAAMC,KAClBpB,EAAO,GAAKmB,EAAMC,KAClBpB,EAAO,GAAKmB,EAAMC,KAClBpB,EAAO,GAAKmB,EAAMC,KACXpB,GAUT+N,EAAQlN,MAAQ,SAAUiP,EAAQ9P,GAChC,GAAKI,UAAQ0P,GAGb,OAAK1P,UAAQJ,IAabA,EAAO,GAAK8P,EAAO,GACnB9P,EAAO,GAAK8P,EAAO,GACnB9P,EAAO,GAAK8P,EAAO,GACnB9P,EAAO,GAAK8P,EAAO,GACnB9P,EAAO,GAAK8P,EAAO,GACnB9P,EAAO,GAAK8P,EAAO,GACnB9P,EAAO,GAAK8P,EAAO,GACnB9P,EAAO,GAAK8P,EAAO,GACnB9P,EAAO,GAAK8P,EAAO,GACZ9P,GArBE,IAAI+N,EACT+B,EAAO,GACPA,EAAO,GACPA,EAAO,GACPA,EAAO,GACPA,EAAO,GACPA,EAAO,GACPA,EAAO,GACPA,EAAO,GACPA,EAAO,KAoCb/B,EAAQ9L,UAAY,SAAUd,EAAOC,EAAepB,GAoBlD,OAlBAC,QAAMG,QAAQ,QAASe,GAGvBC,EAAgBvB,eAAauB,EAAe,GAEvChB,UAAQJ,KACXA,EAAS,IAAI+N,GAGf/N,EAAO,GAAKmB,EAAMC,GAClBpB,EAAO,GAAKmB,EAAMC,EAAgB,GAClCpB,EAAO,GAAKmB,EAAMC,EAAgB,GAClCpB,EAAO,GAAKmB,EAAMC,EAAgB,GAClCpB,EAAO,GAAKmB,EAAMC,EAAgB,GAClCpB,EAAO,GAAKmB,EAAMC,EAAgB,GAClCpB,EAAO,GAAKmB,EAAMC,EAAgB,GAClCpB,EAAO,GAAKmB,EAAMC,EAAgB,GAClCpB,EAAO,GAAKmB,EAAMC,EAAgB,GAC3BpB,GAUT+N,EAAQgC,qBAAuB,SAAUC,EAAQhQ,GAK/C,OAHAC,QAAMG,QAAQ,SAAU4P,GAGjBjC,EAAQlN,MAAMmP,EAAQhQ,IAW/B+N,EAAQkC,kBAAoB,SAAUD,EAAQhQ,GAK5C,OAHAC,QAAMG,QAAQ,SAAU4P,GAGnB5P,UAAQJ,IAabA,EAAO,GAAKgQ,EAAO,GACnBhQ,EAAO,GAAKgQ,EAAO,GACnBhQ,EAAO,GAAKgQ,EAAO,GACnBhQ,EAAO,GAAKgQ,EAAO,GACnBhQ,EAAO,GAAKgQ,EAAO,GACnBhQ,EAAO,GAAKgQ,EAAO,GACnBhQ,EAAO,GAAKgQ,EAAO,GACnBhQ,EAAO,GAAKgQ,EAAO,GACnBhQ,EAAO,GAAKgQ,EAAO,GACZhQ,GArBE,IAAI+N,EACTiC,EAAO,GACPA,EAAO,GACPA,EAAO,GACPA,EAAO,GACPA,EAAO,GACPA,EAAO,GACPA,EAAO,GACPA,EAAO,GACPA,EAAO,KAsBbjC,EAAQmC,eAAiB,SAAUC,EAAYnQ,GAE7CC,QAAMC,OAAOC,OAAO,aAAcgQ,GAGlC,IAAI/H,EAAK+H,EAAW1Q,EAAI0Q,EAAW1Q,EAC/B2Q,EAAKD,EAAW1Q,EAAI0Q,EAAWzQ,EAC/B2Q,EAAKF,EAAW1Q,EAAI0Q,EAAWxQ,EAC/B2Q,EAAKH,EAAW1Q,EAAI0Q,EAAWI,EAC/BlI,EAAK8H,EAAWzQ,EAAIyQ,EAAWzQ,EAC/B8Q,EAAKL,EAAWzQ,EAAIyQ,EAAWxQ,EAC/B8Q,EAAKN,EAAWzQ,EAAIyQ,EAAWI,EAC/BjI,EAAK6H,EAAWxQ,EAAIwQ,EAAWxQ,EAC/B+Q,EAAKP,EAAWxQ,EAAIwQ,EAAWI,EAC/BI,EAAKR,EAAWI,EAAIJ,EAAWI,EAE/BK,EAAMxI,EAAKC,EAAKC,EAAKqI,EACrBE,EAAM,GAAOT,EAAKM,GAClBI,EAAM,GAAOT,EAAKI,GAElBM,EAAM,GAAOX,EAAKM,GAClBM,GAAO5I,EAAKC,EAAKC,EAAKqI,EACtBM,EAAM,GAAOT,EAAKF,GAElBY,EAAM,GAAOb,EAAKI,GAClBU,EAAM,GAAOX,EAAKF,GAClBc,GAAOhJ,EAAKC,EAAKC,EAAKqI,EAE1B,OAAKvQ,UAAQJ,IAGbA,EAAO,GAAK4Q,EACZ5Q,EAAO,GAAK+Q,EACZ/Q,EAAO,GAAKkR,EACZlR,EAAO,GAAK6Q,EACZ7Q,EAAO,GAAKgR,EACZhR,EAAO,GAAKmR,EACZnR,EAAO,GAAK8Q,EACZ9Q,EAAO,GAAKiR,EACZjR,EAAO,GAAKoR,EACLpR,GAXE,IAAI+N,EAAQ6C,EAAKC,EAAKC,EAAKC,EAAKC,EAAKC,EAAKC,EAAKC,EAAKC,IAqB/DrD,EAAQsD,qBAAuB,SAAUC,EAAkBtR,GAEzDC,QAAMC,OAAOC,OAAO,mBAAoBmR,GAGxC,IAAI1B,EAAWnP,KAAKE,KAAK2Q,EAAiBC,OACtCC,EAAS/Q,KAAKE,KAAK2Q,EAAiBG,SACpC/B,EAASjP,KAAKE,IAAI2Q,EAAiBI,MACnC7B,EAAWpP,KAAKC,KAAK4Q,EAAiBC,OACtCI,EAASlR,KAAKC,KAAK4Q,EAAiBG,SACpChC,EAAShP,KAAKC,IAAI4Q,EAAiBI,MAEnCd,EAAMhB,EAAW4B,EACjBX,GAAOnB,EAASiC,EAASlC,EAASI,EAAW2B,EAC7CV,EAAMrB,EAASkC,EAASjC,EAASG,EAAW2B,EAE5CT,EAAMnB,EAAW+B,EACjBX,EAAMtB,EAAS8B,EAAS/B,EAASI,EAAW8B,EAC5CV,GAAOxB,EAAS+B,EAAS9B,EAASG,EAAW8B,EAE7CT,GAAOrB,EACPsB,EAAM1B,EAASG,EACfwB,EAAM1B,EAASE,EAEnB,OAAKxP,UAAQJ,IAGbA,EAAO,GAAK4Q,EACZ5Q,EAAO,GAAK+Q,EACZ/Q,EAAO,GAAKkR,EACZlR,EAAO,GAAK6Q,EACZ7Q,EAAO,GAAKgR,EACZhR,EAAO,GAAKmR,EACZnR,EAAO,GAAK8Q,EACZ9Q,EAAO,GAAKiR,EACZjR,EAAO,GAAKoR,EACLpR,GAXE,IAAI+N,EAAQ6C,EAAKC,EAAKC,EAAKC,EAAKC,EAAKC,EAAKC,EAAKC,EAAKC,IA4B/DrD,EAAQ6D,UAAY,SAAUC,EAAO7R,GAKnC,OAHAC,QAAMC,OAAOC,OAAO,QAAS0R,GAGxBzR,UAAQJ,IAIbA,EAAO,GAAK6R,EAAMpS,EAClBO,EAAO,GAAK,EACZA,EAAO,GAAK,EACZA,EAAO,GAAK,EACZA,EAAO,GAAK6R,EAAMnS,EAClBM,EAAO,GAAK,EACZA,EAAO,GAAK,EACZA,EAAO,GAAK,EACZA,EAAO,GAAK6R,EAAMlS,EACXK,GAZE,IAAI+N,EAAQ8D,EAAMpS,EAAG,EAAK,EAAK,EAAKoS,EAAMnS,EAAG,EAAK,EAAK,EAAKmS,EAAMlS,IA6B7EoO,EAAQ+D,iBAAmB,SAAUD,EAAO7R,GAK1C,OAHAC,QAAMC,OAAO4B,OAAO,QAAS+P,GAGxBzR,UAAQJ,IAIbA,EAAO,GAAK6R,EACZ7R,EAAO,GAAK,EACZA,EAAO,GAAK,EACZA,EAAO,GAAK,EACZA,EAAO,GAAK6R,EACZ7R,EAAO,GAAK,EACZA,EAAO,GAAK,EACZA,EAAO,GAAK,EACZA,EAAO,GAAK6R,EACL7R,GAZE,IAAI+N,EAAQ8D,EAAO,EAAK,EAAK,EAAKA,EAAO,EAAK,EAAK,EAAKA,IA6BnE9D,EAAQgE,iBAAmB,SAAUC,EAAQhS,GAK3C,OAHAC,QAAMC,OAAOC,OAAO,SAAU6R,GAGzB5R,UAAQJ,IAcbA,EAAO,GAAK,EACZA,EAAO,GAAKgS,EAAOrS,EACnBK,EAAO,IAAMgS,EAAOtS,EACpBM,EAAO,IAAMgS,EAAOrS,EACpBK,EAAO,GAAK,EACZA,EAAO,GAAKgS,EAAOvS,EACnBO,EAAO,GAAKgS,EAAOtS,EACnBM,EAAO,IAAMgS,EAAOvS,EACpBO,EAAO,GAAK,EACLA,GAtBE,IAAI+N,EACT,GACCiE,EAAOrS,EACRqS,EAAOtS,EACPsS,EAAOrS,EACP,GACCqS,EAAOvS,GACPuS,EAAOtS,EACRsS,EAAOvS,EACP,IA6BNsO,EAAQkE,cAAgB,SAAUC,EAAOlS,GAEvCC,QAAMC,OAAO4B,OAAO,QAASoQ,GAG7B,IAAIC,EAAW1R,KAAKE,IAAIuR,GACpBE,EAAW3R,KAAKC,IAAIwR,GAExB,OAAK9R,UAAQJ,IAcbA,EAAO,GAAK,EACZA,EAAO,GAAK,EACZA,EAAO,GAAK,EACZA,EAAO,GAAK,EACZA,EAAO,GAAKmS,EACZnS,EAAO,GAAKoS,EACZpS,EAAO,GAAK,EACZA,EAAO,IAAMoS,EACbpS,EAAO,GAAKmS,EAELnS,GAvBE,IAAI+N,EACT,EACA,EACA,EACA,EACAoE,GACCC,EACD,EACAA,EACAD,IA8BNpE,EAAQsE,cAAgB,SAAUH,EAAOlS,GAEvCC,QAAMC,OAAO4B,OAAO,QAASoQ,GAG7B,IAAIC,EAAW1R,KAAKE,IAAIuR,GACpBE,EAAW3R,KAAKC,IAAIwR,GAExB,OAAK9R,UAAQJ,IAcbA,EAAO,GAAKmS,EACZnS,EAAO,GAAK,EACZA,EAAO,IAAMoS,EACbpS,EAAO,GAAK,EACZA,EAAO,GAAK,EACZA,EAAO,GAAK,EACZA,EAAO,GAAKoS,EACZpS,EAAO,GAAK,EACZA,EAAO,GAAKmS,EAELnS,GAvBE,IAAI+N,EACToE,EACA,EACAC,EACA,EACA,EACA,GACCA,EACD,EACAD,IA8BNpE,EAAQuE,cAAgB,SAAUJ,EAAOlS,GAEvCC,QAAMC,OAAO4B,OAAO,QAASoQ,GAG7B,IAAIC,EAAW1R,KAAKE,IAAIuR,GACpBE,EAAW3R,KAAKC,IAAIwR,GAExB,OAAK9R,UAAQJ,IAcbA,EAAO,GAAKmS,EACZnS,EAAO,GAAKoS,EACZpS,EAAO,GAAK,EACZA,EAAO,IAAMoS,EACbpS,EAAO,GAAKmS,EACZnS,EAAO,GAAK,EACZA,EAAO,GAAK,EACZA,EAAO,GAAK,EACZA,EAAO,GAAK,EAELA,GAvBE,IAAI+N,EACToE,GACCC,EACD,EACAA,EACAD,EACA,EACA,EACA,EACA,IAyBNpE,EAAQwE,QAAU,SAAUzC,EAAQ9P,GAKlC,OAHAC,QAAMC,OAAOC,OAAO,SAAU2P,GAGzB1P,UAAQJ,IAabA,EAAO,GAAK8P,EAAO,GACnB9P,EAAO,GAAK8P,EAAO,GACnB9P,EAAO,GAAK8P,EAAO,GACnB9P,EAAO,GAAK8P,EAAO,GACnB9P,EAAO,GAAK8P,EAAO,GACnB9P,EAAO,GAAK8P,EAAO,GACnB9P,EAAO,GAAK8P,EAAO,GACnB9P,EAAO,GAAK8P,EAAO,GACnB9P,EAAO,GAAK8P,EAAO,GACZ9P,GArBE,CACL8P,EAAO,GACPA,EAAO,GACPA,EAAO,GACPA,EAAO,GACPA,EAAO,GACPA,EAAO,GACPA,EAAO,GACPA,EAAO,GACPA,EAAO,KA+Bb/B,EAAQyE,gBAAkB,SAAUC,EAAQC,GAQ1C,OANAzS,QAAMC,OAAO4B,OAAOC,oBAAoB,MAAO2Q,EAAK,GACpDzS,QAAMC,OAAO4B,OAAO6Q,iBAAiB,MAAOD,EAAK,GACjDzS,QAAMC,OAAO4B,OAAOC,oBAAoB,SAAU0Q,EAAQ,GAC1DxS,QAAMC,OAAO4B,OAAO6Q,iBAAiB,SAAUF,EAAQ,GAGvC,EAATA,EAAaC,GAatB3E,EAAQ6E,UAAY,SAAU9C,EAAQ9N,EAAOhC,GAE3CC,QAAMC,OAAOC,OAAO,SAAU2P,GAC9B7P,QAAMC,OAAO4B,OAAOC,oBAAoB,QAASC,EAAO,GACxD/B,QAAMC,OAAO4B,OAAO6Q,iBAAiB,QAAS3Q,EAAO,GACrD/B,QAAMC,OAAOC,OAAO,SAAUH,GAG9B,IAAI6S,EAAqB,EAAR7Q,EACbvC,EAAIqQ,EAAO+C,GACXnT,EAAIoQ,EAAO+C,EAAa,GACxBlT,EAAImQ,EAAO+C,EAAa,GAK5B,OAHA7S,EAAOP,EAAIA,EACXO,EAAON,EAAIA,EACXM,EAAOL,EAAIA,EACJK,GAcT+N,EAAQ+E,UAAY,SAAUhD,EAAQ9N,EAAOlB,EAAWd,GAEtDC,QAAMC,OAAOC,OAAO,SAAU2P,GAC9B7P,QAAMC,OAAO4B,OAAOC,oBAAoB,QAASC,EAAO,GACxD/B,QAAMC,OAAO4B,OAAO6Q,iBAAiB,QAAS3Q,EAAO,GACrD/B,QAAMC,OAAOC,OAAO,YAAaW,GACjCb,QAAMC,OAAOC,OAAO,SAAUH,GAI9B,IAAI6S,EAAqB,EAAR7Q,EAIjB,OALAhC,EAAS+N,EAAQlN,MAAMiP,EAAQ9P,IAExB6S,GAAc/R,EAAUrB,EAC/BO,EAAO6S,EAAa,GAAK/R,EAAUpB,EACnCM,EAAO6S,EAAa,GAAK/R,EAAUnB,EAC5BK,GAaT+N,EAAQgF,OAAS,SAAUjD,EAAQ9N,EAAOhC,GAExCC,QAAMC,OAAOC,OAAO,SAAU2P,GAC9B7P,QAAMC,OAAO4B,OAAOC,oBAAoB,QAASC,EAAO,GACxD/B,QAAMC,OAAO4B,OAAO6Q,iBAAiB,QAAS3Q,EAAO,GACrD/B,QAAMC,OAAOC,OAAO,SAAUH,GAG9B,IAAIP,EAAIqQ,EAAO9N,GACXtC,EAAIoQ,EAAO9N,EAAQ,GACnBrC,EAAImQ,EAAO9N,EAAQ,GAKvB,OAHAhC,EAAOP,EAAIA,EACXO,EAAON,EAAIA,EACXM,EAAOL,EAAIA,EACJK,GAcT+N,EAAQiF,OAAS,SAAUlD,EAAQ9N,EAAOlB,EAAWd,GAanD,OAXAC,QAAMC,OAAOC,OAAO,SAAU2P,GAC9B7P,QAAMC,OAAO4B,OAAOC,oBAAoB,QAASC,EAAO,GACxD/B,QAAMC,OAAO4B,OAAO6Q,iBAAiB,QAAS3Q,EAAO,GACrD/B,QAAMC,OAAOC,OAAO,YAAaW,GACjCb,QAAMC,OAAOC,OAAO,SAAUH,IAG9BA,EAAS+N,EAAQlN,MAAMiP,EAAQ9P,IACxBgC,GAASlB,EAAUrB,EAC1BO,EAAOgC,EAAQ,GAAKlB,EAAUpB,EAC9BM,EAAOgC,EAAQ,GAAKlB,EAAUnB,EACvBK,GAGT,IAAIiT,EAAgB,IAAIzT,EASxBuO,EAAQmF,SAAW,SAAUpD,EAAQ9P,GAenC,OAbAC,QAAMC,OAAOC,OAAO,SAAU2P,GAC9B7P,QAAMC,OAAOC,OAAO,SAAUH,GAG9BA,EAAOP,EAAID,EAAWe,UACpBf,EAAWoB,aAAakP,EAAO,GAAIA,EAAO,GAAIA,EAAO,GAAImD,IAE3DjT,EAAON,EAAIF,EAAWe,UACpBf,EAAWoB,aAAakP,EAAO,GAAIA,EAAO,GAAIA,EAAO,GAAImD,IAE3DjT,EAAOL,EAAIH,EAAWe,UACpBf,EAAWoB,aAAakP,EAAO,GAAIA,EAAO,GAAIA,EAAO,GAAImD,IAEpDjT,GAGT,IAAImT,EAAe,IAAI3T,EASvBuO,EAAQqF,gBAAkB,SAAUtD,GAElC,OADA/B,EAAQmF,SAASpD,EAAQqD,GAClB3T,EAAW0C,iBAAiBiR,IAWrCpF,EAAQsF,SAAW,SAAUvQ,EAAMC,EAAO/C,GAExCC,QAAMC,OAAOC,OAAO,OAAQ2C,GAC5B7C,QAAMC,OAAOC,OAAO,QAAS4C,GAC7B9C,QAAMC,OAAOC,OAAO,SAAUH,GAG9B,IAAIgO,EACFlL,EAAK,GAAKC,EAAM,GAAKD,EAAK,GAAKC,EAAM,GAAKD,EAAK,GAAKC,EAAM,GACxDoL,EACFrL,EAAK,GAAKC,EAAM,GAAKD,EAAK,GAAKC,EAAM,GAAKD,EAAK,GAAKC,EAAM,GACxDuL,EACFxL,EAAK,GAAKC,EAAM,GAAKD,EAAK,GAAKC,EAAM,GAAKD,EAAK,GAAKC,EAAM,GAExDkL,EACFnL,EAAK,GAAKC,EAAM,GAAKD,EAAK,GAAKC,EAAM,GAAKD,EAAK,GAAKC,EAAM,GACxDqL,EACFtL,EAAK,GAAKC,EAAM,GAAKD,EAAK,GAAKC,EAAM,GAAKD,EAAK,GAAKC,EAAM,GACxDwL,EACFzL,EAAK,GAAKC,EAAM,GAAKD,EAAK,GAAKC,EAAM,GAAKD,EAAK,GAAKC,EAAM,GAExDmL,EACFpL,EAAK,GAAKC,EAAM,GAAKD,EAAK,GAAKC,EAAM,GAAKD,EAAK,GAAKC,EAAM,GACxDsL,EACFvL,EAAK,GAAKC,EAAM,GAAKD,EAAK,GAAKC,EAAM,GAAKD,EAAK,GAAKC,EAAM,GACxDyL,EACF1L,EAAK,GAAKC,EAAM,GAAKD,EAAK,GAAKC,EAAM,GAAKD,EAAK,GAAKC,EAAM,GAW5D,OATA/C,EAAO,GAAKgO,EACZhO,EAAO,GAAKmO,EACZnO,EAAO,GAAKsO,EACZtO,EAAO,GAAKiO,EACZjO,EAAO,GAAKoO,EACZpO,EAAO,GAAKuO,EACZvO,EAAO,GAAKkO,EACZlO,EAAO,GAAKqO,EACZrO,EAAO,GAAKwO,EACLxO,GAWT+N,EAAQxK,IAAM,SAAUT,EAAMC,EAAO/C,GAgBnC,OAdAC,QAAMC,OAAOC,OAAO,OAAQ2C,GAC5B7C,QAAMC,OAAOC,OAAO,QAAS4C,GAC7B9C,QAAMC,OAAOC,OAAO,SAAUH,GAG9BA,EAAO,GAAK8C,EAAK,GAAKC,EAAM,GAC5B/C,EAAO,GAAK8C,EAAK,GAAKC,EAAM,GAC5B/C,EAAO,GAAK8C,EAAK,GAAKC,EAAM,GAC5B/C,EAAO,GAAK8C,EAAK,GAAKC,EAAM,GAC5B/C,EAAO,GAAK8C,EAAK,GAAKC,EAAM,GAC5B/C,EAAO,GAAK8C,EAAK,GAAKC,EAAM,GAC5B/C,EAAO,GAAK8C,EAAK,GAAKC,EAAM,GAC5B/C,EAAO,GAAK8C,EAAK,GAAKC,EAAM,GAC5B/C,EAAO,GAAK8C,EAAK,GAAKC,EAAM,GACrB/C,GAWT+N,EAAQ/K,SAAW,SAAUF,EAAMC,EAAO/C,GAgBxC,OAdAC,QAAMC,OAAOC,OAAO,OAAQ2C,GAC5B7C,QAAMC,OAAOC,OAAO,QAAS4C,GAC7B9C,QAAMC,OAAOC,OAAO,SAAUH,GAG9BA,EAAO,GAAK8C,EAAK,GAAKC,EAAM,GAC5B/C,EAAO,GAAK8C,EAAK,GAAKC,EAAM,GAC5B/C,EAAO,GAAK8C,EAAK,GAAKC,EAAM,GAC5B/C,EAAO,GAAK8C,EAAK,GAAKC,EAAM,GAC5B/C,EAAO,GAAK8C,EAAK,GAAKC,EAAM,GAC5B/C,EAAO,GAAK8C,EAAK,GAAKC,EAAM,GAC5B/C,EAAO,GAAK8C,EAAK,GAAKC,EAAM,GAC5B/C,EAAO,GAAK8C,EAAK,GAAKC,EAAM,GAC5B/C,EAAO,GAAK8C,EAAK,GAAKC,EAAM,GACrB/C,GAWT+N,EAAQuF,iBAAmB,SAAUxD,EAAQhP,EAAWd,GAEtDC,QAAMC,OAAOC,OAAO,SAAU2P,GAC9B7P,QAAMC,OAAOC,OAAO,YAAaW,GACjCb,QAAMC,OAAOC,OAAO,SAAUH,GAG9B,IAAIuT,EAAKzS,EAAUrB,EACf+T,EAAK1S,EAAUpB,EACf+T,EAAK3S,EAAUnB,EAEfF,EAAIqQ,EAAO,GAAKyD,EAAKzD,EAAO,GAAK0D,EAAK1D,EAAO,GAAK2D,EAClD/T,EAAIoQ,EAAO,GAAKyD,EAAKzD,EAAO,GAAK0D,EAAK1D,EAAO,GAAK2D,EAClD9T,EAAImQ,EAAO,GAAKyD,EAAKzD,EAAO,GAAK0D,EAAK1D,EAAO,GAAK2D,EAKtD,OAHAzT,EAAOP,EAAIA,EACXO,EAAON,EAAIA,EACXM,EAAOL,EAAIA,EACJK,GAWT+N,EAAQvK,iBAAmB,SAAUsM,EAAQrM,EAAQzD,GAgBnD,OAdAC,QAAMC,OAAOC,OAAO,SAAU2P,GAC9B7P,QAAMC,OAAO4B,OAAO,SAAU2B,GAC9BxD,QAAMC,OAAOC,OAAO,SAAUH,GAG9BA,EAAO,GAAK8P,EAAO,GAAKrM,EACxBzD,EAAO,GAAK8P,EAAO,GAAKrM,EACxBzD,EAAO,GAAK8P,EAAO,GAAKrM,EACxBzD,EAAO,GAAK8P,EAAO,GAAKrM,EACxBzD,EAAO,GAAK8P,EAAO,GAAKrM,EACxBzD,EAAO,GAAK8P,EAAO,GAAKrM,EACxBzD,EAAO,GAAK8P,EAAO,GAAKrM,EACxBzD,EAAO,GAAK8P,EAAO,GAAKrM,EACxBzD,EAAO,GAAK8P,EAAO,GAAKrM,EACjBzD,GAmBT+N,EAAQ2F,gBAAkB,SAAU5D,EAAQ+B,EAAO7R,GAgBjD,OAdAC,QAAMC,OAAOC,OAAO,SAAU2P,GAC9B7P,QAAMC,OAAOC,OAAO,QAAS0R,GAC7B5R,QAAMC,OAAOC,OAAO,SAAUH,GAG9BA,EAAO,GAAK8P,EAAO,GAAK+B,EAAMpS,EAC9BO,EAAO,GAAK8P,EAAO,GAAK+B,EAAMpS,EAC9BO,EAAO,GAAK8P,EAAO,GAAK+B,EAAMpS,EAC9BO,EAAO,GAAK8P,EAAO,GAAK+B,EAAMnS,EAC9BM,EAAO,GAAK8P,EAAO,GAAK+B,EAAMnS,EAC9BM,EAAO,GAAK8P,EAAO,GAAK+B,EAAMnS,EAC9BM,EAAO,GAAK8P,EAAO,GAAK+B,EAAMlS,EAC9BK,EAAO,GAAK8P,EAAO,GAAK+B,EAAMlS,EAC9BK,EAAO,GAAK8P,EAAO,GAAK+B,EAAMlS,EACvBK,GAUT+N,EAAQpK,OAAS,SAAUmM,EAAQ9P,GAejC,OAbAC,QAAMC,OAAOC,OAAO,SAAU2P,GAC9B7P,QAAMC,OAAOC,OAAO,SAAUH,GAG9BA,EAAO,IAAM8P,EAAO,GACpB9P,EAAO,IAAM8P,EAAO,GACpB9P,EAAO,IAAM8P,EAAO,GACpB9P,EAAO,IAAM8P,EAAO,GACpB9P,EAAO,IAAM8P,EAAO,GACpB9P,EAAO,IAAM8P,EAAO,GACpB9P,EAAO,IAAM8P,EAAO,GACpB9P,EAAO,IAAM8P,EAAO,GACpB9P,EAAO,IAAM8P,EAAO,GACb9P,GAUT+N,EAAQ4F,UAAY,SAAU7D,EAAQ9P,GAEpCC,QAAMC,OAAOC,OAAO,SAAU2P,GAC9B7P,QAAMC,OAAOC,OAAO,SAAUH,GAG9B,IAAIgO,EAAc8B,EAAO,GACrB3B,EAAc2B,EAAO,GACrBxB,EAAcwB,EAAO,GACrB7B,EAAc6B,EAAO,GACrB1B,EAAc0B,EAAO,GACrBvB,EAAcuB,EAAO,GACrB5B,EAAc4B,EAAO,GACrBzB,EAAcyB,EAAO,GACrBtB,EAAcsB,EAAO,GAWzB,OATA9P,EAAO,GAAKgO,EACZhO,EAAO,GAAKmO,EACZnO,EAAO,GAAKsO,EACZtO,EAAO,GAAKiO,EACZjO,EAAO,GAAKoO,EACZpO,EAAO,GAAKuO,EACZvO,EAAO,GAAKkO,EACZlO,EAAO,GAAKqO,EACZrO,EAAO,GAAKwO,EACLxO,GAGT,IAAI4T,EAAO,IAAIpU,EAAW,EAAG,EAAG,GAShCuO,EAAQ8F,YAAc,SAAU/D,EAAQ9P,GAEtCC,QAAMC,OAAOC,OAAO,SAAU2P,GAC9B7P,QAAMC,OAAOC,OAAO,SAAUH,GAG9B,IAAI8T,EAAetU,EAAW8D,iBAC5BsQ,EACA7F,EAAQmF,SAASpD,EAAQqD,GACzBA,GAIF,OAFAnT,EAAS+N,EAAQ2F,gBAAgB5D,EAAQgE,EAAc9T,IAezD,IAAI+T,EAAS,CAAC,EAAG,EAAG,GAChBC,EAAS,CAAC,EAAG,EAAG,GAEpB,SAASC,EAAyBnE,GAKhC,IADA,IAAIoE,EAAO,EACFtS,EAAI,EAAGA,EAAI,IAAKA,EAAG,CAC1B,IAAIuS,EAAOrE,EAAO/B,EAAQyE,gBAAgBwB,EAAOpS,GAAImS,EAAOnS,KAC5DsS,GAAQ,EAAMC,EAAOA,EAGvB,OAAO1T,KAAKkC,KAAKuR,GAGnB,SAASE,EAAkBtE,EAAQ9P,GAcjC,IANA,IAAIqU,EAAY7O,aAAW6H,UAEvBiH,EAAc,EACdC,EAAU,EAGL3S,EAAI,EAAGA,EAAI,IAAKA,EAAG,CAC1B,IAAIuS,EAAO1T,KAAKmD,IAAIkM,EAAO/B,EAAQyE,gBAAgBwB,EAAOpS,GAAImS,EAAOnS,MACjEuS,EAAOG,IACTC,EAAU3S,EACV0S,EAAcH,GAIlB,IAAIK,EAAI,EACJC,EAAI,EAEJ3J,EAAIiJ,EAAOQ,GACXG,EAAIV,EAAOO,GAEf,GAAI9T,KAAKmD,IAAIkM,EAAO/B,EAAQyE,gBAAgBkC,EAAG5J,KAAOuJ,EAAW,CAC/D,IAKIpQ,EADA0Q,GAJK7E,EAAO/B,EAAQyE,gBAAgBkC,EAAGA,IAClC5E,EAAO/B,EAAQyE,gBAAgB1H,EAAGA,KAGrB,EAFbgF,EAAO/B,EAAQyE,gBAAgBkC,EAAG5J,IAY3C2J,GANExQ,EADE0Q,EAAM,GACH,IAAQA,EAAMlU,KAAKkC,KAAK,EAAMgS,EAAMA,IAErC,GAAOA,EAAMlU,KAAKkC,KAAK,EAAMgS,EAAMA,MAGzCH,EAAI,EAAM/T,KAAKkC,KAAK,EAAMsB,EAAIA,IAYhC,OARAjE,EAAS+N,EAAQlN,MAAMkN,EAAQ6G,SAAU5U,IAElC+N,EAAQyE,gBAAgB1H,EAAGA,IAAM9K,EACtC+N,EAAQyE,gBAAgBkC,EAAGA,IACzBF,EACJxU,EAAO+N,EAAQyE,gBAAgBkC,EAAG5J,IAAM2J,EACxCzU,EAAO+N,EAAQyE,gBAAgB1H,EAAG4J,KAAOD,EAElCzU,EAGT,IAAI6U,EAAU,IAAI9G,EACd+G,EAAmB,IAAI/G,EAiC3BA,EAAQgH,0BAA4B,SAAUjF,EAAQ9P,GAEpDC,QAAMC,OAAOC,OAAO,SAAU2P,GAM9B,IAAIuE,EAAY7O,aAAWwP,UAGvBC,EAAQ,EACRC,EAAQ,EAEP9U,UAAQJ,KACXA,EAAS,IAWX,IARA,IAAImV,EAAiBnV,EAAOoV,QAAUrH,EAAQlN,MAC5CkN,EAAQ6G,SACR5U,EAAOoV,SAELC,EAAcrV,EAAOsV,SAAWvH,EAAQlN,MAAMiP,EAAQ9P,EAAOsV,UAE7DjK,EAAUgJ,EA7IhB,SAA8BvE,GAE5B,IADA,IAAIoE,EAAO,EACFtS,EAAI,EAAGA,EAAI,IAAKA,EAAG,CAC1B,IAAIuS,EAAOrE,EAAOlO,GAClBsS,GAAQC,EAAOA,EAGjB,OAAO1T,KAAKkC,KAAKuR,GAsISqB,CAAqBF,GAExCH,EAjBS,IAiBYjB,EAAyBoB,GAAchK,GACjE+I,EAAkBiB,EAAYR,GAC9B9G,EAAQ4F,UAAUkB,EAASC,GAC3B/G,EAAQsF,SAASgC,EAAYR,EAASQ,GACtCtH,EAAQsF,SAASyB,EAAkBO,EAAYA,GAC/CtH,EAAQsF,SAAS8B,EAAeN,EAASM,KAEnCF,EAAQ,MACVC,EACFD,EAAQ,GAIZ,OAAOjV,GAUT+N,EAAQnK,IAAM,SAAUkM,EAAQ9P,GAgB9B,OAdAC,QAAMC,OAAOC,OAAO,SAAU2P,GAC9B7P,QAAMC,OAAOC,OAAO,SAAUH,GAG9BA,EAAO,GAAKS,KAAKmD,IAAIkM,EAAO,IAC5B9P,EAAO,GAAKS,KAAKmD,IAAIkM,EAAO,IAC5B9P,EAAO,GAAKS,KAAKmD,IAAIkM,EAAO,IAC5B9P,EAAO,GAAKS,KAAKmD,IAAIkM,EAAO,IAC5B9P,EAAO,GAAKS,KAAKmD,IAAIkM,EAAO,IAC5B9P,EAAO,GAAKS,KAAKmD,IAAIkM,EAAO,IAC5B9P,EAAO,GAAKS,KAAKmD,IAAIkM,EAAO,IAC5B9P,EAAO,GAAKS,KAAKmD,IAAIkM,EAAO,IAC5B9P,EAAO,GAAKS,KAAKmD,IAAIkM,EAAO,IAErB9P,GAST+N,EAAQyH,YAAc,SAAU1F,GAE9B7P,QAAMC,OAAOC,OAAO,SAAU2P,GAG9B,IAAIkB,EAAMlB,EAAO,GACbqB,EAAMrB,EAAO,GACb2F,EAAM3F,EAAO,GACbmB,EAAMnB,EAAO,GACbsB,EAAMtB,EAAO,GACb4F,EAAM5F,EAAO,GACb6F,EAAM7F,EAAO,GACb8F,EAAM9F,EAAO,GACb+F,EAAM/F,EAAO,GAEjB,OACEkB,GAAOI,EAAMyE,EAAMD,EAAMF,GACzBzE,GAAO2E,EAAMH,EAAMtE,EAAM0E,GACzBF,GAAOxE,EAAMuE,EAAMtE,EAAMqE,IAa7B1H,EAAQ+H,QAAU,SAAUhG,EAAQ9P,GAElCC,QAAMC,OAAOC,OAAO,SAAU2P,GAC9B7P,QAAMC,OAAOC,OAAO,SAAUH,GAG9B,IAAIgR,EAAMlB,EAAO,GACbqB,EAAMrB,EAAO,GACb2F,EAAM3F,EAAO,GACbmB,EAAMnB,EAAO,GACbsB,EAAMtB,EAAO,GACb4F,EAAM5F,EAAO,GACb6F,EAAM7F,EAAO,GACb8F,EAAM9F,EAAO,GACb+F,EAAM/F,EAAO,GAEb0F,EAAczH,EAAQyH,YAAY1F,GAGtC,GAAIrP,KAAKmD,IAAI4R,IAAgBhQ,aAAW6H,UACtC,MAAM,IAAI1L,iBAAe,4BAI3B3B,EAAO,GAAKoR,EAAMyE,EAAMD,EAAMF,EAC9B1V,EAAO,GAAK4V,EAAMH,EAAMtE,EAAM0E,EAC9B7V,EAAO,GAAKmR,EAAMuE,EAAMtE,EAAMqE,EAC9BzV,EAAO,GAAK2V,EAAMD,EAAMzE,EAAM4E,EAC9B7V,EAAO,GAAKgR,EAAM6E,EAAMF,EAAMF,EAC9BzV,EAAO,GAAKiR,EAAMwE,EAAMzE,EAAM0E,EAC9B1V,EAAO,GAAKiR,EAAM2E,EAAMD,EAAMvE,EAC9BpR,EAAO,GAAK2V,EAAMxE,EAAMH,EAAM4E,EAC9B5V,EAAO,GAAKgR,EAAMI,EAAMH,EAAME,EAE9B,IAAIU,EAAQ,EAAM2D,EAClB,OAAOzH,EAAQvK,iBAAiBxD,EAAQ6R,EAAO7R,IAGjD,IAAI+V,EAAyB,IAAIhI,ECj0CjC,SAASiI,EAAWvW,EAAGC,EAAGC,EAAG4Q,GAM3B3Q,KAAKH,EAAII,eAAaJ,EAAG,GAOzBG,KAAKF,EAAIG,eAAaH,EAAG,GAOzBE,KAAKD,EAAIE,eAAaF,EAAG,GAOzBC,KAAK2Q,EAAI1Q,eAAa0Q,EAAG,GD+yC3BxC,EAAQkI,iBAAmB,SAAUnG,EAAQ9P,GAM3C,OAJAC,QAAMC,OAAOC,OAAO,SAAU2P,GAC9B7P,QAAMC,OAAOC,OAAO,SAAUH,GAGvB+N,EAAQ+H,QACb/H,EAAQ4F,UAAU7D,EAAQiG,GAC1B/V,IAYJ+N,EAAQ7I,OAAS,SAAUpC,EAAMC,GAC/B,OACED,IAASC,GACR3C,UAAQ0C,IACP1C,UAAQ2C,IACRD,EAAK,KAAOC,EAAM,IAClBD,EAAK,KAAOC,EAAM,IAClBD,EAAK,KAAOC,EAAM,IAClBD,EAAK,KAAOC,EAAM,IAClBD,EAAK,KAAOC,EAAM,IAClBD,EAAK,KAAOC,EAAM,IAClBD,EAAK,KAAOC,EAAM,IAClBD,EAAK,KAAOC,EAAM,IAClBD,EAAK,KAAOC,EAAM,IAcxBgL,EAAQ1I,cAAgB,SAAUvC,EAAMC,EAAOsI,GAG7C,OAFAA,EAAUxL,eAAawL,EAAS,GAG9BvI,IAASC,GACR3C,UAAQ0C,IACP1C,UAAQ2C,IACRtC,KAAKmD,IAAId,EAAK,GAAKC,EAAM,KAAOsI,GAChC5K,KAAKmD,IAAId,EAAK,GAAKC,EAAM,KAAOsI,GAChC5K,KAAKmD,IAAId,EAAK,GAAKC,EAAM,KAAOsI,GAChC5K,KAAKmD,IAAId,EAAK,GAAKC,EAAM,KAAOsI,GAChC5K,KAAKmD,IAAId,EAAK,GAAKC,EAAM,KAAOsI,GAChC5K,KAAKmD,IAAId,EAAK,GAAKC,EAAM,KAAOsI,GAChC5K,KAAKmD,IAAId,EAAK,GAAKC,EAAM,KAAOsI,GAChC5K,KAAKmD,IAAId,EAAK,GAAKC,EAAM,KAAOsI,GAChC5K,KAAKmD,IAAId,EAAK,GAAKC,EAAM,KAAOsI,GAUtC0C,EAAQ6G,SAAWzN,OAAOC,OACxB,IAAI2G,EAAQ,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,IAStDA,EAAQ7G,KAAOC,OAAOC,OACpB,IAAI2G,EAAQ,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,IAStDA,EAAQmI,YAAc,EAQtBnI,EAAQoI,YAAc,EAQtBpI,EAAQqI,YAAc,EAQtBrI,EAAQsI,YAAc,EAQtBtI,EAAQuI,YAAc,EAQtBvI,EAAQwI,YAAc,EAQtBxI,EAAQyI,YAAc,EAQtBzI,EAAQ0I,YAAc,EAQtB1I,EAAQ2I,YAAc,EAEtBvP,OAAOmE,iBAAiByC,EAAQzG,UAAW,CAOzC/F,OAAQ,CACNiK,IAAK,WACH,OAAOuC,EAAQ/M,iBAWrB+M,EAAQzG,UAAUzG,MAAQ,SAAUb,GAClC,OAAO+N,EAAQlN,MAAMjB,KAAMI,IAU7B+N,EAAQzG,UAAUpC,OAAS,SAAUnC,GACnC,OAAOgL,EAAQ7I,OAAOtF,KAAMmD,IAM9BgL,EAAQ5I,YAAc,SAAU2K,EAAQ3O,EAAOiE,GAC7C,OACE0K,EAAO,KAAO3O,EAAMiE,IACpB0K,EAAO,KAAO3O,EAAMiE,EAAS,IAC7B0K,EAAO,KAAO3O,EAAMiE,EAAS,IAC7B0K,EAAO,KAAO3O,EAAMiE,EAAS,IAC7B0K,EAAO,KAAO3O,EAAMiE,EAAS,IAC7B0K,EAAO,KAAO3O,EAAMiE,EAAS,IAC7B0K,EAAO,KAAO3O,EAAMiE,EAAS,IAC7B0K,EAAO,KAAO3O,EAAMiE,EAAS,IAC7B0K,EAAO,KAAO3O,EAAMiE,EAAS,IAajC2I,EAAQzG,UAAUjC,cAAgB,SAAUtC,EAAOsI,GACjD,OAAO0C,EAAQ1I,cAAczF,KAAMmD,EAAOsI,IAS5C0C,EAAQzG,UAAUC,SAAW,WAC3B,MACE,IACA3H,KAAK,GACL,KACAA,KAAK,GACL,KACAA,KAAK,GALL,OAQAA,KAAK,GACL,KACAA,KAAK,GACL,KACAA,KAAK,GAZL,OAeAA,KAAK,GACL,KACAA,KAAK,GACL,KACAA,KAAK,GACL,KC7hDJoW,EAAWpV,aAAe,SAAUnB,EAAGC,EAAGC,EAAG4Q,EAAGvQ,GAC9C,OAAKI,UAAQJ,IAIbA,EAAOP,EAAIA,EACXO,EAAON,EAAIA,EACXM,EAAOL,EAAIA,EACXK,EAAOuQ,EAAIA,EACJvQ,GAPE,IAAIgW,EAAWvW,EAAGC,EAAGC,EAAG4Q,IAkBnCyF,EAAWW,UAAY,SAAUC,EAAO5W,GAItC,OAFAC,QAAMC,OAAOC,OAAO,QAASyW,GAExBxW,UAAQJ,IAIbA,EAAOP,EAAImX,EAAMC,IACjB7W,EAAON,EAAIkX,EAAME,MACjB9W,EAAOL,EAAIiX,EAAMG,KACjB/W,EAAOuQ,EAAIqG,EAAMI,MACVhX,GAPE,IAAIgW,EAAWY,EAAMC,IAAKD,EAAME,MAAOF,EAAMG,KAAMH,EAAMI,QAiBpEhB,EAAWnV,MAAQ,SAAUC,EAAWd,GACtC,GAAKI,UAAQU,GAIb,OAAKV,UAAQJ,IAIbA,EAAOP,EAAIqB,EAAUrB,EACrBO,EAAON,EAAIoB,EAAUpB,EACrBM,EAAOL,EAAImB,EAAUnB,EACrBK,EAAOuQ,EAAIzP,EAAUyP,EACdvQ,GAPE,IAAIgW,EAAWlV,EAAUrB,EAAGqB,EAAUpB,EAAGoB,EAAUnB,EAAGmB,EAAUyP,IAc3EyF,EAAWhV,aAAe,EAW1BgV,EAAW/U,KAAO,SAAUC,EAAOC,EAAOC,GAaxC,OAXAnB,QAAMC,OAAOC,OAAO,QAASe,GAC7BjB,QAAMG,QAAQ,QAASe,GAGvBC,EAAgBvB,eAAauB,EAAe,GAE5CD,EAAMC,KAAmBF,EAAMzB,EAC/B0B,EAAMC,KAAmBF,EAAMxB,EAC/ByB,EAAMC,KAAmBF,EAAMvB,EAC/BwB,EAAMC,GAAiBF,EAAMqP,EAEtBpP,GAWT6U,EAAW3U,OAAS,SAAUF,EAAOC,EAAepB,GAclD,OAZAC,QAAMG,QAAQ,QAASe,GAGvBC,EAAgBvB,eAAauB,EAAe,GAEvChB,UAAQJ,KACXA,EAAS,IAAIgW,GAEfhW,EAAOP,EAAI0B,EAAMC,KACjBpB,EAAON,EAAIyB,EAAMC,KACjBpB,EAAOL,EAAIwB,EAAMC,KACjBpB,EAAOuQ,EAAIpP,EAAMC,GACVpB,GAWTgW,EAAW1U,UAAY,SAAUH,EAAOnB,GAEtCC,QAAMG,QAAQ,QAASe,GAGvB,IAAII,EAASJ,EAAMI,OACfC,EAAwB,EAATD,EACnB,GAAKnB,UAAQJ,GAEN,CAAA,IAAKyB,MAAMC,QAAQ1B,IAAWA,EAAOuB,SAAWC,EACrD,MAAM,IAAIG,iBACR,8EAEO3B,EAAOuB,SAAWC,IAC3BxB,EAAOuB,OAASC,QANhBxB,EAAS,IAAIyB,MAAMD,GASrB,IAAK,IAAII,EAAI,EAAGA,EAAIL,IAAUK,EAC5BoU,EAAW/U,KAAKE,EAAMS,GAAI5B,EAAY,EAAJ4B,GAEpC,OAAO5B,GAUTgW,EAAWnU,YAAc,SAAUV,EAAOnB,GAIxC,GAFAC,QAAMG,QAAQ,QAASe,GACvBlB,QAAMC,OAAO4B,OAAOC,oBAAoB,eAAgBZ,EAAMI,OAAQ,GAClEJ,EAAMI,OAAS,GAAM,EACvB,MAAM,IAAII,iBAAe,yCAI3B,IAAIJ,EAASJ,EAAMI,OACdnB,UAAQJ,GAGXA,EAAOuB,OAASA,EAAS,EAFzBvB,EAAS,IAAIyB,MAAMF,EAAS,GAK9B,IAAK,IAAIK,EAAI,EAAGA,EAAIL,EAAQK,GAAK,EAAG,CAClC,IAAII,EAAQJ,EAAI,EAChB5B,EAAOgC,GAASgU,EAAW3U,OAAOF,EAAOS,EAAG5B,EAAOgC,IAErD,OAAOhC,GAqBTgW,EAAW/T,UAAY+T,EAAW3U,OAQlC2U,EAAW9T,iBAAmB,SAAUpB,GAKtC,OAHAb,QAAMC,OAAOC,OAAO,YAAaW,GAG1BL,KAAK0B,IAAIrB,EAAUrB,EAAGqB,EAAUpB,EAAGoB,EAAUnB,EAAGmB,EAAUyP,IASnEyF,EAAW5T,iBAAmB,SAAUtB,GAKtC,OAHAb,QAAMC,OAAOC,OAAO,YAAaW,GAG1BL,KAAK4B,IAAIvB,EAAUrB,EAAGqB,EAAUpB,EAAGoB,EAAUnB,EAAGmB,EAAUyP,IAWnEyF,EAAW1T,mBAAqB,SAAUC,EAAOC,EAAQxC,GAYvD,OAVAC,QAAMC,OAAOC,OAAO,QAASoC,GAC7BtC,QAAMC,OAAOC,OAAO,SAAUqC,GAC9BvC,QAAMC,OAAOC,OAAO,SAAUH,GAG9BA,EAAOP,EAAIgB,KAAK4B,IAAIE,EAAM9C,EAAG+C,EAAO/C,GACpCO,EAAON,EAAIe,KAAK4B,IAAIE,EAAM7C,EAAG8C,EAAO9C,GACpCM,EAAOL,EAAIc,KAAK4B,IAAIE,EAAM5C,EAAG6C,EAAO7C,GACpCK,EAAOuQ,EAAI9P,KAAK4B,IAAIE,EAAMgO,EAAG/N,EAAO+N,GAE7BvQ,GAWTgW,EAAWvT,mBAAqB,SAAUF,EAAOC,EAAQxC,GAYvD,OAVAC,QAAMC,OAAOC,OAAO,QAASoC,GAC7BtC,QAAMC,OAAOC,OAAO,SAAUqC,GAC9BvC,QAAMC,OAAOC,OAAO,SAAUH,GAG9BA,EAAOP,EAAIgB,KAAK0B,IAAII,EAAM9C,EAAG+C,EAAO/C,GACpCO,EAAON,EAAIe,KAAK0B,IAAII,EAAM7C,EAAG8C,EAAO9C,GACpCM,EAAOL,EAAIc,KAAK0B,IAAII,EAAM5C,EAAG6C,EAAO7C,GACpCK,EAAOuQ,EAAI9P,KAAK0B,IAAII,EAAMgO,EAAG/N,EAAO+N,GAE7BvQ,GASTgW,EAAWtT,iBAAmB,SAAU5B,GAKtC,OAHAb,QAAMC,OAAOC,OAAO,YAAaW,GAI/BA,EAAUrB,EAAIqB,EAAUrB,EACxBqB,EAAUpB,EAAIoB,EAAUpB,EACxBoB,EAAUnB,EAAImB,EAAUnB,EACxBmB,EAAUyP,EAAIzP,EAAUyP,GAU5ByF,EAAWzV,UAAY,SAAUO,GAC/B,OAAOL,KAAKkC,KAAKqT,EAAWtT,iBAAiB5B,KAG/C,IAAI8B,EAAkB,IAAIoT,EAe1BA,EAAWnT,SAAW,SAAUC,EAAMC,GAOpC,OALA9C,QAAMC,OAAOC,OAAO,OAAQ2C,GAC5B7C,QAAMC,OAAOC,OAAO,QAAS4C,GAG7BiT,EAAWhT,SAASF,EAAMC,EAAOH,GAC1BoT,EAAWzV,UAAUqC,IAiB9BoT,EAAW/S,gBAAkB,SAAUH,EAAMC,GAO3C,OALA9C,QAAMC,OAAOC,OAAO,OAAQ2C,GAC5B7C,QAAMC,OAAOC,OAAO,QAAS4C,GAG7BiT,EAAWhT,SAASF,EAAMC,EAAOH,GAC1BoT,EAAWtT,iBAAiBE,IAUrCoT,EAAW9S,UAAY,SAAUpC,EAAWd,GAE1CC,QAAMC,OAAOC,OAAO,YAAaW,GACjCb,QAAMC,OAAOC,OAAO,SAAUH,GAG9B,IAAIO,EAAYyV,EAAWzV,UAAUO,GAQrC,GANAd,EAAOP,EAAIqB,EAAUrB,EAAIc,EACzBP,EAAON,EAAIoB,EAAUpB,EAAIa,EACzBP,EAAOL,EAAImB,EAAUnB,EAAIY,EACzBP,EAAOuQ,EAAIzP,EAAUyP,EAAIhQ,EAIvB4C,MAAMnD,EAAOP,IACb0D,MAAMnD,EAAON,IACbyD,MAAMnD,EAAOL,IACbwD,MAAMnD,EAAOuQ,GAEb,MAAM,IAAI5O,iBAAe,qCAI3B,OAAO3B,GAUTgW,EAAW5S,IAAM,SAAUN,EAAMC,GAM/B,OAJA9C,QAAMC,OAAOC,OAAO,OAAQ2C,GAC5B7C,QAAMC,OAAOC,OAAO,QAAS4C,GAI3BD,EAAKrD,EAAIsD,EAAMtD,EAAIqD,EAAKpD,EAAIqD,EAAMrD,EAAIoD,EAAKnD,EAAIoD,EAAMpD,EAAImD,EAAKyN,EAAIxN,EAAMwN,GAY5EyF,EAAW3S,mBAAqB,SAAUP,EAAMC,EAAO/C,GAWrD,OATAC,QAAMC,OAAOC,OAAO,OAAQ2C,GAC5B7C,QAAMC,OAAOC,OAAO,QAAS4C,GAC7B9C,QAAMC,OAAOC,OAAO,SAAUH,GAG9BA,EAAOP,EAAIqD,EAAKrD,EAAIsD,EAAMtD,EAC1BO,EAAON,EAAIoD,EAAKpD,EAAIqD,EAAMrD,EAC1BM,EAAOL,EAAImD,EAAKnD,EAAIoD,EAAMpD,EAC1BK,EAAOuQ,EAAIzN,EAAKyN,EAAIxN,EAAMwN,EACnBvQ,GAWTgW,EAAW1S,iBAAmB,SAAUR,EAAMC,EAAO/C,GAWnD,OATAC,QAAMC,OAAOC,OAAO,OAAQ2C,GAC5B7C,QAAMC,OAAOC,OAAO,QAAS4C,GAC7B9C,QAAMC,OAAOC,OAAO,SAAUH,GAG9BA,EAAOP,EAAIqD,EAAKrD,EAAIsD,EAAMtD,EAC1BO,EAAON,EAAIoD,EAAKpD,EAAIqD,EAAMrD,EAC1BM,EAAOL,EAAImD,EAAKnD,EAAIoD,EAAMpD,EAC1BK,EAAOuQ,EAAIzN,EAAKyN,EAAIxN,EAAMwN,EACnBvQ,GAWTgW,EAAWzS,IAAM,SAAUT,EAAMC,EAAO/C,GAWtC,OATAC,QAAMC,OAAOC,OAAO,OAAQ2C,GAC5B7C,QAAMC,OAAOC,OAAO,QAAS4C,GAC7B9C,QAAMC,OAAOC,OAAO,SAAUH,GAG9BA,EAAOP,EAAIqD,EAAKrD,EAAIsD,EAAMtD,EAC1BO,EAAON,EAAIoD,EAAKpD,EAAIqD,EAAMrD,EAC1BM,EAAOL,EAAImD,EAAKnD,EAAIoD,EAAMpD,EAC1BK,EAAOuQ,EAAIzN,EAAKyN,EAAIxN,EAAMwN,EACnBvQ,GAWTgW,EAAWhT,SAAW,SAAUF,EAAMC,EAAO/C,GAW3C,OATAC,QAAMC,OAAOC,OAAO,OAAQ2C,GAC5B7C,QAAMC,OAAOC,OAAO,QAAS4C,GAC7B9C,QAAMC,OAAOC,OAAO,SAAUH,GAG9BA,EAAOP,EAAIqD,EAAKrD,EAAIsD,EAAMtD,EAC1BO,EAAON,EAAIoD,EAAKpD,EAAIqD,EAAMrD,EAC1BM,EAAOL,EAAImD,EAAKnD,EAAIoD,EAAMpD,EAC1BK,EAAOuQ,EAAIzN,EAAKyN,EAAIxN,EAAMwN,EACnBvQ,GAWTgW,EAAWxS,iBAAmB,SAAU1C,EAAW2C,EAAQzD,GAWzD,OATAC,QAAMC,OAAOC,OAAO,YAAaW,GACjCb,QAAMC,OAAO4B,OAAO,SAAU2B,GAC9BxD,QAAMC,OAAOC,OAAO,SAAUH,GAG9BA,EAAOP,EAAIqB,EAAUrB,EAAIgE,EACzBzD,EAAON,EAAIoB,EAAUpB,EAAI+D,EACzBzD,EAAOL,EAAImB,EAAUnB,EAAI8D,EACzBzD,EAAOuQ,EAAIzP,EAAUyP,EAAI9M,EAClBzD,GAWTgW,EAAWtS,eAAiB,SAAU5C,EAAW2C,EAAQzD,GAWvD,OATAC,QAAMC,OAAOC,OAAO,YAAaW,GACjCb,QAAMC,OAAO4B,OAAO,SAAU2B,GAC9BxD,QAAMC,OAAOC,OAAO,SAAUH,GAG9BA,EAAOP,EAAIqB,EAAUrB,EAAIgE,EACzBzD,EAAON,EAAIoB,EAAUpB,EAAI+D,EACzBzD,EAAOL,EAAImB,EAAUnB,EAAI8D,EACzBzD,EAAOuQ,EAAIzP,EAAUyP,EAAI9M,EAClBzD,GAUTgW,EAAWrS,OAAS,SAAU7C,EAAWd,GAUvC,OARAC,QAAMC,OAAOC,OAAO,YAAaW,GACjCb,QAAMC,OAAOC,OAAO,SAAUH,GAG9BA,EAAOP,GAAKqB,EAAUrB,EACtBO,EAAON,GAAKoB,EAAUpB,EACtBM,EAAOL,GAAKmB,EAAUnB,EACtBK,EAAOuQ,GAAKzP,EAAUyP,EACfvQ,GAUTgW,EAAWpS,IAAM,SAAU9C,EAAWd,GAUpC,OARAC,QAAMC,OAAOC,OAAO,YAAaW,GACjCb,QAAMC,OAAOC,OAAO,SAAUH,GAG9BA,EAAOP,EAAIgB,KAAKmD,IAAI9C,EAAUrB,GAC9BO,EAAON,EAAIe,KAAKmD,IAAI9C,EAAUpB,GAC9BM,EAAOL,EAAIc,KAAKmD,IAAI9C,EAAUnB,GAC9BK,EAAOuQ,EAAI9P,KAAKmD,IAAI9C,EAAUyP,GACvBvQ,GAGT,IAAI6D,EAAc,IAAImS,EAUtBA,EAAWlS,KAAO,SAAUC,EAAOC,EAAKC,EAAGjE,GAUzC,OARAC,QAAMC,OAAOC,OAAO,QAAS4D,GAC7B9D,QAAMC,OAAOC,OAAO,MAAO6D,GAC3B/D,QAAMC,OAAO4B,OAAO,IAAKmC,GACzBhE,QAAMC,OAAOC,OAAO,SAAUH,GAG9BgW,EAAWxS,iBAAiBQ,EAAKC,EAAGJ,GACpC7D,EAASgW,EAAWxS,iBAAiBO,EAAO,EAAME,EAAGjE,GAC9CgW,EAAWzS,IAAIM,EAAa7D,EAAQA,IAG7C,IAAIyE,EAA4B,IAAIuR,EAQpCA,EAAWtR,mBAAqB,SAAU5D,EAAWd,GAEnDC,QAAMC,OAAOC,OAAO,YAAaW,GACjCb,QAAMC,OAAOC,OAAO,SAAUH,GAG9B,IAAI2E,EAAIqR,EAAW9S,UAAUpC,EAAW2D,GA2BxC,OA1BAuR,EAAWpS,IAAIe,EAAGA,GAKZ3E,EAHF2E,EAAElF,GAAKkF,EAAEjF,EACPiF,EAAElF,GAAKkF,EAAEhF,EACPgF,EAAElF,GAAKkF,EAAE4L,EACFyF,EAAWnV,MAAMmV,EAAWpR,OAAQ5E,GAEpCgW,EAAWnV,MAAMmV,EAAWiB,OAAQjX,GAEtC2E,EAAEhF,GAAKgF,EAAE4L,EACTyF,EAAWnV,MAAMmV,EAAWnR,OAAQ7E,GAEpCgW,EAAWnV,MAAMmV,EAAWiB,OAAQjX,GAEtC2E,EAAEjF,GAAKiF,EAAEhF,EACdgF,EAAEjF,GAAKiF,EAAE4L,EACFyF,EAAWnV,MAAMmV,EAAWlR,OAAQ9E,GAEpCgW,EAAWnV,MAAMmV,EAAWiB,OAAQjX,GAEtC2E,EAAEhF,GAAKgF,EAAE4L,EACTyF,EAAWnV,MAAMmV,EAAWnR,OAAQ7E,GAEpCgW,EAAWnV,MAAMmV,EAAWiB,OAAQjX,IAcjDgW,EAAW9Q,OAAS,SAAUpC,EAAMC,GAClC,OACED,IAASC,GACR3C,UAAQ0C,IACP1C,UAAQ2C,IACRD,EAAKrD,IAAMsD,EAAMtD,GACjBqD,EAAKpD,IAAMqD,EAAMrD,GACjBoD,EAAKnD,IAAMoD,EAAMpD,GACjBmD,EAAKyN,IAAMxN,EAAMwN,GAOvByF,EAAW7Q,YAAc,SAAUrE,EAAWK,EAAOiE,GACnD,OACEtE,EAAUrB,IAAM0B,EAAMiE,IACtBtE,EAAUpB,IAAMyB,EAAMiE,EAAS,IAC/BtE,EAAUnB,IAAMwB,EAAMiE,EAAS,IAC/BtE,EAAUyP,IAAMpP,EAAMiE,EAAS,IAenC4Q,EAAW3Q,cAAgB,SACzBvC,EACAC,EACAuC,EACAC,GAEA,OACEzC,IAASC,GACR3C,UAAQ0C,IACP1C,UAAQ2C,IACRyC,aAAWH,cACTvC,EAAKrD,EACLsD,EAAMtD,EACN6F,EACAC,IAEFC,aAAWH,cACTvC,EAAKpD,EACLqD,EAAMrD,EACN4F,EACAC,IAEFC,aAAWH,cACTvC,EAAKnD,EACLoD,EAAMpD,EACN2F,EACAC,IAEFC,aAAWH,cACTvC,EAAKyN,EACLxN,EAAMwN,EACNjL,EACAC,IAWRyQ,EAAW9O,KAAOC,OAAOC,OAAO,IAAI4O,EAAW,EAAK,EAAK,EAAK,IAQ9DA,EAAW3O,IAAMF,OAAOC,OAAO,IAAI4O,EAAW,EAAK,EAAK,EAAK,IAQ7DA,EAAWpR,OAASuC,OAAOC,OAAO,IAAI4O,EAAW,EAAK,EAAK,EAAK,IAQhEA,EAAWlR,OAASqC,OAAOC,OAAO,IAAI4O,EAAW,EAAK,EAAK,EAAK,IAQhEA,EAAWnR,OAASsC,OAAOC,OAAO,IAAI4O,EAAW,EAAK,EAAK,EAAK,IAQhEA,EAAWiB,OAAS9P,OAAOC,OAAO,IAAI4O,EAAW,EAAK,EAAK,EAAK,IAQhEA,EAAW1O,UAAUzG,MAAQ,SAAUb,GACrC,OAAOgW,EAAWnV,MAAMjB,KAAMI,IAUhCgW,EAAW1O,UAAUpC,OAAS,SAAUnC,GACtC,OAAOiT,EAAW9Q,OAAOtF,KAAMmD,IAajCiT,EAAW1O,UAAUjC,cAAgB,SACnCtC,EACAuC,EACAC,GAEA,OAAOyQ,EAAW3Q,cAChBzF,KACAmD,EACAuC,EACAC,IASJyQ,EAAW1O,UAAUC,SAAW,WAC9B,MAAO,IAAM3H,KAAKH,EAAI,KAAOG,KAAKF,EAAI,KAAOE,KAAKD,EAAI,KAAOC,KAAK2Q,EAAI,KAIxE,IAAI2G,EAAkB,IAAIC,aAAa,GACnCC,EAAiB,IAAIC,WAAWH,EAAgB9J,QAEhDkK,EAAU,IAAIC,YAAY,CAAC,YAE3BC,EAA6B,KADpB,IAAIH,WAAWC,EAAQlK,QACV,GCj0B1B,SAASqK,EACPzJ,EACAC,EACAC,EACAwJ,EACAvJ,EACAC,EACAC,EACAsJ,EACArJ,EACAC,EACAC,EACAoJ,EACAC,EACAC,EACAC,EACAC,GAEApY,KAAK,GAAKC,eAAamO,EAAa,GACpCpO,KAAK,GAAKC,eAAasO,EAAa,GACpCvO,KAAK,GAAKC,eAAayO,EAAa,GACpC1O,KAAK,GAAKC,eAAagY,EAAa,GACpCjY,KAAK,GAAKC,eAAaoO,EAAa,GACpCrO,KAAK,GAAKC,eAAauO,EAAa,GACpCxO,KAAK,GAAKC,eAAa0O,EAAa,GACpC3O,KAAK,GAAKC,eAAaiY,EAAa,GACpClY,KAAK,GAAKC,eAAaqO,EAAa,GACpCtO,KAAK,GAAKC,eAAawO,EAAa,GACpCzO,KAAK,IAAMC,eAAa2O,EAAa,GACrC5O,KAAK,IAAMC,eAAakY,EAAa,GACrCnY,KAAK,IAAMC,eAAa6X,EAAa,GACrC9X,KAAK,IAAMC,eAAa8X,EAAa,GACrC/X,KAAK,IAAMC,eAAa+X,EAAa,GACrChY,KAAK,IAAMC,eAAamY,EAAa,GDyyBvChC,EAAWiC,UAAY,SAAU/W,EAAOlB,GAwBtC,OAtBAC,QAAMC,OAAO4B,OAAO,QAASZ,GAGxBd,UAAQJ,KACXA,EAAS,IAAIgW,GAIfkB,EAAgB,GAAKhW,EAEjBsW,GACFxX,EAAOP,EAAI2X,EAAe,GAC1BpX,EAAON,EAAI0X,EAAe,GAC1BpX,EAAOL,EAAIyX,EAAe,GAC1BpX,EAAOuQ,EAAI6G,EAAe,KAG1BpX,EAAOP,EAAI2X,EAAe,GAC1BpX,EAAON,EAAI0X,EAAe,GAC1BpX,EAAOL,EAAIyX,EAAe,GAC1BpX,EAAOuQ,EAAI6G,EAAe,IAErBpX,GAUTgW,EAAWkC,YAAc,SAAUC,GAkBjC,OAhBAlY,QAAMC,OAAOC,OAAO,cAAegY,GAI/BX,GACFJ,EAAe,GAAKe,EAAY1Y,EAChC2X,EAAe,GAAKe,EAAYzY,EAChC0X,EAAe,GAAKe,EAAYxY,EAChCyX,EAAe,GAAKe,EAAY5H,IAGhC6G,EAAe,GAAKe,EAAY5H,EAChC6G,EAAe,GAAKe,EAAYxY,EAChCyX,EAAe,GAAKe,EAAYzY,EAChC0X,EAAe,GAAKe,EAAY1Y,GAE3ByX,EAAgB,ICt1BzBO,EAAQzW,aAAe,GAWvByW,EAAQxW,KAAO,SAAUC,EAAOC,EAAOC,GAyBrC,OAvBAnB,QAAMC,OAAOC,OAAO,QAASe,GAC7BjB,QAAMG,QAAQ,QAASe,GAGvBC,EAAgBvB,eAAauB,EAAe,GAE5CD,EAAMC,KAAmBF,EAAM,GAC/BC,EAAMC,KAAmBF,EAAM,GAC/BC,EAAMC,KAAmBF,EAAM,GAC/BC,EAAMC,KAAmBF,EAAM,GAC/BC,EAAMC,KAAmBF,EAAM,GAC/BC,EAAMC,KAAmBF,EAAM,GAC/BC,EAAMC,KAAmBF,EAAM,GAC/BC,EAAMC,KAAmBF,EAAM,GAC/BC,EAAMC,KAAmBF,EAAM,GAC/BC,EAAMC,KAAmBF,EAAM,GAC/BC,EAAMC,KAAmBF,EAAM,IAC/BC,EAAMC,KAAmBF,EAAM,IAC/BC,EAAMC,KAAmBF,EAAM,IAC/BC,EAAMC,KAAmBF,EAAM,IAC/BC,EAAMC,KAAmBF,EAAM,IAC/BC,EAAMC,GAAiBF,EAAM,IAEtBC,GAWTsW,EAAQpW,OAAS,SAAUF,EAAOC,EAAepB,GA2B/C,OAzBAC,QAAMG,QAAQ,QAASe,GAGvBC,EAAgBvB,eAAauB,EAAe,GAEvChB,UAAQJ,KACXA,EAAS,IAAIyX,GAGfzX,EAAO,GAAKmB,EAAMC,KAClBpB,EAAO,GAAKmB,EAAMC,KAClBpB,EAAO,GAAKmB,EAAMC,KAClBpB,EAAO,GAAKmB,EAAMC,KAClBpB,EAAO,GAAKmB,EAAMC,KAClBpB,EAAO,GAAKmB,EAAMC,KAClBpB,EAAO,GAAKmB,EAAMC,KAClBpB,EAAO,GAAKmB,EAAMC,KAClBpB,EAAO,GAAKmB,EAAMC,KAClBpB,EAAO,GAAKmB,EAAMC,KAClBpB,EAAO,IAAMmB,EAAMC,KACnBpB,EAAO,IAAMmB,EAAMC,KACnBpB,EAAO,IAAMmB,EAAMC,KACnBpB,EAAO,IAAMmB,EAAMC,KACnBpB,EAAO,IAAMmB,EAAMC,KACnBpB,EAAO,IAAMmB,EAAMC,GACZpB,GAUTyX,EAAQ5W,MAAQ,SAAUiP,EAAQ9P,GAChC,GAAKI,UAAQ0P,GAGb,OAAK1P,UAAQJ,IAoBbA,EAAO,GAAK8P,EAAO,GACnB9P,EAAO,GAAK8P,EAAO,GACnB9P,EAAO,GAAK8P,EAAO,GACnB9P,EAAO,GAAK8P,EAAO,GACnB9P,EAAO,GAAK8P,EAAO,GACnB9P,EAAO,GAAK8P,EAAO,GACnB9P,EAAO,GAAK8P,EAAO,GACnB9P,EAAO,GAAK8P,EAAO,GACnB9P,EAAO,GAAK8P,EAAO,GACnB9P,EAAO,GAAK8P,EAAO,GACnB9P,EAAO,IAAM8P,EAAO,IACpB9P,EAAO,IAAM8P,EAAO,IACpB9P,EAAO,IAAM8P,EAAO,IACpB9P,EAAO,IAAM8P,EAAO,IACpB9P,EAAO,IAAM8P,EAAO,IACpB9P,EAAO,IAAM8P,EAAO,IACb9P,GAnCE,IAAIyX,EACT3H,EAAO,GACPA,EAAO,GACPA,EAAO,GACPA,EAAO,IACPA,EAAO,GACPA,EAAO,GACPA,EAAO,GACPA,EAAO,IACPA,EAAO,GACPA,EAAO,GACPA,EAAO,IACPA,EAAO,IACPA,EAAO,GACPA,EAAO,GACPA,EAAO,IACPA,EAAO,MA6Cb2H,EAAQxV,UAAYwV,EAAQpW,OAS5BoW,EAAQ1H,qBAAuB,SAAUC,EAAQhQ,GAK/C,OAHAC,QAAMG,QAAQ,SAAU4P,GAGjByH,EAAQ5W,MAAMmP,EAAQhQ,IAW/ByX,EAAQxH,kBAAoB,SAAUD,EAAQhQ,GAK5C,OAHAC,QAAMG,QAAQ,SAAU4P,GAGnB5P,UAAQJ,IAoBbA,EAAO,GAAKgQ,EAAO,GACnBhQ,EAAO,GAAKgQ,EAAO,GACnBhQ,EAAO,GAAKgQ,EAAO,GACnBhQ,EAAO,GAAKgQ,EAAO,IACnBhQ,EAAO,GAAKgQ,EAAO,GACnBhQ,EAAO,GAAKgQ,EAAO,GACnBhQ,EAAO,GAAKgQ,EAAO,GACnBhQ,EAAO,GAAKgQ,EAAO,IACnBhQ,EAAO,GAAKgQ,EAAO,GACnBhQ,EAAO,GAAKgQ,EAAO,GACnBhQ,EAAO,IAAMgQ,EAAO,IACpBhQ,EAAO,IAAMgQ,EAAO,IACpBhQ,EAAO,IAAMgQ,EAAO,GACpBhQ,EAAO,IAAMgQ,EAAO,GACpBhQ,EAAO,IAAMgQ,EAAO,IACpBhQ,EAAO,IAAMgQ,EAAO,IACbhQ,GAnCE,IAAIyX,EACTzH,EAAO,GACPA,EAAO,GACPA,EAAO,GACPA,EAAO,GACPA,EAAO,GACPA,EAAO,GACPA,EAAO,GACPA,EAAO,GACPA,EAAO,GACPA,EAAO,GACPA,EAAO,IACPA,EAAO,IACPA,EAAO,IACPA,EAAO,IACPA,EAAO,IACPA,EAAO,MA+BbyH,EAAQW,wBAA0B,SAAUC,EAAUC,EAAatY,GAOjE,OALAC,QAAMC,OAAOC,OAAO,WAAYkY,GAGhCC,EAAczY,eAAayY,EAAa9Y,EAAW0H,MAE9C9G,UAAQJ,IAqBbA,EAAO,GAAKqY,EAAS,GACrBrY,EAAO,GAAKqY,EAAS,GACrBrY,EAAO,GAAKqY,EAAS,GACrBrY,EAAO,GAAK,EACZA,EAAO,GAAKqY,EAAS,GACrBrY,EAAO,GAAKqY,EAAS,GACrBrY,EAAO,GAAKqY,EAAS,GACrBrY,EAAO,GAAK,EACZA,EAAO,GAAKqY,EAAS,GACrBrY,EAAO,GAAKqY,EAAS,GACrBrY,EAAO,IAAMqY,EAAS,GACtBrY,EAAO,IAAM,EACbA,EAAO,IAAMsY,EAAY7Y,EACzBO,EAAO,IAAMsY,EAAY5Y,EACzBM,EAAO,IAAMsY,EAAY3Y,EACzBK,EAAO,IAAM,EACNA,GApCE,IAAIyX,EACTY,EAAS,GACTA,EAAS,GACTA,EAAS,GACTC,EAAY7Y,EACZ4Y,EAAS,GACTA,EAAS,GACTA,EAAS,GACTC,EAAY5Y,EACZ2Y,EAAS,GACTA,EAAS,GACTA,EAAS,GACTC,EAAY3Y,EACZ,EACA,EACA,EACA,IAwCN8X,EAAQc,uCAAyC,SAC/CD,EACAD,EACAxG,EACA7R,GAGAC,QAAMC,OAAOC,OAAO,cAAemY,GACnCrY,QAAMC,OAAOC,OAAO,WAAYkY,GAChCpY,QAAMC,OAAOC,OAAO,QAAS0R,GAGxBzR,UAAQJ,KACXA,EAAS,IAAIyX,GAGf,IAAIe,EAAS3G,EAAMpS,EACfgZ,EAAS5G,EAAMnS,EACfgZ,EAAS7G,EAAMlS,EAEfyI,EAAKiQ,EAAS5Y,EAAI4Y,EAAS5Y,EAC3B2Q,EAAKiI,EAAS5Y,EAAI4Y,EAAS3Y,EAC3B2Q,EAAKgI,EAAS5Y,EAAI4Y,EAAS1Y,EAC3B2Q,EAAK+H,EAAS5Y,EAAI4Y,EAAS9H,EAC3BlI,EAAKgQ,EAAS3Y,EAAI2Y,EAAS3Y,EAC3B8Q,EAAK6H,EAAS3Y,EAAI2Y,EAAS1Y,EAC3B8Q,EAAK4H,EAAS3Y,EAAI2Y,EAAS9H,EAC3BjI,EAAK+P,EAAS1Y,EAAI0Y,EAAS1Y,EAC3B+Q,EAAK2H,EAAS1Y,EAAI0Y,EAAS9H,EAC3BI,EAAK0H,EAAS9H,EAAI8H,EAAS9H,EAE3BK,EAAMxI,EAAKC,EAAKC,EAAKqI,EACrBE,EAAM,GAAOT,EAAKM,GAClBI,EAAM,GAAOT,EAAKI,GAElBM,EAAM,GAAOX,EAAKM,GAClBM,GAAO5I,EAAKC,EAAKC,EAAKqI,EACtBM,EAAM,GAAOT,EAAKF,GAElBY,EAAM,GAAOb,EAAKI,GAClBU,EAAM,GAAOX,EAAKF,GAClBc,GAAOhJ,EAAKC,EAAKC,EAAKqI,EAmB1B,OAjBA3Q,EAAO,GAAK4Q,EAAM4H,EAClBxY,EAAO,GAAK+Q,EAAMyH,EAClBxY,EAAO,GAAKkR,EAAMsH,EAClBxY,EAAO,GAAK,EACZA,EAAO,GAAK6Q,EAAM4H,EAClBzY,EAAO,GAAKgR,EAAMyH,EAClBzY,EAAO,GAAKmR,EAAMsH,EAClBzY,EAAO,GAAK,EACZA,EAAO,GAAK8Q,EAAM4H,EAClB1Y,EAAO,GAAKiR,EAAMyH,EAClB1Y,EAAO,IAAMoR,EAAMsH,EACnB1Y,EAAO,IAAM,EACbA,EAAO,IAAMsY,EAAY7Y,EACzBO,EAAO,IAAMsY,EAAY5Y,EACzBM,EAAO,IAAMsY,EAAY3Y,EACzBK,EAAO,IAAM,EAENA,GAUTyX,EAAQkB,6BAA+B,SACrCC,EACA5Y,GAMA,OAHAC,QAAMC,OAAOC,OAAO,2BAA4ByY,GAGzCnB,EAAQc,uCACbK,EAAyBN,YACzBM,EAAyBP,SACzBO,EAAyB/G,MACzB7R,IAaJyX,EAAQoB,gBAAkB,SAAUP,EAAatY,GAK/C,OAHAC,QAAMC,OAAOC,OAAO,cAAemY,GAG5Bb,EAAQW,wBAAwBrK,EAAQ6G,SAAU0D,EAAatY,IAkBxEyX,EAAQ7F,UAAY,SAAUC,EAAO7R,GAKnC,OAHAC,QAAMC,OAAOC,OAAO,QAAS0R,GAGxBzR,UAAQJ,IAqBbA,EAAO,GAAK6R,EAAMpS,EAClBO,EAAO,GAAK,EACZA,EAAO,GAAK,EACZA,EAAO,GAAK,EACZA,EAAO,GAAK,EACZA,EAAO,GAAK6R,EAAMnS,EAClBM,EAAO,GAAK,EACZA,EAAO,GAAK,EACZA,EAAO,GAAK,EACZA,EAAO,GAAK,EACZA,EAAO,IAAM6R,EAAMlS,EACnBK,EAAO,IAAM,EACbA,EAAO,IAAM,EACbA,EAAO,IAAM,EACbA,EAAO,IAAM,EACbA,EAAO,IAAM,EACNA,GApCE,IAAIyX,EACT5F,EAAMpS,EACN,EACA,EACA,EACA,EACAoS,EAAMnS,EACN,EACA,EACA,EACA,EACAmS,EAAMlS,EACN,EACA,EACA,EACA,EACA,IAsCN8X,EAAQ3F,iBAAmB,SAAUD,EAAO7R,GAK1C,OAHAC,QAAMC,OAAO4B,OAAO,QAAS+P,GAGxBzR,UAAQJ,IAqBbA,EAAO,GAAK6R,EACZ7R,EAAO,GAAK,EACZA,EAAO,GAAK,EACZA,EAAO,GAAK,EACZA,EAAO,GAAK,EACZA,EAAO,GAAK6R,EACZ7R,EAAO,GAAK,EACZA,EAAO,GAAK,EACZA,EAAO,GAAK,EACZA,EAAO,GAAK,EACZA,EAAO,IAAM6R,EACb7R,EAAO,IAAM,EACbA,EAAO,IAAM,EACbA,EAAO,IAAM,EACbA,EAAO,IAAM,EACbA,EAAO,IAAM,EACNA,GApCE,IAAIyX,EACT5F,EACA,EACA,EACA,EACA,EACAA,EACA,EACA,EACA,EACA,EACAA,EACA,EACA,EACA,EACA,EACA,IAuBN,IAAIiH,EAAc,IAAItZ,EAClBuZ,GAAc,IAAIvZ,EAClBwZ,GAAc,IAAIxZ,EAStBiY,EAAQwB,WAAa,SAAUC,EAAQlZ,GAErCC,QAAMC,OAAOC,OAAO,SAAU+Y,GAG9B,IAAIjM,EAAWiM,EAAOjM,SAClBkM,EAAYD,EAAOC,UACnBC,EAAKF,EAAOE,GAGhBnZ,QAAMC,OAAOC,OAAO,kBAAmB8M,GACvChN,QAAMC,OAAOC,OAAO,mBAAoBgZ,GACxClZ,QAAMC,OAAOC,OAAO,YAAaiZ,GAGjC5Z,EAAW0D,UAAUiW,EAAWL,GAChCtZ,EAAW0D,UACT1D,EAAW+E,MAAMuU,EAAaM,EAAIL,IAClCA,IAEFvZ,EAAW0D,UACT1D,EAAW+E,MAAMwU,GAAaD,EAAaE,IAC3CA,IAGF,IAAIK,EAAKN,GAAYtZ,EACjB6Z,EAAKP,GAAYrZ,EACjB6Z,EAAKR,GAAYpZ,EACjB6Z,EAAKV,EAAYrZ,EACjBga,EAAKX,EAAYpZ,EACjBga,EAAKZ,EAAYnZ,EACjBga,EAAKX,GAAYvZ,EACjBma,EAAKZ,GAAYtZ,EACjBma,EAAKb,GAAYrZ,EACjBmI,EAAYmF,EAASxN,EACrBsI,EAAYkF,EAASvN,EACrBsI,EAAYiF,EAAStN,EACrBma,EAAKT,GAAMvR,EAAYwR,GAAMvR,EAAYwR,GAAMvR,EAC/C+R,EAAKJ,GAAM7R,EAAY8R,GAAM7R,EAAY8R,GAAM7R,EAC/CgS,EAAKR,EAAK1R,EAAY2R,EAAK1R,EAAY2R,EAAK1R,EAiBhD,OAAK5H,UAAQJ,IAoBbA,EAAO,GAAKqZ,EACZrZ,EAAO,GAAK2Z,EACZ3Z,EAAO,IAAMwZ,EACbxZ,EAAO,GAAK,EACZA,EAAO,GAAKsZ,EACZtZ,EAAO,GAAK4Z,EACZ5Z,EAAO,IAAMyZ,EACbzZ,EAAO,GAAK,EACZA,EAAO,GAAKuZ,EACZvZ,EAAO,GAAK6Z,EACZ7Z,EAAO,KAAO0Z,EACd1Z,EAAO,IAAM,EACbA,EAAO,IAAM8Z,EACb9Z,EAAO,IAAM+Z,EACb/Z,EAAO,IAAMga,EACbha,EAAO,IAAM,EACNA,GAnCE,IAAIyX,EACT4B,EACAC,EACAC,EACAO,EACAH,EACAC,EACAC,EACAE,GACCP,GACAC,GACAC,EACDM,EACA,EACA,EACA,EACA,IAqCNvC,EAAQwC,8BAAgC,SACtCC,EACAC,EACAC,EACAC,EACAra,GAGAC,QAAMC,OAAO4B,OAAOwL,YAAY,OAAQ4M,EAAM,GAC9Cja,QAAMC,OAAO4B,OAAOwY,SAAS,OAAQJ,EAAMzZ,KAAK8Z,IAChDta,QAAMC,OAAO4B,OAAOwL,YAAY,OAAQ8M,EAAM,GAC9Cna,QAAMC,OAAO4B,OAAOwL,YAAY,MAAO+M,EAAK,GAC5Cpa,QAAMC,OAAOC,OAAO,SAAUH,GAG9B,IAEIoO,EAAc,EAFL3N,KAAK+Z,IAAW,GAAPN,GAGlBlM,EAAcI,EAAc+L,EAC5B3L,GAAe6L,EAAMD,IAASA,EAAOC,GACrCzC,EAAe,EAAMyC,EAAMD,GAASA,EAAOC,GAkB/C,OAhBAra,EAAO,GAAKgO,EACZhO,EAAO,GAAK,EACZA,EAAO,GAAK,EACZA,EAAO,GAAK,EACZA,EAAO,GAAK,EACZA,EAAO,GAAKoO,EACZpO,EAAO,GAAK,EACZA,EAAO,GAAK,EACZA,EAAO,GAAK,EACZA,EAAO,GAAK,EACZA,EAAO,IAAMwO,EACbxO,EAAO,KAAO,EACdA,EAAO,IAAM,EACbA,EAAO,IAAM,EACbA,EAAO,IAAM4X,EACb5X,EAAO,IAAM,EACNA,GAeTyX,EAAQgD,6BAA+B,SACrC3X,EACAC,EACA2X,EACAC,EACAP,EACAC,EACAra,GAGAC,QAAMC,OAAO4B,OAAO,OAAQgB,GAC5B7C,QAAMC,OAAO4B,OAAO,QAASiB,GAC7B9C,QAAMC,OAAO4B,OAAO,SAAU4Y,GAC9Bza,QAAMC,OAAO4B,OAAO,MAAO6Y,GAC3B1a,QAAMC,OAAO4B,OAAO,OAAQsY,GAC5Bna,QAAMC,OAAO4B,OAAO,MAAOuY,GAC3Bpa,QAAMC,OAAOC,OAAO,SAAUH,GAG9B,IAAIgF,EAAI,GAAOjC,EAAQD,GACnBmC,EAAI,GAAO0V,EAAMD,GACjBlG,EAAI,GAAO6F,EAAMD,GAEjBQ,IAAO7X,EAAQD,GAAQkC,EACvB6V,IAAOF,EAAMD,GAAUzV,EACvB6V,IAAOT,EAAMD,GAAQ5F,EAqBzB,OApBAxP,GAAK,EACLC,GAAK,EACLuP,IAAM,EAENxU,EAAO,GAAKgF,EACZhF,EAAO,GAAK,EACZA,EAAO,GAAK,EACZA,EAAO,GAAK,EACZA,EAAO,GAAK,EACZA,EAAO,GAAKiF,EACZjF,EAAO,GAAK,EACZA,EAAO,GAAK,EACZA,EAAO,GAAK,EACZA,EAAO,GAAK,EACZA,EAAO,IAAMwU,EACbxU,EAAO,IAAM,EACbA,EAAO,IAAM4a,EACb5a,EAAO,IAAM6a,EACb7a,EAAO,IAAM8a,EACb9a,EAAO,IAAM,EACNA,GAeTyX,EAAQsD,4BAA8B,SACpCjY,EACAC,EACA2X,EACAC,EACAP,EACAC,EACAra,GAGAC,QAAMC,OAAO4B,OAAO,OAAQgB,GAC5B7C,QAAMC,OAAO4B,OAAO,QAASiB,GAC7B9C,QAAMC,OAAO4B,OAAO,SAAU4Y,GAC9Bza,QAAMC,OAAO4B,OAAO,MAAO6Y,GAC3B1a,QAAMC,OAAO4B,OAAO,OAAQsY,GAC5Bna,QAAMC,OAAO4B,OAAO,MAAOuY,GAC3Bpa,QAAMC,OAAOC,OAAO,SAAUH,GAG9B,IAAIgO,EAAe,EAAMoM,GAASrX,EAAQD,GACtCsL,EAAe,EAAMgM,GAASO,EAAMD,GACpCxM,GAAenL,EAAQD,IAASC,EAAQD,GACxCuL,GAAesM,EAAMD,IAAWC,EAAMD,GACtClM,IAAgB6L,EAAMD,IAASC,EAAMD,GAErCxC,GAAgB,EAAMyC,EAAMD,GAASC,EAAMD,GAkB/C,OAhBApa,EAAO,GAAKgO,EACZhO,EAAO,GAAK,EACZA,EAAO,GAAK,EACZA,EAAO,GAAK,EACZA,EAAO,GAAK,EACZA,EAAO,GAAKoO,EACZpO,EAAO,GAAK,EACZA,EAAO,GAAK,EACZA,EAAO,GAAKkO,EACZlO,EAAO,GAAKqO,EACZrO,EAAO,IAAMwO,EACbxO,EAAO,KAdY,EAenBA,EAAO,IAAM,EACbA,EAAO,IAAM,EACbA,EAAO,IAAM4X,EACb5X,EAAO,IAAM,EACNA,GAcTyX,EAAQuD,oCAAsC,SAC5ClY,EACAC,EACA2X,EACAC,EACAP,EACApa,GAGAC,QAAMC,OAAO4B,OAAO,OAAQgB,GAC5B7C,QAAMC,OAAO4B,OAAO,QAASiB,GAC7B9C,QAAMC,OAAO4B,OAAO,SAAU4Y,GAC9Bza,QAAMC,OAAO4B,OAAO,MAAO6Y,GAC3B1a,QAAMC,OAAO4B,OAAO,OAAQsY,GAC5Bna,QAAMC,OAAOC,OAAO,SAAUH,GAG9B,IAAIgO,EAAe,EAAMoM,GAASrX,EAAQD,GACtCsL,EAAe,EAAMgM,GAASO,EAAMD,GACpCxM,GAAenL,EAAQD,IAASC,EAAQD,GACxCuL,GAAesM,EAAMD,IAAWC,EAAMD,GAGtC9C,GAAe,EAAMwC,EAkBzB,OAhBApa,EAAO,GAAKgO,EACZhO,EAAO,GAAK,EACZA,EAAO,GAAK,EACZA,EAAO,GAAK,EACZA,EAAO,GAAK,EACZA,EAAO,GAAKoO,EACZpO,EAAO,GAAK,EACZA,EAAO,GAAK,EACZA,EAAO,GAAKkO,EACZlO,EAAO,GAAKqO,EACZrO,EAAO,KAdY,EAenBA,EAAO,KAdY,EAenBA,EAAO,IAAM,EACbA,EAAO,IAAM,EACbA,EAAO,IAAM4X,EACb5X,EAAO,IAAM,EACNA,GAqBTyX,EAAQwD,8BAAgC,SACtCC,EACAC,EACAC,EACApb,GAEKI,UAAQJ,KACXA,EAAS,IAAIyX,GAGfyD,EAAWrb,eAAaqb,EAAUrb,eAAawb,cAC/C,IAAI5b,EAAII,eAAaqb,EAASzb,EAAG,GAC7BC,EAAIG,eAAaqb,EAASxb,EAAG,GAC7B4b,EAAQzb,eAAaqb,EAASI,MAAO,GACrCnV,EAAStG,eAAaqb,EAAS/U,OAAQ,GAC3CgV,EAAiBtb,eAAasb,EAAgB,GAG9C,IAAII,EAAoB,GAARD,EACZE,EAAsB,GAATrV,EACbsV,EAA+C,KAJnDL,EAAgBvb,eAAaub,EAAe,IAIXD,GAE7BnN,EAAcuN,EACdnN,EAAcoN,EACdhN,EAAciN,EACd/D,EAAcjY,EAAI8b,EAClB5D,EAAcjY,EAAI8b,EAClB5D,EAAcuD,EAAiBM,EAmBnC,OAhBAzb,EAAO,GAAKgO,EACZhO,EAAO,GAAK,EACZA,EAAO,GAAK,EACZA,EAAO,GAAK,EACZA,EAAO,GAAK,EACZA,EAAO,GAAKoO,EACZpO,EAAO,GAAK,EACZA,EAAO,GAAK,EACZA,EAAO,GAAK,EACZA,EAAO,GAAK,EACZA,EAAO,IAAMwO,EACbxO,EAAO,IAAM,EACbA,EAAO,IAAM0X,EACb1X,EAAO,IAAM2X,EACb3X,EAAO,IAAM4X,EACb5X,EAAO,IAjBW,EAkBXA,GAaTyX,EAAQiE,YAAc,SAAUzO,EAAUkM,EAAWC,EAAIrW,EAAO/C,GAyB9D,OAvBAC,QAAMC,OAAOC,OAAO,WAAY8M,GAChChN,QAAMC,OAAOC,OAAO,YAAagZ,GACjClZ,QAAMC,OAAOC,OAAO,KAAMiZ,GAC1BnZ,QAAMC,OAAOC,OAAO,QAAS4C,GAC7B9C,QAAMC,OAAOC,OAAO,SAAUH,GAG9BA,EAAO,GAAK+C,EAAMtD,EAClBO,EAAO,GAAKoZ,EAAG3Z,EACfO,EAAO,IAAMmZ,EAAU1Z,EACvBO,EAAO,GAAK,EACZA,EAAO,GAAK+C,EAAMrD,EAClBM,EAAO,GAAKoZ,EAAG1Z,EACfM,EAAO,IAAMmZ,EAAUzZ,EACvBM,EAAO,GAAK,EACZA,EAAO,GAAK+C,EAAMpD,EAClBK,EAAO,GAAKoZ,EAAGzZ,EACfK,EAAO,KAAOmZ,EAAUxZ,EACxBK,EAAO,IAAM,EACbA,EAAO,KAAOR,EAAW4D,IAAIL,EAAOkK,GACpCjN,EAAO,KAAOR,EAAW4D,IAAIgW,EAAInM,GACjCjN,EAAO,IAAMR,EAAW4D,IAAI+V,EAAWlM,GACvCjN,EAAO,IAAM,EACNA,GAsBTyX,EAAQlF,QAAU,SAAUzC,EAAQ9P,GAKlC,OAHAC,QAAMC,OAAOC,OAAO,SAAU2P,GAGzB1P,UAAQJ,IAoBbA,EAAO,GAAK8P,EAAO,GACnB9P,EAAO,GAAK8P,EAAO,GACnB9P,EAAO,GAAK8P,EAAO,GACnB9P,EAAO,GAAK8P,EAAO,GACnB9P,EAAO,GAAK8P,EAAO,GACnB9P,EAAO,GAAK8P,EAAO,GACnB9P,EAAO,GAAK8P,EAAO,GACnB9P,EAAO,GAAK8P,EAAO,GACnB9P,EAAO,GAAK8P,EAAO,GACnB9P,EAAO,GAAK8P,EAAO,GACnB9P,EAAO,IAAM8P,EAAO,IACpB9P,EAAO,IAAM8P,EAAO,IACpB9P,EAAO,IAAM8P,EAAO,IACpB9P,EAAO,IAAM8P,EAAO,IACpB9P,EAAO,IAAM8P,EAAO,IACpB9P,EAAO,IAAM8P,EAAO,IACb9P,GAnCE,CACL8P,EAAO,GACPA,EAAO,GACPA,EAAO,GACPA,EAAO,GACPA,EAAO,GACPA,EAAO,GACPA,EAAO,GACPA,EAAO,GACPA,EAAO,GACPA,EAAO,GACPA,EAAO,IACPA,EAAO,IACPA,EAAO,IACPA,EAAO,IACPA,EAAO,IACPA,EAAO,MAsCb2H,EAAQjF,gBAAkB,SAAUC,EAAQC,GAS1C,OAPAzS,QAAMC,OAAO4B,OAAOC,oBAAoB,MAAO2Q,EAAK,GACpDzS,QAAMC,OAAO4B,OAAO6Q,iBAAiB,MAAOD,EAAK,GAEjDzS,QAAMC,OAAO4B,OAAOC,oBAAoB,SAAU0Q,EAAQ,GAC1DxS,QAAMC,OAAO4B,OAAO6Q,iBAAiB,SAAUF,EAAQ,GAGvC,EAATA,EAAaC,GA8BtB+E,EAAQ7E,UAAY,SAAU9C,EAAQ9N,EAAOhC,GAE3CC,QAAMC,OAAOC,OAAO,SAAU2P,GAE9B7P,QAAMC,OAAO4B,OAAOC,oBAAoB,QAASC,EAAO,GACxD/B,QAAMC,OAAO4B,OAAO6Q,iBAAiB,QAAS3Q,EAAO,GAErD/B,QAAMC,OAAOC,OAAO,SAAUH,GAG9B,IAAI6S,EAAqB,EAAR7Q,EACbvC,EAAIqQ,EAAO+C,GACXnT,EAAIoQ,EAAO+C,EAAa,GACxBlT,EAAImQ,EAAO+C,EAAa,GACxBtC,EAAIT,EAAO+C,EAAa,GAM5B,OAJA7S,EAAOP,EAAIA,EACXO,EAAON,EAAIA,EACXM,EAAOL,EAAIA,EACXK,EAAOuQ,EAAIA,EACJvQ,GA6BTyX,EAAQ3E,UAAY,SAAUhD,EAAQ9N,EAAOlB,EAAWd,GAEtDC,QAAMC,OAAOC,OAAO,SAAU2P,GAE9B7P,QAAMC,OAAO4B,OAAOC,oBAAoB,QAASC,EAAO,GACxD/B,QAAMC,OAAO4B,OAAO6Q,iBAAiB,QAAS3Q,EAAO,GAErD/B,QAAMC,OAAOC,OAAO,YAAaW,GACjCb,QAAMC,OAAOC,OAAO,SAAUH,GAI9B,IAAI6S,EAAqB,EAAR7Q,EAKjB,OANAhC,EAASyX,EAAQ5W,MAAMiP,EAAQ9P,IAExB6S,GAAc/R,EAAUrB,EAC/BO,EAAO6S,EAAa,GAAK/R,EAAUpB,EACnCM,EAAO6S,EAAa,GAAK/R,EAAUnB,EACnCK,EAAO6S,EAAa,GAAK/R,EAAUyP,EAC5BvQ,GAYTyX,EAAQkE,eAAiB,SAAU7L,EAAQwI,EAAatY,GA2BtD,OAzBAC,QAAMC,OAAOC,OAAO,SAAU2P,GAC9B7P,QAAMC,OAAOC,OAAO,cAAemY,GACnCrY,QAAMC,OAAOC,OAAO,SAAUH,GAG9BA,EAAO,GAAK8P,EAAO,GACnB9P,EAAO,GAAK8P,EAAO,GACnB9P,EAAO,GAAK8P,EAAO,GACnB9P,EAAO,GAAK8P,EAAO,GAEnB9P,EAAO,GAAK8P,EAAO,GACnB9P,EAAO,GAAK8P,EAAO,GACnB9P,EAAO,GAAK8P,EAAO,GACnB9P,EAAO,GAAK8P,EAAO,GAEnB9P,EAAO,GAAK8P,EAAO,GACnB9P,EAAO,GAAK8P,EAAO,GACnB9P,EAAO,IAAM8P,EAAO,IACpB9P,EAAO,IAAM8P,EAAO,IAEpB9P,EAAO,IAAMsY,EAAY7Y,EACzBO,EAAO,IAAMsY,EAAY5Y,EACzBM,EAAO,IAAMsY,EAAY3Y,EACzBK,EAAO,IAAM8P,EAAO,IAEb9P,GAGT,IAAI4b,GAAe,IAAIpc,EAUvBiY,EAAQoE,SAAW,SAAU/L,EAAQ+B,EAAO7R,GAE1CC,QAAMC,OAAOC,OAAO,SAAU2P,GAC9B7P,QAAMC,OAAOC,OAAO,QAAS0R,GAC7B5R,QAAMC,OAAOC,OAAO,SAAUH,GAG9B,IAAI8b,EAAgBrE,EAAQvE,SAASpD,EAAQ8L,IACzCG,EAAWvc,EAAW8D,iBACxBuO,EACAiK,EACAF,IAEF,OAAOnE,EAAQ/D,gBAAgB5D,EAAQiM,EAAU/b,IA8BnDyX,EAAQ1E,OAAS,SAAUjD,EAAQ9N,EAAOhC,GAExCC,QAAMC,OAAOC,OAAO,SAAU2P,GAE9B7P,QAAMC,OAAO4B,OAAOC,oBAAoB,QAASC,EAAO,GACxD/B,QAAMC,OAAO4B,OAAO6Q,iBAAiB,QAAS3Q,EAAO,GAErD/B,QAAMC,OAAOC,OAAO,SAAUH,GAG9B,IAAIP,EAAIqQ,EAAO9N,GACXtC,EAAIoQ,EAAO9N,EAAQ,GACnBrC,EAAImQ,EAAO9N,EAAQ,GACnBuO,EAAIT,EAAO9N,EAAQ,IAMvB,OAJAhC,EAAOP,EAAIA,EACXO,EAAON,EAAIA,EACXM,EAAOL,EAAIA,EACXK,EAAOuQ,EAAIA,EACJvQ,GA6BTyX,EAAQzE,OAAS,SAAUlD,EAAQ9N,EAAOlB,EAAWd,GAgBnD,OAdAC,QAAMC,OAAOC,OAAO,SAAU2P,GAE9B7P,QAAMC,OAAO4B,OAAOC,oBAAoB,QAASC,EAAO,GACxD/B,QAAMC,OAAO4B,OAAO6Q,iBAAiB,QAAS3Q,EAAO,GAErD/B,QAAMC,OAAOC,OAAO,YAAaW,GACjCb,QAAMC,OAAOC,OAAO,SAAUH,IAG9BA,EAASyX,EAAQ5W,MAAMiP,EAAQ9P,IACxBgC,GAASlB,EAAUrB,EAC1BO,EAAOgC,EAAQ,GAAKlB,EAAUpB,EAC9BM,EAAOgC,EAAQ,GAAKlB,EAAUnB,EAC9BK,EAAOgC,EAAQ,IAAMlB,EAAUyP,EACxBvQ,GAGT,IAAIiT,GAAgB,IAAIzT,EASxBiY,EAAQvE,SAAW,SAAUpD,EAAQ9P,GAenC,OAbAC,QAAMC,OAAOC,OAAO,SAAU2P,GAC9B7P,QAAMC,OAAOC,OAAO,SAAUH,GAG9BA,EAAOP,EAAID,EAAWe,UACpBf,EAAWoB,aAAakP,EAAO,GAAIA,EAAO,GAAIA,EAAO,GAAImD,KAE3DjT,EAAON,EAAIF,EAAWe,UACpBf,EAAWoB,aAAakP,EAAO,GAAIA,EAAO,GAAIA,EAAO,GAAImD,KAE3DjT,EAAOL,EAAIH,EAAWe,UACpBf,EAAWoB,aAAakP,EAAO,GAAIA,EAAO,GAAIA,EAAO,IAAKmD,KAErDjT,GAGT,IAAImT,GAAe,IAAI3T,EAUvBiY,EAAQrE,gBAAkB,SAAUtD,GAElC,OADA2H,EAAQvE,SAASpD,EAAQqD,IAClB3T,EAAW0C,iBAAiBiR,KAWrCsE,EAAQpE,SAAW,SAAUvQ,EAAMC,EAAO/C,GAExCC,QAAMC,OAAOC,OAAO,OAAQ2C,GAC5B7C,QAAMC,OAAOC,OAAO,QAAS4C,GAC7B9C,QAAMC,OAAOC,OAAO,SAAUH,GAG9B,IAAIgc,EAAQlZ,EAAK,GACbmZ,EAAQnZ,EAAK,GACboZ,EAAQpZ,EAAK,GACbqZ,EAAQrZ,EAAK,GACbsZ,EAAQtZ,EAAK,GACbuZ,EAAQvZ,EAAK,GACbwZ,EAAQxZ,EAAK,GACbyZ,EAAQzZ,EAAK,GACb0Z,EAAQ1Z,EAAK,GACb2Z,EAAQ3Z,EAAK,GACb4Z,EAAS5Z,EAAK,IACd6Z,EAAS7Z,EAAK,IACd8Z,EAAS9Z,EAAK,IACd+Z,EAAS/Z,EAAK,IACdga,EAASha,EAAK,IACdia,EAASja,EAAK,IAEdka,EAASja,EAAM,GACfka,EAASla,EAAM,GACfma,EAASna,EAAM,GACfoa,EAASpa,EAAM,GACfqa,EAASra,EAAM,GACfsa,EAASta,EAAM,GACfua,EAASva,EAAM,GACfwa,EAASxa,EAAM,GACfya,EAASza,EAAM,GACf0a,EAAS1a,EAAM,GACf2a,EAAU3a,EAAM,IAChB4a,EAAU5a,EAAM,IAChB6a,EAAU7a,EAAM,IAChB8a,EAAU9a,EAAM,IAChB+a,EAAU/a,EAAM,IAChBgb,EAAUhb,EAAM,IAEhBiL,EACFgO,EAAQgB,EAASZ,EAAQa,EAAST,EAAQU,EAASN,EAASO,EAC1DhP,EACF8N,EAAQe,EAASX,EAAQY,EAASR,EAAQS,EAASL,EAASM,EAC1D7O,EACF4N,EAAQc,EAASV,EAAQW,EAASP,EAASQ,EAASJ,EAASK,EAC3DtF,EACFsE,EAAQa,EAAST,EAAQU,EAASN,EAASO,EAASH,EAASI,EAE3DlP,EACF+N,EAAQoB,EAAShB,EAAQiB,EAASb,EAAQc,EAASV,EAASW,EAC1DnP,EACF6N,EAAQmB,EAASf,EAAQgB,EAASZ,EAAQa,EAAST,EAASU,EAC1DhP,EACF2N,EAAQkB,EAASd,EAAQe,EAASX,EAASY,EAASR,EAASS,EAC3DzF,EACFqE,EAAQiB,EAASb,EAAQc,EAASV,EAASW,EAASP,EAASQ,EAE3DrP,EACF8N,EAAQwB,EAASpB,EAAQqB,EAASjB,EAAQkB,EAAUd,EAASe,EAC3DtP,EACF4N,EAAQuB,EAASnB,EAAQoB,EAAShB,EAAQiB,EAAUb,EAASc,EAC3DnP,EACF0N,EAAQsB,EAASlB,EAAQmB,EAASf,EAASgB,EAAUZ,EAASa,EAC5D5F,EACFoE,EAAQqB,EAASjB,EAAQkB,EAASd,EAASe,EAAUX,EAASY,EAE5DjG,EACFsE,EAAQ4B,EAAUxB,EAAQyB,EAAUrB,EAAQsB,EAAUlB,EAASmB,EAC7DpG,EACFsE,EAAQ2B,EAAUvB,EAAQwB,EAAUpB,EAAQqB,EAAUjB,EAASkB,EAC7DnG,EACFsE,EAAQ0B,EAAUtB,EAAQuB,EAAUnB,EAASoB,EAAUhB,EAASiB,EAC9D/F,EACFmE,EAAQyB,EAAUrB,EAAQsB,EAAUlB,EAASmB,EAAUf,EAASgB,EAkBlE,OAhBA/d,EAAO,GAAKgO,EACZhO,EAAO,GAAKmO,EACZnO,EAAO,GAAKsO,EACZtO,EAAO,GAAK6X,EACZ7X,EAAO,GAAKiO,EACZjO,EAAO,GAAKoO,EACZpO,EAAO,GAAKuO,EACZvO,EAAO,GAAK8X,EACZ9X,EAAO,GAAKkO,EACZlO,EAAO,GAAKqO,EACZrO,EAAO,IAAMwO,EACbxO,EAAO,IAAM+X,EACb/X,EAAO,IAAM0X,EACb1X,EAAO,IAAM2X,EACb3X,EAAO,IAAM4X,EACb5X,EAAO,IAAMgY,EACNhY,GAWTyX,EAAQlU,IAAM,SAAUT,EAAMC,EAAO/C,GAuBnC,OArBAC,QAAMC,OAAOC,OAAO,OAAQ2C,GAC5B7C,QAAMC,OAAOC,OAAO,QAAS4C,GAC7B9C,QAAMC,OAAOC,OAAO,SAAUH,GAG9BA,EAAO,GAAK8C,EAAK,GAAKC,EAAM,GAC5B/C,EAAO,GAAK8C,EAAK,GAAKC,EAAM,GAC5B/C,EAAO,GAAK8C,EAAK,GAAKC,EAAM,GAC5B/C,EAAO,GAAK8C,EAAK,GAAKC,EAAM,GAC5B/C,EAAO,GAAK8C,EAAK,GAAKC,EAAM,GAC5B/C,EAAO,GAAK8C,EAAK,GAAKC,EAAM,GAC5B/C,EAAO,GAAK8C,EAAK,GAAKC,EAAM,GAC5B/C,EAAO,GAAK8C,EAAK,GAAKC,EAAM,GAC5B/C,EAAO,GAAK8C,EAAK,GAAKC,EAAM,GAC5B/C,EAAO,GAAK8C,EAAK,GAAKC,EAAM,GAC5B/C,EAAO,IAAM8C,EAAK,IAAMC,EAAM,IAC9B/C,EAAO,IAAM8C,EAAK,IAAMC,EAAM,IAC9B/C,EAAO,IAAM8C,EAAK,IAAMC,EAAM,IAC9B/C,EAAO,IAAM8C,EAAK,IAAMC,EAAM,IAC9B/C,EAAO,IAAM8C,EAAK,IAAMC,EAAM,IAC9B/C,EAAO,IAAM8C,EAAK,IAAMC,EAAM,IACvB/C,GAWTyX,EAAQzU,SAAW,SAAUF,EAAMC,EAAO/C,GAuBxC,OArBAC,QAAMC,OAAOC,OAAO,OAAQ2C,GAC5B7C,QAAMC,OAAOC,OAAO,QAAS4C,GAC7B9C,QAAMC,OAAOC,OAAO,SAAUH,GAG9BA,EAAO,GAAK8C,EAAK,GAAKC,EAAM,GAC5B/C,EAAO,GAAK8C,EAAK,GAAKC,EAAM,GAC5B/C,EAAO,GAAK8C,EAAK,GAAKC,EAAM,GAC5B/C,EAAO,GAAK8C,EAAK,GAAKC,EAAM,GAC5B/C,EAAO,GAAK8C,EAAK,GAAKC,EAAM,GAC5B/C,EAAO,GAAK8C,EAAK,GAAKC,EAAM,GAC5B/C,EAAO,GAAK8C,EAAK,GAAKC,EAAM,GAC5B/C,EAAO,GAAK8C,EAAK,GAAKC,EAAM,GAC5B/C,EAAO,GAAK8C,EAAK,GAAKC,EAAM,GAC5B/C,EAAO,GAAK8C,EAAK,GAAKC,EAAM,GAC5B/C,EAAO,IAAM8C,EAAK,IAAMC,EAAM,IAC9B/C,EAAO,IAAM8C,EAAK,IAAMC,EAAM,IAC9B/C,EAAO,IAAM8C,EAAK,IAAMC,EAAM,IAC9B/C,EAAO,IAAM8C,EAAK,IAAMC,EAAM,IAC9B/C,EAAO,IAAM8C,EAAK,IAAMC,EAAM,IAC9B/C,EAAO,IAAM8C,EAAK,IAAMC,EAAM,IACvB/C,GAsBTyX,EAAQuG,uBAAyB,SAAUlb,EAAMC,EAAO/C,GAEtDC,QAAMC,OAAOC,OAAO,OAAQ2C,GAC5B7C,QAAMC,OAAOC,OAAO,QAAS4C,GAC7B9C,QAAMC,OAAOC,OAAO,SAAUH,GAG9B,IAAIgc,EAAQlZ,EAAK,GACbmZ,EAAQnZ,EAAK,GACboZ,EAAQpZ,EAAK,GACbsZ,EAAQtZ,EAAK,GACbuZ,EAAQvZ,EAAK,GACbwZ,EAAQxZ,EAAK,GACb0Z,EAAQ1Z,EAAK,GACb2Z,EAAQ3Z,EAAK,GACb4Z,EAAS5Z,EAAK,IACd8Z,EAAS9Z,EAAK,IACd+Z,EAAS/Z,EAAK,IACdga,EAASha,EAAK,IAEdka,EAASja,EAAM,GACfka,EAASla,EAAM,GACfma,EAASna,EAAM,GACfqa,EAASra,EAAM,GACfsa,EAASta,EAAM,GACfua,EAASva,EAAM,GACfya,EAASza,EAAM,GACf0a,EAAS1a,EAAM,GACf2a,EAAU3a,EAAM,IAChB6a,EAAU7a,EAAM,IAChB8a,EAAU9a,EAAM,IAChB+a,EAAU/a,EAAM,IAEhBiL,EAAcgO,EAAQgB,EAASZ,EAAQa,EAAST,EAAQU,EACxD/O,EAAc8N,EAAQe,EAASX,EAAQY,EAASR,EAAQS,EACxD5O,EAAc4N,EAAQc,EAASV,EAAQW,EAASP,EAASQ,EAEzDjP,EAAc+N,EAAQoB,EAAShB,EAAQiB,EAASb,EAAQc,EACxDlP,EAAc6N,EAAQmB,EAASf,EAAQgB,EAASZ,EAAQa,EACxD/O,EAAc2N,EAAQkB,EAASd,EAAQe,EAASX,EAASY,EAEzDpP,EAAc8N,EAAQwB,EAASpB,EAAQqB,EAASjB,EAAQkB,EACxDrP,EAAc4N,EAAQuB,EAASnB,EAAQoB,EAAShB,EAAQiB,EACxDlP,EAAc0N,EAAQsB,EAASlB,EAAQmB,EAASf,EAASgB,EAEzDhG,EACFsE,EAAQ4B,EAAUxB,EAAQyB,EAAUrB,EAAQsB,EAAUlB,EACpDjF,EACFsE,EAAQ2B,EAAUvB,EAAQwB,EAAUpB,EAAQqB,EAAUjB,EACpDjF,EACFsE,EAAQ0B,EAAUtB,EAAQuB,EAAUnB,EAASoB,EAAUhB,EAkBzD,OAhBA9c,EAAO,GAAKgO,EACZhO,EAAO,GAAKmO,EACZnO,EAAO,GAAKsO,EACZtO,EAAO,GAAK,EACZA,EAAO,GAAKiO,EACZjO,EAAO,GAAKoO,EACZpO,EAAO,GAAKuO,EACZvO,EAAO,GAAK,EACZA,EAAO,GAAKkO,EACZlO,EAAO,GAAKqO,EACZrO,EAAO,IAAMwO,EACbxO,EAAO,IAAM,EACbA,EAAO,IAAM0X,EACb1X,EAAO,IAAM2X,EACb3X,EAAO,IAAM4X,EACb5X,EAAO,IAAM,EACNA,GAiBTyX,EAAQwG,kBAAoB,SAAUnO,EAAQuI,EAAUrY,GAEtDC,QAAMC,OAAOC,OAAO,SAAU2P,GAC9B7P,QAAMC,OAAOC,OAAO,WAAYkY,GAChCpY,QAAMC,OAAOC,OAAO,SAAUH,GAG9B,IAAIgc,EAAQlM,EAAO,GACfmM,EAAQnM,EAAO,GACfoM,EAAQpM,EAAO,GACfsM,EAAQtM,EAAO,GACfuM,EAAQvM,EAAO,GACfwM,EAAQxM,EAAO,GACf0M,EAAQ1M,EAAO,GACf2M,EAAQ3M,EAAO,GACf4M,EAAS5M,EAAO,IAEhBkN,EAAS3E,EAAS,GAClB4E,EAAS5E,EAAS,GAClB6E,EAAS7E,EAAS,GAClB+E,EAAS/E,EAAS,GAClBgF,EAAShF,EAAS,GAClBiF,EAASjF,EAAS,GAClBmF,EAASnF,EAAS,GAClBoF,EAASpF,EAAS,GAClBqF,EAAUrF,EAAS,GAEnBrK,EAAcgO,EAAQgB,EAASZ,EAAQa,EAAST,EAAQU,EACxD/O,EAAc8N,EAAQe,EAASX,EAAQY,EAASR,EAAQS,EACxD5O,EAAc4N,EAAQc,EAASV,EAAQW,EAASP,EAASQ,EAEzDjP,EAAc+N,EAAQoB,EAAShB,EAAQiB,EAASb,EAAQc,EACxDlP,EAAc6N,EAAQmB,EAASf,EAAQgB,EAASZ,EAAQa,EACxD/O,EAAc2N,EAAQkB,EAASd,EAAQe,EAASX,EAASY,EAEzDpP,EAAc8N,EAAQwB,EAASpB,EAAQqB,EAASjB,EAAQkB,EACxDrP,EAAc4N,EAAQuB,EAASnB,EAAQoB,EAAShB,EAAQiB,EACxDlP,EAAc0N,EAAQsB,EAASlB,EAAQmB,EAASf,EAASgB,EAkB7D,OAhBA1d,EAAO,GAAKgO,EACZhO,EAAO,GAAKmO,EACZnO,EAAO,GAAKsO,EACZtO,EAAO,GAAK,EACZA,EAAO,GAAKiO,EACZjO,EAAO,GAAKoO,EACZpO,EAAO,GAAKuO,EACZvO,EAAO,GAAK,EACZA,EAAO,GAAKkO,EACZlO,EAAO,GAAKqO,EACZrO,EAAO,IAAMwO,EACbxO,EAAO,IAAM,EACbA,EAAO,IAAM8P,EAAO,IACpB9P,EAAO,IAAM8P,EAAO,IACpB9P,EAAO,IAAM8P,EAAO,IACpB9P,EAAO,IAAM8P,EAAO,IACb9P,GAiBTyX,EAAQyG,sBAAwB,SAAUpO,EAAQwI,EAAatY,GAE7DC,QAAMC,OAAOC,OAAO,SAAU2P,GAC9B7P,QAAMC,OAAOC,OAAO,cAAemY,GACnCrY,QAAMC,OAAOC,OAAO,SAAUH,GAG9B,IAAIP,EAAI6Y,EAAY7Y,EAChBC,EAAI4Y,EAAY5Y,EAChBC,EAAI2Y,EAAY3Y,EAEhBib,EAAKnb,EAAIqQ,EAAO,GAAKpQ,EAAIoQ,EAAO,GAAKnQ,EAAImQ,EAAO,GAAKA,EAAO,IAC5D+K,EAAKpb,EAAIqQ,EAAO,GAAKpQ,EAAIoQ,EAAO,GAAKnQ,EAAImQ,EAAO,GAAKA,EAAO,IAC5DgL,EAAKrb,EAAIqQ,EAAO,GAAKpQ,EAAIoQ,EAAO,GAAKnQ,EAAImQ,EAAO,IAAMA,EAAO,IAkBjE,OAhBA9P,EAAO,GAAK8P,EAAO,GACnB9P,EAAO,GAAK8P,EAAO,GACnB9P,EAAO,GAAK8P,EAAO,GACnB9P,EAAO,GAAK8P,EAAO,GACnB9P,EAAO,GAAK8P,EAAO,GACnB9P,EAAO,GAAK8P,EAAO,GACnB9P,EAAO,GAAK8P,EAAO,GACnB9P,EAAO,GAAK8P,EAAO,GACnB9P,EAAO,GAAK8P,EAAO,GACnB9P,EAAO,GAAK8P,EAAO,GACnB9P,EAAO,IAAM8P,EAAO,IACpB9P,EAAO,IAAM8P,EAAO,IACpB9P,EAAO,IAAM4a,EACb5a,EAAO,IAAM6a,EACb7a,EAAO,IAAM8a,EACb9a,EAAO,IAAM8P,EAAO,IACb9P,GAGT,IAAIme,GAAsB,IAAI3e,EAsB9BiY,EAAQ2G,uBAAyB,SAAUtO,EAAQ+B,EAAO7R,GAUxD,OARAC,QAAMC,OAAOC,OAAO,SAAU2P,GAC9B7P,QAAMC,OAAO4B,OAAO,QAAS+P,GAC7B5R,QAAMC,OAAOC,OAAO,SAAUH,GAG9Bme,GAAoB1e,EAAIoS,EACxBsM,GAAoBze,EAAImS,EACxBsM,GAAoBxe,EAAIkS,EACjB4F,EAAQ/D,gBAAgB5D,EAAQqO,GAAqBne,IAuB9DyX,EAAQ/D,gBAAkB,SAAU5D,EAAQ+B,EAAO7R,GAEjDC,QAAMC,OAAOC,OAAO,SAAU2P,GAC9B7P,QAAMC,OAAOC,OAAO,QAAS0R,GAC7B5R,QAAMC,OAAOC,OAAO,SAAUH,GAG9B,IAAIwY,EAAS3G,EAAMpS,EACfgZ,EAAS5G,EAAMnS,EACfgZ,EAAS7G,EAAMlS,EAGnB,OAAe,IAAX6Y,GAA6B,IAAXC,GAA6B,IAAXC,EAC/BjB,EAAQ5W,MAAMiP,EAAQ9P,IAG/BA,EAAO,GAAKwY,EAAS1I,EAAO,GAC5B9P,EAAO,GAAKwY,EAAS1I,EAAO,GAC5B9P,EAAO,GAAKwY,EAAS1I,EAAO,GAC5B9P,EAAO,GAAK,EACZA,EAAO,GAAKyY,EAAS3I,EAAO,GAC5B9P,EAAO,GAAKyY,EAAS3I,EAAO,GAC5B9P,EAAO,GAAKyY,EAAS3I,EAAO,GAC5B9P,EAAO,GAAK,EACZA,EAAO,GAAK0Y,EAAS5I,EAAO,GAC5B9P,EAAO,GAAK0Y,EAAS5I,EAAO,GAC5B9P,EAAO,IAAM0Y,EAAS5I,EAAO,IAC7B9P,EAAO,IAAM,EACbA,EAAO,IAAM8P,EAAO,IACpB9P,EAAO,IAAM8P,EAAO,IACpB9P,EAAO,IAAM8P,EAAO,IACpB9P,EAAO,IAAM,EACNA,IAWTyX,EAAQnE,iBAAmB,SAAUxD,EAAQhP,EAAWd,GAEtDC,QAAMC,OAAOC,OAAO,SAAU2P,GAC9B7P,QAAMC,OAAOC,OAAO,YAAaW,GACjCb,QAAMC,OAAOC,OAAO,SAAUH,GAG9B,IAAIuT,EAAKzS,EAAUrB,EACf+T,EAAK1S,EAAUpB,EACf+T,EAAK3S,EAAUnB,EACf0e,EAAKvd,EAAUyP,EAEf9Q,EAAIqQ,EAAO,GAAKyD,EAAKzD,EAAO,GAAK0D,EAAK1D,EAAO,GAAK2D,EAAK3D,EAAO,IAAMuO,EACpE3e,EAAIoQ,EAAO,GAAKyD,EAAKzD,EAAO,GAAK0D,EAAK1D,EAAO,GAAK2D,EAAK3D,EAAO,IAAMuO,EACpE1e,EAAImQ,EAAO,GAAKyD,EAAKzD,EAAO,GAAK0D,EAAK1D,EAAO,IAAM2D,EAAK3D,EAAO,IAAMuO,EACrE9N,EAAIT,EAAO,GAAKyD,EAAKzD,EAAO,GAAK0D,EAAK1D,EAAO,IAAM2D,EAAK3D,EAAO,IAAMuO,EAMzE,OAJAre,EAAOP,EAAIA,EACXO,EAAON,EAAIA,EACXM,EAAOL,EAAIA,EACXK,EAAOuQ,EAAIA,EACJvQ,GAmBTyX,EAAQ6G,wBAA0B,SAAUxO,EAAQhP,EAAWd,GAE7DC,QAAMC,OAAOC,OAAO,SAAU2P,GAC9B7P,QAAMC,OAAOC,OAAO,YAAaW,GACjCb,QAAMC,OAAOC,OAAO,SAAUH,GAG9B,IAAIuT,EAAKzS,EAAUrB,EACf+T,EAAK1S,EAAUpB,EACf+T,EAAK3S,EAAUnB,EAEfF,EAAIqQ,EAAO,GAAKyD,EAAKzD,EAAO,GAAK0D,EAAK1D,EAAO,GAAK2D,EAClD/T,EAAIoQ,EAAO,GAAKyD,EAAKzD,EAAO,GAAK0D,EAAK1D,EAAO,GAAK2D,EAClD9T,EAAImQ,EAAO,GAAKyD,EAAKzD,EAAO,GAAK0D,EAAK1D,EAAO,IAAM2D,EAKvD,OAHAzT,EAAOP,EAAIA,EACXO,EAAON,EAAIA,EACXM,EAAOL,EAAIA,EACJK,GAgBTyX,EAAQ8G,gBAAkB,SAAUzO,EAAQhP,EAAWd,GAErDC,QAAMC,OAAOC,OAAO,SAAU2P,GAC9B7P,QAAMC,OAAOC,OAAO,YAAaW,GACjCb,QAAMC,OAAOC,OAAO,SAAUH,GAG9B,IAAIuT,EAAKzS,EAAUrB,EACf+T,EAAK1S,EAAUpB,EACf+T,EAAK3S,EAAUnB,EAEfF,EAAIqQ,EAAO,GAAKyD,EAAKzD,EAAO,GAAK0D,EAAK1D,EAAO,GAAK2D,EAAK3D,EAAO,IAC9DpQ,EAAIoQ,EAAO,GAAKyD,EAAKzD,EAAO,GAAK0D,EAAK1D,EAAO,GAAK2D,EAAK3D,EAAO,IAC9DnQ,EAAImQ,EAAO,GAAKyD,EAAKzD,EAAO,GAAK0D,EAAK1D,EAAO,IAAM2D,EAAK3D,EAAO,IAKnE,OAHA9P,EAAOP,EAAIA,EACXO,EAAON,EAAIA,EACXM,EAAOL,EAAIA,EACJK,GA0BTyX,EAAQjU,iBAAmB,SAAUsM,EAAQrM,EAAQzD,GAuBnD,OArBAC,QAAMC,OAAOC,OAAO,SAAU2P,GAC9B7P,QAAMC,OAAO4B,OAAO,SAAU2B,GAC9BxD,QAAMC,OAAOC,OAAO,SAAUH,GAG9BA,EAAO,GAAK8P,EAAO,GAAKrM,EACxBzD,EAAO,GAAK8P,EAAO,GAAKrM,EACxBzD,EAAO,GAAK8P,EAAO,GAAKrM,EACxBzD,EAAO,GAAK8P,EAAO,GAAKrM,EACxBzD,EAAO,GAAK8P,EAAO,GAAKrM,EACxBzD,EAAO,GAAK8P,EAAO,GAAKrM,EACxBzD,EAAO,GAAK8P,EAAO,GAAKrM,EACxBzD,EAAO,GAAK8P,EAAO,GAAKrM,EACxBzD,EAAO,GAAK8P,EAAO,GAAKrM,EACxBzD,EAAO,GAAK8P,EAAO,GAAKrM,EACxBzD,EAAO,IAAM8P,EAAO,IAAMrM,EAC1BzD,EAAO,IAAM8P,EAAO,IAAMrM,EAC1BzD,EAAO,IAAM8P,EAAO,IAAMrM,EAC1BzD,EAAO,IAAM8P,EAAO,IAAMrM,EAC1BzD,EAAO,IAAM8P,EAAO,IAAMrM,EAC1BzD,EAAO,IAAM8P,EAAO,IAAMrM,EACnBzD,GAyBTyX,EAAQ9T,OAAS,SAAUmM,EAAQ9P,GAsBjC,OApBAC,QAAMC,OAAOC,OAAO,SAAU2P,GAC9B7P,QAAMC,OAAOC,OAAO,SAAUH,GAG9BA,EAAO,IAAM8P,EAAO,GACpB9P,EAAO,IAAM8P,EAAO,GACpB9P,EAAO,IAAM8P,EAAO,GACpB9P,EAAO,IAAM8P,EAAO,GACpB9P,EAAO,IAAM8P,EAAO,GACpB9P,EAAO,IAAM8P,EAAO,GACpB9P,EAAO,IAAM8P,EAAO,GACpB9P,EAAO,IAAM8P,EAAO,GACpB9P,EAAO,IAAM8P,EAAO,GACpB9P,EAAO,IAAM8P,EAAO,GACpB9P,EAAO,KAAO8P,EAAO,IACrB9P,EAAO,KAAO8P,EAAO,IACrB9P,EAAO,KAAO8P,EAAO,IACrB9P,EAAO,KAAO8P,EAAO,IACrB9P,EAAO,KAAO8P,EAAO,IACrB9P,EAAO,KAAO8P,EAAO,IACd9P,GAyBTyX,EAAQ9D,UAAY,SAAU7D,EAAQ9P,GAEpCC,QAAMC,OAAOC,OAAO,SAAU2P,GAC9B7P,QAAMC,OAAOC,OAAO,SAAUH,GAG9B,IAAIwe,EAAU1O,EAAO,GACjB2O,EAAU3O,EAAO,GACjB4O,EAAU5O,EAAO,GACjB6O,EAAU7O,EAAO,GACjB8O,EAAU9O,EAAO,GACjB+O,EAAW/O,EAAO,IAkBtB,OAhBA9P,EAAO,GAAK8P,EAAO,GACnB9P,EAAO,GAAK8P,EAAO,GACnB9P,EAAO,GAAK8P,EAAO,GACnB9P,EAAO,GAAK8P,EAAO,IACnB9P,EAAO,GAAKwe,EACZxe,EAAO,GAAK8P,EAAO,GACnB9P,EAAO,GAAK8P,EAAO,GACnB9P,EAAO,GAAK8P,EAAO,IACnB9P,EAAO,GAAKye,EACZze,EAAO,GAAK2e,EACZ3e,EAAO,IAAM8P,EAAO,IACpB9P,EAAO,IAAM8P,EAAO,IACpB9P,EAAO,IAAM0e,EACb1e,EAAO,IAAM4e,EACb5e,EAAO,IAAM6e,EACb7e,EAAO,IAAM8P,EAAO,IACb9P,GAUTyX,EAAQ7T,IAAM,SAAUkM,EAAQ9P,GAuB9B,OArBAC,QAAMC,OAAOC,OAAO,SAAU2P,GAC9B7P,QAAMC,OAAOC,OAAO,SAAUH,GAG9BA,EAAO,GAAKS,KAAKmD,IAAIkM,EAAO,IAC5B9P,EAAO,GAAKS,KAAKmD,IAAIkM,EAAO,IAC5B9P,EAAO,GAAKS,KAAKmD,IAAIkM,EAAO,IAC5B9P,EAAO,GAAKS,KAAKmD,IAAIkM,EAAO,IAC5B9P,EAAO,GAAKS,KAAKmD,IAAIkM,EAAO,IAC5B9P,EAAO,GAAKS,KAAKmD,IAAIkM,EAAO,IAC5B9P,EAAO,GAAKS,KAAKmD,IAAIkM,EAAO,IAC5B9P,EAAO,GAAKS,KAAKmD,IAAIkM,EAAO,IAC5B9P,EAAO,GAAKS,KAAKmD,IAAIkM,EAAO,IAC5B9P,EAAO,GAAKS,KAAKmD,IAAIkM,EAAO,IAC5B9P,EAAO,IAAMS,KAAKmD,IAAIkM,EAAO,KAC7B9P,EAAO,IAAMS,KAAKmD,IAAIkM,EAAO,KAC7B9P,EAAO,IAAMS,KAAKmD,IAAIkM,EAAO,KAC7B9P,EAAO,IAAMS,KAAKmD,IAAIkM,EAAO,KAC7B9P,EAAO,IAAMS,KAAKmD,IAAIkM,EAAO,KAC7B9P,EAAO,IAAMS,KAAKmD,IAAIkM,EAAO,KAEtB9P,GAgCTyX,EAAQvS,OAAS,SAAUpC,EAAMC,GAK/B,OACED,IAASC,GACR3C,UAAQ0C,IACP1C,UAAQ2C,IAERD,EAAK,MAAQC,EAAM,KACnBD,EAAK,MAAQC,EAAM,KACnBD,EAAK,MAAQC,EAAM,KAEnBD,EAAK,KAAOC,EAAM,IAClBD,EAAK,KAAOC,EAAM,IAClBD,EAAK,KAAOC,EAAM,IAClBD,EAAK,KAAOC,EAAM,IAClBD,EAAK,KAAOC,EAAM,IAClBD,EAAK,KAAOC,EAAM,IAClBD,EAAK,KAAOC,EAAM,IAClBD,EAAK,KAAOC,EAAM,IAClBD,EAAK,MAAQC,EAAM,KAEnBD,EAAK,KAAOC,EAAM,IAClBD,EAAK,KAAOC,EAAM,IAClBD,EAAK,MAAQC,EAAM,KACnBD,EAAK,MAAQC,EAAM,KAmCzB0U,EAAQpS,cAAgB,SAAUvC,EAAMC,EAAOsI,GAG7C,OAFAA,EAAUxL,eAAawL,EAAS,GAG9BvI,IAASC,GACR3C,UAAQ0C,IACP1C,UAAQ2C,IACRtC,KAAKmD,IAAId,EAAK,GAAKC,EAAM,KAAOsI,GAChC5K,KAAKmD,IAAId,EAAK,GAAKC,EAAM,KAAOsI,GAChC5K,KAAKmD,IAAId,EAAK,GAAKC,EAAM,KAAOsI,GAChC5K,KAAKmD,IAAId,EAAK,GAAKC,EAAM,KAAOsI,GAChC5K,KAAKmD,IAAId,EAAK,GAAKC,EAAM,KAAOsI,GAChC5K,KAAKmD,IAAId,EAAK,GAAKC,EAAM,KAAOsI,GAChC5K,KAAKmD,IAAId,EAAK,GAAKC,EAAM,KAAOsI,GAChC5K,KAAKmD,IAAId,EAAK,GAAKC,EAAM,KAAOsI,GAChC5K,KAAKmD,IAAId,EAAK,GAAKC,EAAM,KAAOsI,GAChC5K,KAAKmD,IAAId,EAAK,GAAKC,EAAM,KAAOsI,GAChC5K,KAAKmD,IAAId,EAAK,IAAMC,EAAM,MAAQsI,GAClC5K,KAAKmD,IAAId,EAAK,IAAMC,EAAM,MAAQsI,GAClC5K,KAAKmD,IAAId,EAAK,IAAMC,EAAM,MAAQsI,GAClC5K,KAAKmD,IAAId,EAAK,IAAMC,EAAM,MAAQsI,GAClC5K,KAAKmD,IAAId,EAAK,IAAMC,EAAM,MAAQsI,GAClC5K,KAAKmD,IAAId,EAAK,IAAMC,EAAM,MAAQsI,GAWxCoM,EAAQqH,eAAiB,SAAUhP,EAAQ9P,GASzC,OAPAC,QAAMC,OAAOC,OAAO,SAAU2P,GAC9B7P,QAAMC,OAAOC,OAAO,SAAUH,GAG9BA,EAAOP,EAAIqQ,EAAO,IAClB9P,EAAON,EAAIoQ,EAAO,IAClB9P,EAAOL,EAAImQ,EAAO,IACX9P,GAyBTyX,EAAQsH,WAAa,SAAUjP,EAAQ9P,GAerC,OAbAC,QAAMC,OAAOC,OAAO,SAAU2P,GAC9B7P,QAAMC,OAAOC,OAAO,SAAUH,GAG9BA,EAAO,GAAK8P,EAAO,GACnB9P,EAAO,GAAK8P,EAAO,GACnB9P,EAAO,GAAK8P,EAAO,GACnB9P,EAAO,GAAK8P,EAAO,GACnB9P,EAAO,GAAK8P,EAAO,GACnB9P,EAAO,GAAK8P,EAAO,GACnB9P,EAAO,GAAK8P,EAAO,GACnB9P,EAAO,GAAK8P,EAAO,GACnB9P,EAAO,GAAK8P,EAAO,IACZ9P,GAGT,IAAIgf,GAAyB,IAAIjR,EAC7BkR,GAAqB,IAAIlR,EACzBmR,GAAmB,IAAIlJ,EACvBmJ,GAA2B,IAAInJ,EAAW,EAAK,EAAK,EAAK,GAc7DyB,EAAQ3B,QAAU,SAAUhG,EAAQ9P,GAElCC,QAAMC,OAAOC,OAAO,SAAU2P,GAC9B7P,QAAMC,OAAOC,OAAO,SAAUH,GAM9B,IAAIof,EAAOtP,EAAO,GACduP,EAAOvP,EAAO,GACdwP,EAAOxP,EAAO,GACdyP,EAAOzP,EAAO,IACd0P,EAAO1P,EAAO,GACd2P,EAAO3P,EAAO,GACd4P,EAAO5P,EAAO,GACd6P,EAAO7P,EAAO,IACd8P,EAAO9P,EAAO,GACd+P,EAAO/P,EAAO,GACdgQ,EAAQhQ,EAAO,IACfiQ,EAAQjQ,EAAO,IACfkQ,EAAQlQ,EAAO,GACfmQ,EAAQnQ,EAAO,GACfoQ,EAAQpQ,EAAO,IACfqQ,EAAQrQ,EAAO,IAGfsQ,EAAON,EAAQK,EACfE,EAAON,EAAQG,EACfI,EAAOT,EAAOM,EACdI,EAAOR,EAAQE,EACfO,EAAOX,EAAOK,EACdO,EAAOX,EAAQG,EACfS,EAAOd,EAAOO,EACdQ,EAAOZ,EAAQC,EACfY,EAAOhB,EAAOM,EACdW,EAAOf,EAAQE,EACfc,EAAQlB,EAAOK,EACfc,EAAQlB,EAAOG,EAGfgB,EACFZ,EAAOX,EACPc,EAAOb,EACPc,EAAOb,GACNU,EAAOZ,EAAOa,EAAOZ,EAAOe,EAAOd,GAClCsB,EACFZ,EAAOb,EACPkB,EAAOhB,EACPmB,EAAOlB,GACNS,EAAOZ,EAAOmB,EAAOjB,EAAOkB,EAAOjB,GAClCuB,EACFZ,EAAOd,EACPmB,EAAOlB,EACPqB,EAAQnB,GACPY,EAAOf,EAAOkB,EAAOjB,EAAOsB,EAAQpB,GACnCwB,EACFV,EAAOjB,EACPoB,EAAOnB,EACPsB,EAAQrB,GACPc,EAAOhB,EAAOqB,EAAOpB,EAAOqB,EAAQpB,GACnC0B,EACFf,EAAOhB,EACPiB,EAAOhB,EACPmB,EAAOlB,GACNa,EAAOf,EAAOkB,EAAOjB,EAAOkB,EAAOjB,GAClC8B,EACFjB,EAAOhB,EACPuB,EAAOrB,EACPsB,EAAOrB,GACNc,EAAOjB,EAAOsB,EAAOpB,EAAOuB,EAAOtB,GAClC+B,EACFf,EAAOnB,EACPsB,EAAOrB,EACP0B,EAAQxB,GACPe,EAAOlB,EAAOuB,EAAOtB,EAAOyB,EAAQvB,GACnCgC,EACFf,EAAOpB,EACPyB,EAAOxB,EACPyB,EAAQxB,GACPmB,EAAOrB,EAAOwB,EAAOvB,EAAO0B,EAAQzB,GAiBnCkC,GAdJpB,EAAOd,EAAOK,GAeLM,GAZTM,EAAOhB,EAAOE,GAaLS,GAZTM,EAAOnB,EAAOK,GAaLS,IAhBTE,EAAOd,EAAOG,GAiBJO,GAhBVK,EAAOjB,EAAOM,GAgBWO,GAbzBO,EAAOnB,EAAOG,GAa0BU,GACpCsB,EACFpB,EAAOL,GAdTU,EAAOtB,EAAOO,GAeLO,GAZTW,EAAOvB,EAAOE,GAaLW,GACNC,EAAOJ,GAhBVW,EAAOpB,EAAOC,GAgBWU,GAfzBU,EAAOxB,EAAOM,GAe0BS,GACpCuB,EACFpB,EAAON,EACPW,EAAOV,GAhBTa,EAAQ1B,EAAOK,GAiBLU,GACPI,EAAOP,EAAQU,EAAOT,GAjBzBc,EAAQ1B,EAAOG,GAiB0BW,GACrCwB,EACFlB,EAAOT,EACPY,EAAOX,EACPc,EAAQb,GACPM,EAAOR,EAAQa,EAAOZ,EAAQa,EAAQZ,GACrC0B,EACFtB,EAAOR,EACPW,EAAOV,EACPM,EAAOR,GACNW,EAAOT,EAAQK,EAAOP,EAAOU,EAAOT,GACnC+B,EACFjB,EAAOb,EACPK,EAAOR,EACPe,EAAOb,GACNY,EAAOZ,EAAQe,EAAOd,EAAQM,EAAOT,GACpCkC,EACFpB,EAAOb,EACPkB,EAAQhB,EACRQ,EAAOX,GACNkB,EAAQf,EAAQO,EAAOV,EAAOe,EAAOd,GACpCkC,EACFjB,EAAQhB,EACRU,EAAOZ,EACPiB,EAAOhB,GACNe,EAAOf,EAAOkB,EAAQjB,EAAQW,EAAOb,GAGpCoC,EAAM5C,EAAO4B,EAAO3B,EAAO4B,EAAO3B,EAAO4B,EAAO3B,EAAO4B,EAE3D,GAAI1gB,KAAKmD,IAAIoe,GAAOxc,aAAWyc,UAAW,CAGxC,GACElU,EAAQ1I,cACNoS,EAAQsH,WAAWjP,EAAQkP,IAC3BC,GACAzZ,aAAW0c,WAEblM,EAAW9Q,OACTuS,EAAQ1E,OAAOjD,EAAQ,EAAGoP,IAC1BC,IAmBF,OAhBAnf,EAAO,GAAK,EACZA,EAAO,GAAK,EACZA,EAAO,GAAK,EACZA,EAAO,GAAK,EACZA,EAAO,GAAK,EACZA,EAAO,GAAK,EACZA,EAAO,GAAK,EACZA,EAAO,GAAK,EACZA,EAAO,GAAK,EACZA,EAAO,GAAK,EACZA,EAAO,IAAM,EACbA,EAAO,IAAM,EACbA,EAAO,KAAO8P,EAAO,IACrB9P,EAAO,KAAO8P,EAAO,IACrB9P,EAAO,KAAO8P,EAAO,IACrB9P,EAAO,IAAM,EACNA,EAGT,MAAM,IAAImiB,eACR,6DAuBJ,OAlBAH,EAAM,EAAMA,EAEZhiB,EAAO,GAAKghB,EAAOgB,EACnBhiB,EAAO,GAAKihB,EAAOe,EACnBhiB,EAAO,GAAKkhB,EAAOc,EACnBhiB,EAAO,GAAKmhB,EAAOa,EACnBhiB,EAAO,GAAKohB,EAAOY,EACnBhiB,EAAO,GAAKqhB,EAAOW,EACnBhiB,EAAO,GAAKshB,EAAOU,EACnBhiB,EAAO,GAAKuhB,EAAOS,EACnBhiB,EAAO,GAAKwhB,EAAOQ,EACnBhiB,EAAO,GAAKyhB,EAAOO,EACnBhiB,EAAO,IAAM0hB,EAAQM,EACrBhiB,EAAO,IAAM2hB,EAAQK,EACrBhiB,EAAO,IAAM4hB,EAAQI,EACrBhiB,EAAO,IAAM6hB,EAAQG,EACrBhiB,EAAO,IAAM8hB,EAAQE,EACrBhiB,EAAO,IAAM+hB,EAAQC,EACdhiB,GAgBTyX,EAAQ2K,sBAAwB,SAAUtS,EAAQ9P,GAEhDC,QAAMC,OAAOC,OAAO,SAAU2P,GAC9B7P,QAAMC,OAAOC,OAAO,SAAUH,GAS9B,IAAIqiB,EAAUvS,EAAO,GACjB0O,EAAU1O,EAAO,GACjB2O,EAAU3O,EAAO,GACjBwS,EAAUxS,EAAO,GACjByS,EAAUzS,EAAO,GACjB6O,EAAU7O,EAAO,GACjB0S,EAAU1S,EAAO,GACjB2S,EAAU3S,EAAO,GACjB4S,EAAW5S,EAAO,IAElByD,EAAKzD,EAAO,IACZ0D,EAAK1D,EAAO,IACZ2D,EAAK3D,EAAO,IAEZrQ,GAAK4iB,EAAU9O,EAAKiL,EAAUhL,EAAKiL,EAAUhL,EAC7C/T,GAAK4iB,EAAU/O,EAAKgP,EAAU/O,EAAKmL,EAAUlL,EAC7C9T,GAAK6iB,EAAUjP,EAAKkP,EAAUjP,EAAKkP,EAAWjP,EAkBlD,OAhBAzT,EAAO,GAAKqiB,EACZriB,EAAO,GAAKsiB,EACZtiB,EAAO,GAAKwiB,EACZxiB,EAAO,GAAK,EACZA,EAAO,GAAKwe,EACZxe,EAAO,GAAKuiB,EACZviB,EAAO,GAAKyiB,EACZziB,EAAO,GAAK,EACZA,EAAO,GAAKye,EACZze,EAAO,GAAK2e,EACZ3e,EAAO,IAAM0iB,EACb1iB,EAAO,IAAM,EACbA,EAAO,IAAMP,EACbO,EAAO,IAAMN,EACbM,EAAO,IAAML,EACbK,EAAO,IAAM,EACNA,GAGT,IAAI+V,GAAyB,IAAI0B,ECtkFjC,SAASkL,GAAU/T,EAAMI,EAAOF,EAAMI,GAOpCtP,KAAKgP,KAAO/O,eAAa+O,EAAM,GAQ/BhP,KAAKoP,MAAQnP,eAAamP,EAAO,GAQjCpP,KAAKkP,KAAOjP,eAAaiP,EAAM,GAQ/BlP,KAAKsP,MAAQrP,eAAaqP,EAAO,GDgjFnCuI,EAAQxB,iBAAmB,SAAUnG,EAAQ9P,GAM3C,OAJAC,QAAMC,OAAOC,OAAO,SAAU2P,GAC9B7P,QAAMC,OAAOC,OAAO,SAAUH,GAGvByX,EAAQ3B,QACb2B,EAAQ9D,UAAU7D,EAAQiG,IAC1B/V,IAUJyX,EAAQ7C,SAAWzN,OAAOC,OACxB,IAAIqQ,EACF,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,IAUJA,EAAQvQ,KAAOC,OAAOC,OACpB,IAAIqQ,EACF,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,IAUJA,EAAQvB,YAAc,EAQtBuB,EAAQtB,YAAc,EAQtBsB,EAAQrB,YAAc,EAQtBqB,EAAQmL,YAAc,EAQtBnL,EAAQpB,YAAc,EAQtBoB,EAAQnB,YAAc,EAQtBmB,EAAQlB,YAAc,EAQtBkB,EAAQoL,YAAc,EAQtBpL,EAAQjB,YAAc,EAQtBiB,EAAQhB,YAAc,EAQtBgB,EAAQf,YAAc,GAQtBe,EAAQqL,YAAc,GAQtBrL,EAAQsL,YAAc,GAQtBtL,EAAQuL,YAAc,GAQtBvL,EAAQwL,YAAc,GAQtBxL,EAAQyL,YAAc,GAEtB/b,OAAOmE,iBAAiBmM,EAAQnQ,UAAW,CAOzC/F,OAAQ,CACNiK,IAAK,WACH,OAAOiM,EAAQzW,iBAWrByW,EAAQnQ,UAAUzG,MAAQ,SAAUb,GAClC,OAAOyX,EAAQ5W,MAAMjB,KAAMI,IAU7ByX,EAAQnQ,UAAUpC,OAAS,SAAUnC,GACnC,OAAO0U,EAAQvS,OAAOtF,KAAMmD,IAM9B0U,EAAQtS,YAAc,SAAU2K,EAAQ3O,EAAOiE,GAC7C,OACE0K,EAAO,KAAO3O,EAAMiE,IACpB0K,EAAO,KAAO3O,EAAMiE,EAAS,IAC7B0K,EAAO,KAAO3O,EAAMiE,EAAS,IAC7B0K,EAAO,KAAO3O,EAAMiE,EAAS,IAC7B0K,EAAO,KAAO3O,EAAMiE,EAAS,IAC7B0K,EAAO,KAAO3O,EAAMiE,EAAS,IAC7B0K,EAAO,KAAO3O,EAAMiE,EAAS,IAC7B0K,EAAO,KAAO3O,EAAMiE,EAAS,IAC7B0K,EAAO,KAAO3O,EAAMiE,EAAS,IAC7B0K,EAAO,KAAO3O,EAAMiE,EAAS,IAC7B0K,EAAO,MAAQ3O,EAAMiE,EAAS,KAC9B0K,EAAO,MAAQ3O,EAAMiE,EAAS,KAC9B0K,EAAO,MAAQ3O,EAAMiE,EAAS,KAC9B0K,EAAO,MAAQ3O,EAAMiE,EAAS,KAC9B0K,EAAO,MAAQ3O,EAAMiE,EAAS,KAC9B0K,EAAO,MAAQ3O,EAAMiE,EAAS,KAalCqS,EAAQnQ,UAAUjC,cAAgB,SAAUtC,EAAOsI,GACjD,OAAOoM,EAAQpS,cAAczF,KAAMmD,EAAOsI,IAS5CoM,EAAQnQ,UAAUC,SAAW,WAC3B,MACE,IACA3H,KAAK,GACL,KACAA,KAAK,GACL,KACAA,KAAK,GACL,KACAA,KAAK,IAPL,OAUAA,KAAK,GACL,KACAA,KAAK,GACL,KACAA,KAAK,GACL,KACAA,KAAK,IAhBL,OAmBAA,KAAK,GACL,KACAA,KAAK,GACL,KACAA,KAAK,IACL,KACAA,KAAK,IAzBL,OA4BAA,KAAK,GACL,KACAA,KAAK,GACL,KACAA,KAAK,IACL,KACAA,KAAK,IACL,KCl2FJuH,OAAOmE,iBAAiBqX,GAAUrb,UAAW,CAO3CgU,MAAO,CACL9P,IAAK,WACH,OAAOmX,GAAUQ,aAAavjB,QAUlCuG,OAAQ,CACNqF,IAAK,WACH,OAAOmX,GAAUS,cAAcxjB,UASrC+iB,GAAU3hB,aAAe,EAWzB2hB,GAAU1hB,KAAO,SAAUC,EAAOC,EAAOC,GAavC,OAXAnB,QAAMC,OAAOC,OAAO,QAASe,GAC7BjB,QAAMG,QAAQ,QAASe,GAGvBC,EAAgBvB,eAAauB,EAAe,GAE5CD,EAAMC,KAAmBF,EAAM0N,KAC/BzN,EAAMC,KAAmBF,EAAM8N,MAC/B7N,EAAMC,KAAmBF,EAAM4N,KAC/B3N,EAAMC,GAAiBF,EAAMgO,MAEtB/N,GAWTwhB,GAAUthB,OAAS,SAAUF,EAAOC,EAAepB,GAejD,OAbAC,QAAMG,QAAQ,QAASe,GAGvBC,EAAgBvB,eAAauB,EAAe,GAEvChB,UAAQJ,KACXA,EAAS,IAAI2iB,IAGf3iB,EAAO4O,KAAOzN,EAAMC,KACpBpB,EAAOgP,MAAQ7N,EAAMC,KACrBpB,EAAO8O,KAAO3N,EAAMC,KACpBpB,EAAOkP,MAAQ/N,EAAMC,GACdpB,GAQT2iB,GAAUQ,aAAe,SAAUzU,GAEjCzO,QAAMC,OAAOC,OAAO,YAAauO,GAEjC,IAAII,EAAOJ,EAAUI,KACjBF,EAAOF,EAAUE,KAIrB,OAHIE,EAAOF,IACTE,GAAQtJ,aAAW2J,QAEdL,EAAOF,GAQhB+T,GAAUS,cAAgB,SAAU1U,GAIlC,OAFAzO,QAAMC,OAAOC,OAAO,YAAauO,GAE1BA,EAAUQ,MAAQR,EAAUM,OAgBrC2T,GAAU3c,YAAc,SAAU4I,EAAMI,EAAOF,EAAMI,EAAOlP,GAM1D,OALA4O,EAAOpJ,aAAWa,UAAUxG,eAAa+O,EAAM,IAC/CI,EAAQxJ,aAAWa,UAAUxG,eAAamP,EAAO,IACjDF,EAAOtJ,aAAWa,UAAUxG,eAAaiP,EAAM,IAC/CI,EAAQ1J,aAAWa,UAAUxG,eAAaqP,EAAO,IAE5C9O,UAAQJ,IAIbA,EAAO4O,KAAOA,EACd5O,EAAOgP,MAAQA,EACfhP,EAAO8O,KAAOA,EACd9O,EAAOkP,MAAQA,EAERlP,GARE,IAAI2iB,GAAU/T,EAAMI,EAAOF,EAAMI,IAwB5CyT,GAAUrc,YAAc,SAAUsI,EAAMI,EAAOF,EAAMI,EAAOlP,GAC1D,OAAKI,UAAQJ,IAIbA,EAAO4O,KAAO/O,eAAa+O,EAAM,GACjC5O,EAAOgP,MAAQnP,eAAamP,EAAO,GACnChP,EAAO8O,KAAOjP,eAAaiP,EAAM,GACjC9O,EAAOkP,MAAQrP,eAAaqP,EAAO,GAE5BlP,GARE,IAAI2iB,GAAU/T,EAAMI,EAAOF,EAAMI,IAkB5CyT,GAAUU,sBAAwB,SAAU3W,EAAe1M,GAEzDC,QAAMG,QAAQ,gBAAiBsM,GAU/B,IAPA,IAAIkC,EAAO0U,OAAOC,UACdzU,GAAQwU,OAAOC,UACfC,EAAcF,OAAOC,UACrBE,GAAeH,OAAOC,UACtBvU,EAAQsU,OAAOC,UACfrU,GAASoU,OAAOC,UAEX3hB,EAAI,EAAG8hB,EAAMhX,EAAcnL,OAAQK,EAAI8hB,EAAK9hB,IAAK,CACxD,IAAIqL,EAAWP,EAAc9K,GAC7BgN,EAAOnO,KAAK4B,IAAIuM,EAAM3B,EAAShH,WAC/B6I,EAAOrO,KAAK0B,IAAI2M,EAAM7B,EAAShH,WAC/B+I,EAAQvO,KAAK4B,IAAI2M,EAAO/B,EAAS/G,UACjCgJ,EAAQzO,KAAK0B,IAAI+M,EAAOjC,EAAS/G,UAEjC,IAAIyd,EACF1W,EAAShH,WAAa,EAClBgH,EAAShH,UACTgH,EAAShH,UAAYT,aAAW2J,OACtCqU,EAAc/iB,KAAK4B,IAAImhB,EAAaG,GACpCF,EAAchjB,KAAK0B,IAAIshB,EAAaE,GAetC,OAZI7U,EAAOF,EAAO6U,EAAcD,IAC9B5U,EAAO4U,GACP1U,EAAO2U,GAEIje,aAAW+U,KACpBzL,GAActJ,aAAW2J,QAEvBP,EAAOpJ,aAAW+U,KACpB3L,GAAcpJ,aAAW2J,SAIxB/O,UAAQJ,IAIbA,EAAO4O,KAAOA,EACd5O,EAAOgP,MAAQA,EACfhP,EAAO8O,KAAOA,EACd9O,EAAOkP,MAAQA,EACRlP,GAPE,IAAI2iB,GAAU/T,EAAMI,EAAOF,EAAMI,IAkB5CyT,GAAUiB,mBAAqB,SAAU/W,EAAYzG,EAAWpG,GAE9DC,QAAMG,QAAQ,aAAcyM,GAE5BzG,EAAYvG,eAAauG,EAAWwE,EAAUiB,OAS9C,IAPA,IAAI+C,EAAO0U,OAAOC,UACdzU,GAAQwU,OAAOC,UACfC,EAAcF,OAAOC,UACrBE,GAAeH,OAAOC,UACtBvU,EAAQsU,OAAOC,UACfrU,GAASoU,OAAOC,UAEX3hB,EAAI,EAAG8hB,EAAM7W,EAAWtL,OAAQK,EAAI8hB,EAAK9hB,IAAK,CACrD,IAAIqL,EAAW7G,EAAUuG,wBAAwBE,EAAWjL,IAC5DgN,EAAOnO,KAAK4B,IAAIuM,EAAM3B,EAAShH,WAC/B6I,EAAOrO,KAAK0B,IAAI2M,EAAM7B,EAAShH,WAC/B+I,EAAQvO,KAAK4B,IAAI2M,EAAO/B,EAAS/G,UACjCgJ,EAAQzO,KAAK0B,IAAI+M,EAAOjC,EAAS/G,UAEjC,IAAIyd,EACF1W,EAAShH,WAAa,EAClBgH,EAAShH,UACTgH,EAAShH,UAAYT,aAAW2J,OACtCqU,EAAc/iB,KAAK4B,IAAImhB,EAAaG,GACpCF,EAAchjB,KAAK0B,IAAIshB,EAAaE,GAetC,OAZI7U,EAAOF,EAAO6U,EAAcD,IAC9B5U,EAAO4U,GACP1U,EAAO2U,GAEIje,aAAW+U,KACpBzL,GAActJ,aAAW2J,QAEvBP,EAAOpJ,aAAW+U,KACpB3L,GAAcpJ,aAAW2J,SAIxB/O,UAAQJ,IAIbA,EAAO4O,KAAOA,EACd5O,EAAOgP,MAAQA,EACfhP,EAAO8O,KAAOA,EACd9O,EAAOkP,MAAQA,EACRlP,GAPE,IAAI2iB,GAAU/T,EAAMI,EAAOF,EAAMI,IAiB5CyT,GAAU9hB,MAAQ,SAAU6N,EAAW1O,GACrC,GAAKI,UAAQsO,GAIb,OAAKtO,UAAQJ,IASbA,EAAO4O,KAAOF,EAAUE,KACxB5O,EAAOgP,MAAQN,EAAUM,MACzBhP,EAAO8O,KAAOJ,EAAUI,KACxB9O,EAAOkP,MAAQR,EAAUQ,MAClBlP,GAZE,IAAI2iB,GACTjU,EAAUE,KACVF,EAAUM,MACVN,EAAUI,KACVJ,EAAUQ,QAqBhByT,GAAUtd,cAAgB,SAAUvC,EAAMC,EAAOwC,GAG/C,OAFAA,EAAkB1F,eAAa0F,EAAiB,GAG9CzC,IAASC,GACR3C,UAAQ0C,IACP1C,UAAQ2C,IACRtC,KAAKmD,IAAId,EAAK8L,KAAO7L,EAAM6L,OAASrJ,GACpC9E,KAAKmD,IAAId,EAAKkM,MAAQjM,EAAMiM,QAAUzJ,GACtC9E,KAAKmD,IAAId,EAAKgM,KAAO/L,EAAM+L,OAASvJ,GACpC9E,KAAKmD,IAAId,EAAKoM,MAAQnM,EAAMmM,QAAU3J,GAU5Cod,GAAUrb,UAAUzG,MAAQ,SAAUb,GACpC,OAAO2iB,GAAU9hB,MAAMjB,KAAMI,IAU/B2iB,GAAUrb,UAAUpC,OAAS,SAAU2e,GACrC,OAAOlB,GAAUzd,OAAOtF,KAAMikB,IAWhClB,GAAUzd,OAAS,SAAUpC,EAAMC,GACjC,OACED,IAASC,GACR3C,UAAQ0C,IACP1C,UAAQ2C,IACRD,EAAK8L,OAAS7L,EAAM6L,MACpB9L,EAAKkM,QAAUjM,EAAMiM,OACrBlM,EAAKgM,OAAS/L,EAAM+L,MACpBhM,EAAKoM,QAAUnM,EAAMmM,OAa3ByT,GAAUrb,UAAUjC,cAAgB,SAAUwe,EAAOxY,GACnD,OAAOsX,GAAUtd,cAAczF,KAAMikB,EAAOxY,IAa9CsX,GAAUmB,SAAW,SAAUpV,GAE7BzO,QAAMC,OAAOC,OAAO,YAAauO,GAEjC,IAAIQ,EAAQR,EAAUQ,MACtBjP,QAAMC,OAAO4B,OAAOC,oBAClB,QACAmN,GACC1J,aAAWue,aAEd9jB,QAAMC,OAAO4B,OAAO6Q,iBAAiB,QAASzD,EAAO1J,aAAWue,aAEhE,IAAI/U,EAAQN,EAAUM,MACtB/O,QAAMC,OAAO4B,OAAOC,oBAClB,QACAiN,GACCxJ,aAAWue,aAEd9jB,QAAMC,OAAO4B,OAAO6Q,iBAAiB,QAAS3D,EAAOxJ,aAAWue,aAEhE,IAAInV,EAAOF,EAAUE,KACrB3O,QAAMC,OAAO4B,OAAOC,oBAAoB,OAAQ6M,GAAOnO,KAAK8Z,IAC5Dta,QAAMC,OAAO4B,OAAO6Q,iBAAiB,OAAQ/D,EAAMnO,KAAK8Z,IAExD,IAAIzL,EAAOJ,EAAUI,KACrB7O,QAAMC,OAAO4B,OAAOC,oBAAoB,OAAQ+M,GAAOrO,KAAK8Z,IAC5Dta,QAAMC,OAAO4B,OAAO6Q,iBAAiB,OAAQ7D,EAAMrO,KAAK8Z,KAW1DoI,GAAUqB,UAAY,SAAUtV,EAAW1O,GAKzC,OAHAC,QAAMC,OAAOC,OAAO,YAAauO,GAG5BtO,UAAQJ,IAGbA,EAAOiG,UAAYyI,EAAUE,KAC7B5O,EAAOkG,SAAWwI,EAAUM,MAC5BhP,EAAOmG,OAAS,EACTnG,GALE,IAAI0J,EAAagF,EAAUE,KAAMF,EAAUM,QAetD2T,GAAUsB,UAAY,SAAUvV,EAAW1O,GAKzC,OAHAC,QAAMC,OAAOC,OAAO,YAAauO,GAG5BtO,UAAQJ,IAGbA,EAAOiG,UAAYyI,EAAUE,KAC7B5O,EAAOkG,SAAWwI,EAAUQ,MAC5BlP,EAAOmG,OAAS,EACTnG,GALE,IAAI0J,EAAagF,EAAUE,KAAMF,EAAUQ,QAetDyT,GAAUuB,UAAY,SAAUxV,EAAW1O,GAKzC,OAHAC,QAAMC,OAAOC,OAAO,YAAauO,GAG5BtO,UAAQJ,IAGbA,EAAOiG,UAAYyI,EAAUI,KAC7B9O,EAAOkG,SAAWwI,EAAUQ,MAC5BlP,EAAOmG,OAAS,EACTnG,GALE,IAAI0J,EAAagF,EAAUI,KAAMJ,EAAUQ,QAetDyT,GAAUwB,UAAY,SAAUzV,EAAW1O,GAKzC,OAHAC,QAAMC,OAAOC,OAAO,YAAauO,GAG5BtO,UAAQJ,IAGbA,EAAOiG,UAAYyI,EAAUI,KAC7B9O,EAAOkG,SAAWwI,EAAUM,MAC5BhP,EAAOmG,OAAS,EACTnG,GALE,IAAI0J,EAAagF,EAAUI,KAAMJ,EAAUM,QAetD2T,GAAUyB,OAAS,SAAU1V,EAAW1O,GAEtCC,QAAMC,OAAOC,OAAO,YAAauO,GAGjC,IAAII,EAAOJ,EAAUI,KACjBF,EAAOF,EAAUE,KAEjBE,EAAOF,IACTE,GAAQtJ,aAAW2J,QAGrB,IAAIlJ,EAAYT,aAAW6e,eAA+B,IAAfzV,EAAOE,IAC9C5I,EAAiD,IAArCwI,EAAUM,MAAQN,EAAUQ,OAE5C,OAAK9O,UAAQJ,IAIbA,EAAOiG,UAAYA,EACnBjG,EAAOkG,SAAWA,EAClBlG,EAAOmG,OAAS,EACTnG,GANE,IAAI0J,EAAazD,EAAWC,IAqBvCyc,GAAUla,aAAe,SAAUiG,EAAW4V,EAAgBtkB,GAE5DC,QAAMC,OAAOC,OAAO,YAAauO,GACjCzO,QAAMC,OAAOC,OAAO,iBAAkBmkB,GAGtC,IAAIC,EAAgB7V,EAAUI,KAC1B0V,EAAgB9V,EAAUE,KAE1B6V,EAAqBH,EAAexV,KACpC4V,EAAqBJ,EAAe1V,KAEpC2V,EAAgBC,GAAiBC,EAAqB,EACxDF,GAAiB/e,aAAW2J,OACnBsV,EAAqBC,GAAsBH,EAAgB,IACpEE,GAAsBjf,aAAW2J,QAG/BoV,EAAgBC,GAAiBE,EAAqB,EACxDA,GAAsBlf,aAAW2J,OACxBsV,EAAqBC,GAAsBF,EAAgB,IACpEA,GAAiBhf,aAAW2J,QAG9B,IAAIP,EAAOpJ,aAAW6e,eACpB5jB,KAAK0B,IAAIqiB,EAAeE,IAEtB5V,EAAOtJ,aAAW6e,eACpB5jB,KAAK4B,IAAIkiB,EAAeE,IAG1B,MACG/V,EAAUE,KAAOF,EAAUI,MAC1BwV,EAAe1V,KAAO0V,EAAexV,OACvCA,GAAQF,GAHV,CAQA,IAAII,EAAQvO,KAAK0B,IAAIuM,EAAUM,MAAOsV,EAAetV,OACjDE,EAAQzO,KAAK4B,IAAIqM,EAAUQ,MAAOoV,EAAepV,OAErD,KAAIF,GAASE,GAIb,OAAK9O,UAAQJ,IAGbA,EAAO4O,KAAOA,EACd5O,EAAOgP,MAAQA,EACfhP,EAAO8O,KAAOA,EACd9O,EAAOkP,MAAQA,EACRlP,GANE,IAAI2iB,GAAU/T,EAAMI,EAAOF,EAAMI,KAoB5CyT,GAAUgC,mBAAqB,SAAUjW,EAAW4V,EAAgBtkB,GAElEC,QAAMC,OAAOC,OAAO,YAAauO,GACjCzO,QAAMC,OAAOC,OAAO,iBAAkBmkB,GAGtC,IAAI1V,EAAOnO,KAAK0B,IAAIuM,EAAUE,KAAM0V,EAAe1V,MAC/CI,EAAQvO,KAAK0B,IAAIuM,EAAUM,MAAOsV,EAAetV,OACjDF,EAAOrO,KAAK4B,IAAIqM,EAAUI,KAAMwV,EAAexV,MAC/CI,EAAQzO,KAAK4B,IAAIqM,EAAUQ,MAAOoV,EAAepV,OAErD,KAAIF,GAASE,GAASN,GAAQE,GAI9B,OAAK1O,UAAQJ,IAIbA,EAAO4O,KAAOA,EACd5O,EAAOgP,MAAQA,EACfhP,EAAO8O,KAAOA,EACd9O,EAAOkP,MAAQA,EACRlP,GAPE,IAAI2iB,GAAU/T,EAAMI,EAAOF,EAAMI,IAkB5CyT,GAAUiC,MAAQ,SAAUlW,EAAW4V,EAAgBtkB,GAErDC,QAAMC,OAAOC,OAAO,YAAauO,GACjCzO,QAAMC,OAAOC,OAAO,iBAAkBmkB,GAGjClkB,UAAQJ,KACXA,EAAS,IAAI2iB,IAGf,IAAI4B,EAAgB7V,EAAUI,KAC1B0V,EAAgB9V,EAAUE,KAE1B6V,EAAqBH,EAAexV,KACpC4V,EAAqBJ,EAAe1V,KAEpC2V,EAAgBC,GAAiBC,EAAqB,EACxDF,GAAiB/e,aAAW2J,OACnBsV,EAAqBC,GAAsBH,EAAgB,IACpEE,GAAsBjf,aAAW2J,QAG/BoV,EAAgBC,GAAiBE,EAAqB,EACxDA,GAAsBlf,aAAW2J,OACxBsV,EAAqBC,GAAsBF,EAAgB,IACpEA,GAAiBhf,aAAW2J,QAG9B,IAAIP,EAAOpJ,aAAW6e,eACpB5jB,KAAK4B,IAAImiB,EAAeE,IAEtB5V,EAAOtJ,aAAW6e,eACpB5jB,KAAK0B,IAAIoiB,EAAeE,IAQ1B,OALAzkB,EAAO4O,KAAOA,EACd5O,EAAOgP,MAAQvO,KAAK4B,IAAIqM,EAAUM,MAAOsV,EAAetV,OACxDhP,EAAO8O,KAAOA,EACd9O,EAAOkP,MAAQzO,KAAK0B,IAAIuM,EAAUQ,MAAOoV,EAAepV,OAEjDlP,GAWT2iB,GAAUkC,OAAS,SAAUnW,EAAWtD,EAAcpL,GAepD,OAbAC,QAAMC,OAAOC,OAAO,YAAauO,GACjCzO,QAAMC,OAAOC,OAAO,eAAgBiL,GAG/BhL,UAAQJ,KACXA,EAAS,IAAI2iB,IAGf3iB,EAAO4O,KAAOnO,KAAK4B,IAAIqM,EAAUE,KAAMxD,EAAanF,WACpDjG,EAAOgP,MAAQvO,KAAK4B,IAAIqM,EAAUM,MAAO5D,EAAalF,UACtDlG,EAAO8O,KAAOrO,KAAK0B,IAAIuM,EAAUI,KAAM1D,EAAanF,WACpDjG,EAAOkP,MAAQzO,KAAK0B,IAAIuM,EAAUQ,MAAO9D,EAAalF,UAE/ClG,GAUT2iB,GAAUmC,SAAW,SAAUpW,EAAWtD,GAExCnL,QAAMC,OAAOC,OAAO,YAAauO,GACjCzO,QAAMC,OAAOC,OAAO,eAAgBiL,GAGpC,IAAInF,EAAYmF,EAAanF,UACzBC,EAAWkF,EAAalF,SAExB0I,EAAOF,EAAUE,KACjBE,EAAOJ,EAAUI,KAQrB,OANIA,EAAOF,IACTE,GAAQtJ,aAAW2J,OACflJ,EAAY,IACdA,GAAaT,aAAW2J,UAIzBlJ,EAAY2I,GACXpJ,aAAWH,cAAcY,EAAW2I,EAAMpJ,aAAW4G,cACtDnG,EAAY6I,GACXtJ,aAAWH,cAAcY,EAAW6I,EAAMtJ,aAAW4G,aACvDlG,GAAYwI,EAAUM,OACtB9I,GAAYwI,EAAUQ,OAI1B,IAAI6V,GAAsB,IAAIrb,EChyB9B,SAASsb,GAAWvlB,EAAGC,GAMrBE,KAAKH,EAAII,eAAaJ,EAAG,GAOzBG,KAAKF,EAAIG,eAAaH,EAAG,GD+xB3BijB,GAAUsC,UAAY,SAAUvW,EAAWtI,EAAW8e,EAAellB,GAEnEC,QAAMC,OAAOC,OAAO,YAAauO,GAGjCtI,EAAYvG,eAAauG,EAAWwE,EAAUiB,OAC9CqZ,EAAgBrlB,eAAaqlB,EAAe,GAEvC9kB,UAAQJ,KACXA,EAAS,IAEX,IAAIuB,EAAS,EAET2N,EAAQR,EAAUQ,MAClBF,EAAQN,EAAUM,MAClBF,EAAOJ,EAAUI,KACjBF,EAAOF,EAAUE,KAEjBuW,EAAMJ,GACVI,EAAIhf,OAAS+e,EAEbC,EAAIlf,UAAY2I,EAChBuW,EAAIjf,SAAWgJ,EACflP,EAAOuB,GAAU6E,EAAUmG,wBAAwB4Y,EAAKnlB,EAAOuB,IAC/DA,IAEA4jB,EAAIlf,UAAY6I,EAChB9O,EAAOuB,GAAU6E,EAAUmG,wBAAwB4Y,EAAKnlB,EAAOuB,IAC/DA,IAEA4jB,EAAIjf,SAAW8I,EACfhP,EAAOuB,GAAU6E,EAAUmG,wBAAwB4Y,EAAKnlB,EAAOuB,IAC/DA,IAEA4jB,EAAIlf,UAAY2I,EAChB5O,EAAOuB,GAAU6E,EAAUmG,wBAAwB4Y,EAAKnlB,EAAOuB,IAC/DA,IAGE4jB,EAAIjf,SADFgJ,EAAQ,EACKA,EACNF,EAAQ,EACFA,EAEA,EAGjB,IAAK,IAAIpN,EAAI,EAAGA,EAAI,IAAKA,EACvBujB,EAAIlf,WAAaxF,KAAK8Z,GAAK3Y,EAAI4D,aAAWue,YACtCpB,GAAUmC,SAASpW,EAAWyW,KAChCnlB,EAAOuB,GAAU6E,EAAUmG,wBAAwB4Y,EAAKnlB,EAAOuB,IAC/DA,KAaJ,OATqB,IAAjB4jB,EAAIjf,WACNif,EAAIlf,UAAY2I,EAChB5O,EAAOuB,GAAU6E,EAAUmG,wBAAwB4Y,EAAKnlB,EAAOuB,IAC/DA,IACA4jB,EAAIlf,UAAY6I,EAChB9O,EAAOuB,GAAU6E,EAAUmG,wBAAwB4Y,EAAKnlB,EAAOuB,IAC/DA,KAEFvB,EAAOuB,OAASA,EACTvB,GAST2iB,GAAUY,UAAYpc,OAAOC,OAC3B,IAAIub,IACDliB,KAAK8Z,IACL/U,aAAWue,YACZtjB,KAAK8Z,GACL/U,aAAWue,cCj2BfiB,GAAWpkB,aAAe,SAAUnB,EAAGC,EAAGM,GACxC,OAAKI,UAAQJ,IAIbA,EAAOP,EAAIA,EACXO,EAAON,EAAIA,EACJM,GALE,IAAIglB,GAAWvlB,EAAGC,IAe7BslB,GAAWnkB,MAAQ,SAAUC,EAAWd,GACtC,GAAKI,UAAQU,GAGb,OAAKV,UAAQJ,IAIbA,EAAOP,EAAIqB,EAAUrB,EACrBO,EAAON,EAAIoB,EAAUpB,EACdM,GALE,IAAIglB,GAAWlkB,EAAUrB,EAAGqB,EAAUpB,IAiBjDslB,GAAWpZ,eAAiBoZ,GAAWnkB,MAWvCmkB,GAAWjkB,eAAiBikB,GAAWnkB,MAMvCmkB,GAAWhkB,aAAe,EAW1BgkB,GAAW/jB,KAAO,SAAUC,EAAOC,EAAOC,GAWxC,OATAnB,QAAMC,OAAOC,OAAO,QAASe,GAC7BjB,QAAMG,QAAQ,QAASe,GAGvBC,EAAgBvB,eAAauB,EAAe,GAE5CD,EAAMC,KAAmBF,EAAMzB,EAC/B0B,EAAMC,GAAiBF,EAAMxB,EAEtByB,GAWT6jB,GAAW3jB,OAAS,SAAUF,EAAOC,EAAepB,GAYlD,OAVAC,QAAMG,QAAQ,QAASe,GAGvBC,EAAgBvB,eAAauB,EAAe,GAEvChB,UAAQJ,KACXA,EAAS,IAAIglB,IAEfhlB,EAAOP,EAAI0B,EAAMC,KACjBpB,EAAON,EAAIyB,EAAMC,GACVpB,GAWTglB,GAAW1jB,UAAY,SAAUH,EAAOnB,GAEtCC,QAAMG,QAAQ,QAASe,GAGvB,IAAII,EAASJ,EAAMI,OACfC,EAAwB,EAATD,EACnB,GAAKnB,UAAQJ,GAEN,CAAA,IAAKyB,MAAMC,QAAQ1B,IAAWA,EAAOuB,SAAWC,EACrD,MAAM,IAAIG,iBACR,8EAEO3B,EAAOuB,SAAWC,IAC3BxB,EAAOuB,OAASC,QANhBxB,EAAS,IAAIyB,MAAMD,GASrB,IAAK,IAAII,EAAI,EAAGA,EAAIL,IAAUK,EAC5BojB,GAAW/jB,KAAKE,EAAMS,GAAI5B,EAAY,EAAJ4B,GAEpC,OAAO5B,GAUTglB,GAAWnjB,YAAc,SAAUV,EAAOnB,GAIxC,GAFAC,QAAMG,QAAQ,QAASe,GACvBlB,QAAMC,OAAO4B,OAAOC,oBAAoB,eAAgBZ,EAAMI,OAAQ,GAClEJ,EAAMI,OAAS,GAAM,EACvB,MAAM,IAAII,iBAAe,yCAI3B,IAAIJ,EAASJ,EAAMI,OACdnB,UAAQJ,GAGXA,EAAOuB,OAASA,EAAS,EAFzBvB,EAAS,IAAIyB,MAAMF,EAAS,GAK9B,IAAK,IAAIK,EAAI,EAAGA,EAAIL,EAAQK,GAAK,EAAG,CAClC,IAAII,EAAQJ,EAAI,EAChB5B,EAAOgC,GAASgjB,GAAW3jB,OAAOF,EAAOS,EAAG5B,EAAOgC,IAErD,OAAOhC,GAqBTglB,GAAW/iB,UAAY+iB,GAAW3jB,OAQlC2jB,GAAW9iB,iBAAmB,SAAUpB,GAKtC,OAHAb,QAAMC,OAAOC,OAAO,YAAaW,GAG1BL,KAAK0B,IAAIrB,EAAUrB,EAAGqB,EAAUpB,IASzCslB,GAAW5iB,iBAAmB,SAAUtB,GAKtC,OAHAb,QAAMC,OAAOC,OAAO,YAAaW,GAG1BL,KAAK4B,IAAIvB,EAAUrB,EAAGqB,EAAUpB,IAWzCslB,GAAW1iB,mBAAqB,SAAUC,EAAOC,EAAQxC,GAUvD,OARAC,QAAMC,OAAOC,OAAO,QAASoC,GAC7BtC,QAAMC,OAAOC,OAAO,SAAUqC,GAC9BvC,QAAMC,OAAOC,OAAO,SAAUH,GAG9BA,EAAOP,EAAIgB,KAAK4B,IAAIE,EAAM9C,EAAG+C,EAAO/C,GACpCO,EAAON,EAAIe,KAAK4B,IAAIE,EAAM7C,EAAG8C,EAAO9C,GAE7BM,GAWTglB,GAAWviB,mBAAqB,SAAUF,EAAOC,EAAQxC,GASvD,OAPAC,QAAMC,OAAOC,OAAO,QAASoC,GAC7BtC,QAAMC,OAAOC,OAAO,SAAUqC,GAC9BvC,QAAMC,OAAOC,OAAO,SAAUH,GAG9BA,EAAOP,EAAIgB,KAAK0B,IAAII,EAAM9C,EAAG+C,EAAO/C,GACpCO,EAAON,EAAIe,KAAK0B,IAAII,EAAM7C,EAAG8C,EAAO9C,GAC7BM,GASTglB,GAAWtiB,iBAAmB,SAAU5B,GAKtC,OAHAb,QAAMC,OAAOC,OAAO,YAAaW,GAG1BA,EAAUrB,EAAIqB,EAAUrB,EAAIqB,EAAUpB,EAAIoB,EAAUpB,GAS7DslB,GAAWzkB,UAAY,SAAUO,GAC/B,OAAOL,KAAKkC,KAAKqiB,GAAWtiB,iBAAiB5B,KAG/C,IAAI8B,GAAkB,IAAIoiB,GAa1BA,GAAWniB,SAAW,SAAUC,EAAMC,GAOpC,OALA9C,QAAMC,OAAOC,OAAO,OAAQ2C,GAC5B7C,QAAMC,OAAOC,OAAO,QAAS4C,GAG7BiiB,GAAWhiB,SAASF,EAAMC,EAAOH,IAC1BoiB,GAAWzkB,UAAUqC,KAe9BoiB,GAAW/hB,gBAAkB,SAAUH,EAAMC,GAO3C,OALA9C,QAAMC,OAAOC,OAAO,OAAQ2C,GAC5B7C,QAAMC,OAAOC,OAAO,QAAS4C,GAG7BiiB,GAAWhiB,SAASF,EAAMC,EAAOH,IAC1BoiB,GAAWtiB,iBAAiBE,KAUrCoiB,GAAW9hB,UAAY,SAAUpC,EAAWd,GAE1CC,QAAMC,OAAOC,OAAO,YAAaW,GACjCb,QAAMC,OAAOC,OAAO,SAAUH,GAG9B,IAAIO,EAAYykB,GAAWzkB,UAAUO,GAMrC,GAJAd,EAAOP,EAAIqB,EAAUrB,EAAIc,EACzBP,EAAON,EAAIoB,EAAUpB,EAAIa,EAGrB4C,MAAMnD,EAAOP,IAAM0D,MAAMnD,EAAON,GAClC,MAAM,IAAIiC,iBAAe,qCAI3B,OAAO3B,GAUTglB,GAAW5hB,IAAM,SAAUN,EAAMC,GAM/B,OAJA9C,QAAMC,OAAOC,OAAO,OAAQ2C,GAC5B7C,QAAMC,OAAOC,OAAO,QAAS4C,GAGtBD,EAAKrD,EAAIsD,EAAMtD,EAAIqD,EAAKpD,EAAIqD,EAAMrD,GAU3CslB,GAAWzgB,MAAQ,SAAUzB,EAAMC,GAMjC,OAJA9C,QAAMC,OAAOC,OAAO,OAAQ2C,GAC5B7C,QAAMC,OAAOC,OAAO,QAAS4C,GAGtBD,EAAKrD,EAAIsD,EAAMrD,EAAIoD,EAAKpD,EAAIqD,EAAMtD,GAW3CulB,GAAW3hB,mBAAqB,SAAUP,EAAMC,EAAO/C,GASrD,OAPAC,QAAMC,OAAOC,OAAO,OAAQ2C,GAC5B7C,QAAMC,OAAOC,OAAO,QAAS4C,GAC7B9C,QAAMC,OAAOC,OAAO,SAAUH,GAG9BA,EAAOP,EAAIqD,EAAKrD,EAAIsD,EAAMtD,EAC1BO,EAAON,EAAIoD,EAAKpD,EAAIqD,EAAMrD,EACnBM,GAWTglB,GAAW1hB,iBAAmB,SAAUR,EAAMC,EAAO/C,GASnD,OAPAC,QAAMC,OAAOC,OAAO,OAAQ2C,GAC5B7C,QAAMC,OAAOC,OAAO,QAAS4C,GAC7B9C,QAAMC,OAAOC,OAAO,SAAUH,GAG9BA,EAAOP,EAAIqD,EAAKrD,EAAIsD,EAAMtD,EAC1BO,EAAON,EAAIoD,EAAKpD,EAAIqD,EAAMrD,EACnBM,GAWTglB,GAAWzhB,IAAM,SAAUT,EAAMC,EAAO/C,GAStC,OAPAC,QAAMC,OAAOC,OAAO,OAAQ2C,GAC5B7C,QAAMC,OAAOC,OAAO,QAAS4C,GAC7B9C,QAAMC,OAAOC,OAAO,SAAUH,GAG9BA,EAAOP,EAAIqD,EAAKrD,EAAIsD,EAAMtD,EAC1BO,EAAON,EAAIoD,EAAKpD,EAAIqD,EAAMrD,EACnBM,GAWTglB,GAAWhiB,SAAW,SAAUF,EAAMC,EAAO/C,GAS3C,OAPAC,QAAMC,OAAOC,OAAO,OAAQ2C,GAC5B7C,QAAMC,OAAOC,OAAO,QAAS4C,GAC7B9C,QAAMC,OAAOC,OAAO,SAAUH,GAG9BA,EAAOP,EAAIqD,EAAKrD,EAAIsD,EAAMtD,EAC1BO,EAAON,EAAIoD,EAAKpD,EAAIqD,EAAMrD,EACnBM,GAWTglB,GAAWxhB,iBAAmB,SAAU1C,EAAW2C,EAAQzD,GASzD,OAPAC,QAAMC,OAAOC,OAAO,YAAaW,GACjCb,QAAMC,OAAO4B,OAAO,SAAU2B,GAC9BxD,QAAMC,OAAOC,OAAO,SAAUH,GAG9BA,EAAOP,EAAIqB,EAAUrB,EAAIgE,EACzBzD,EAAON,EAAIoB,EAAUpB,EAAI+D,EAClBzD,GAWTglB,GAAWthB,eAAiB,SAAU5C,EAAW2C,EAAQzD,GASvD,OAPAC,QAAMC,OAAOC,OAAO,YAAaW,GACjCb,QAAMC,OAAO4B,OAAO,SAAU2B,GAC9BxD,QAAMC,OAAOC,OAAO,SAAUH,GAG9BA,EAAOP,EAAIqB,EAAUrB,EAAIgE,EACzBzD,EAAON,EAAIoB,EAAUpB,EAAI+D,EAClBzD,GAUTglB,GAAWrhB,OAAS,SAAU7C,EAAWd,GAQvC,OANAC,QAAMC,OAAOC,OAAO,YAAaW,GACjCb,QAAMC,OAAOC,OAAO,SAAUH,GAG9BA,EAAOP,GAAKqB,EAAUrB,EACtBO,EAAON,GAAKoB,EAAUpB,EACfM,GAUTglB,GAAWphB,IAAM,SAAU9C,EAAWd,GAQpC,OANAC,QAAMC,OAAOC,OAAO,YAAaW,GACjCb,QAAMC,OAAOC,OAAO,SAAUH,GAG9BA,EAAOP,EAAIgB,KAAKmD,IAAI9C,EAAUrB,GAC9BO,EAAON,EAAIe,KAAKmD,IAAI9C,EAAUpB,GACvBM,GAGT,IAAI6D,GAAc,IAAImhB,GAUtBA,GAAWlhB,KAAO,SAAUC,EAAOC,EAAKC,EAAGjE,GAUzC,OARAC,QAAMC,OAAOC,OAAO,QAAS4D,GAC7B9D,QAAMC,OAAOC,OAAO,MAAO6D,GAC3B/D,QAAMC,OAAO4B,OAAO,IAAKmC,GACzBhE,QAAMC,OAAOC,OAAO,SAAUH,GAG9BglB,GAAWxhB,iBAAiBQ,EAAKC,EAAGJ,IACpC7D,EAASglB,GAAWxhB,iBAAiBO,EAAO,EAAME,EAAGjE,GAC9CglB,GAAWzhB,IAAIM,GAAa7D,EAAQA,IAG7C,IAAIkE,GAAsB,IAAI8gB,GAC1B7gB,GAAuB,IAAI6gB,GAQ/BA,GAAW5gB,aAAe,SAAUtB,EAAMC,GAQxC,OANA9C,QAAMC,OAAOC,OAAO,OAAQ2C,GAC5B7C,QAAMC,OAAOC,OAAO,QAAS4C,GAG7BiiB,GAAW9hB,UAAUJ,EAAMoB,IAC3B8gB,GAAW9hB,UAAUH,EAAOoB,IACrBqB,aAAW4f,YAChBJ,GAAW5hB,IAAIc,GAAqBC,MAIxC,IAAIM,GAA4B,IAAIugB,GCzlBpC,SAASK,GAAQrX,EAAaC,EAAaE,EAAaC,GACtDxO,KAAK,GAAKC,eAAamO,EAAa,GACpCpO,KAAK,GAAKC,eAAasO,EAAa,GACpCvO,KAAK,GAAKC,eAAaoO,EAAa,GACpCrO,KAAK,GAAKC,eAAauO,EAAa,GD6lBtC4W,GAAWtgB,mBAAqB,SAAU5D,EAAWd,GAEnDC,QAAMC,OAAOC,OAAO,YAAaW,GACjCb,QAAMC,OAAOC,OAAO,SAAUH,GAG9B,IAAI2E,EAAIqgB,GAAW9hB,UAAUpC,EAAW2D,IASxC,OARAugB,GAAWphB,IAAIe,EAAGA,GAGhB3E,EADE2E,EAAElF,GAAKkF,EAAEjF,EACFslB,GAAWnkB,MAAMmkB,GAAWpgB,OAAQ5E,GAEpCglB,GAAWnkB,MAAMmkB,GAAWlgB,OAAQ9E,IAcjDglB,GAAW9f,OAAS,SAAUpC,EAAMC,GAClC,OACED,IAASC,GACR3C,UAAQ0C,IACP1C,UAAQ2C,IACRD,EAAKrD,IAAMsD,EAAMtD,GACjBqD,EAAKpD,IAAMqD,EAAMrD,GAOvBslB,GAAW7f,YAAc,SAAUrE,EAAWK,EAAOiE,GACnD,OAAOtE,EAAUrB,IAAM0B,EAAMiE,IAAWtE,EAAUpB,IAAMyB,EAAMiE,EAAS,IAczE4f,GAAW3f,cAAgB,SACzBvC,EACAC,EACAuC,EACAC,GAEA,OACEzC,IAASC,GACR3C,UAAQ0C,IACP1C,UAAQ2C,IACRyC,aAAWH,cACTvC,EAAKrD,EACLsD,EAAMtD,EACN6F,EACAC,IAEFC,aAAWH,cACTvC,EAAKpD,EACLqD,EAAMrD,EACN4F,EACAC,IAWRyf,GAAW9d,KAAOC,OAAOC,OAAO,IAAI4d,GAAW,EAAK,IAQpDA,GAAW3d,IAAMF,OAAOC,OAAO,IAAI4d,GAAW,EAAK,IAQnDA,GAAWpgB,OAASuC,OAAOC,OAAO,IAAI4d,GAAW,EAAK,IAQtDA,GAAWlgB,OAASqC,OAAOC,OAAO,IAAI4d,GAAW,EAAK,IAQtDA,GAAW1d,UAAUzG,MAAQ,SAAUb,GACrC,OAAOglB,GAAWnkB,MAAMjB,KAAMI,IAUhCglB,GAAW1d,UAAUpC,OAAS,SAAUnC,GACtC,OAAOiiB,GAAW9f,OAAOtF,KAAMmD,IAajCiiB,GAAW1d,UAAUjC,cAAgB,SACnCtC,EACAuC,EACAC,GAEA,OAAOyf,GAAW3f,cAChBzF,KACAmD,EACAuC,EACAC,IASJyf,GAAW1d,UAAUC,SAAW,WAC9B,MAAO,IAAM3H,KAAKH,EAAI,KAAOG,KAAKF,EAAI,KCvvBxC2lB,GAAQrkB,aAAe,EAWvBqkB,GAAQpkB,KAAO,SAAUC,EAAOC,EAAOC,GAarC,OAXAnB,QAAMC,OAAOC,OAAO,QAASe,GAC7BjB,QAAMG,QAAQ,QAASe,GAGvBC,EAAgBvB,eAAauB,EAAe,GAE5CD,EAAMC,KAAmBF,EAAM,GAC/BC,EAAMC,KAAmBF,EAAM,GAC/BC,EAAMC,KAAmBF,EAAM,GAC/BC,EAAMC,KAAmBF,EAAM,GAExBC,GAWTkkB,GAAQhkB,OAAS,SAAUF,EAAOC,EAAepB,GAe/C,OAbAC,QAAMG,QAAQ,QAASe,GAGvBC,EAAgBvB,eAAauB,EAAe,GAEvChB,UAAQJ,KACXA,EAAS,IAAIqlB,IAGfrlB,EAAO,GAAKmB,EAAMC,KAClBpB,EAAO,GAAKmB,EAAMC,KAClBpB,EAAO,GAAKmB,EAAMC,KAClBpB,EAAO,GAAKmB,EAAMC,KACXpB,GAUTqlB,GAAQxkB,MAAQ,SAAUiP,EAAQ9P,GAChC,GAAKI,UAAQ0P,GAGb,OAAK1P,UAAQJ,IAGbA,EAAO,GAAK8P,EAAO,GACnB9P,EAAO,GAAK8P,EAAO,GACnB9P,EAAO,GAAK8P,EAAO,GACnB9P,EAAO,GAAK8P,EAAO,GACZ9P,GANE,IAAIqlB,GAAQvV,EAAO,GAAIA,EAAO,GAAIA,EAAO,GAAIA,EAAO,KA6B/DuV,GAAQpjB,UAAY,SAAUd,EAAOC,EAAepB,GAelD,OAbAC,QAAMG,QAAQ,QAASe,GAGvBC,EAAgBvB,eAAauB,EAAe,GAEvChB,UAAQJ,KACXA,EAAS,IAAIqlB,IAGfrlB,EAAO,GAAKmB,EAAMC,GAClBpB,EAAO,GAAKmB,EAAMC,EAAgB,GAClCpB,EAAO,GAAKmB,EAAMC,EAAgB,GAClCpB,EAAO,GAAKmB,EAAMC,EAAgB,GAC3BpB,GAUTqlB,GAAQtV,qBAAuB,SAAUC,EAAQhQ,GAK/C,OAHAC,QAAMG,QAAQ,SAAU4P,GAGjBqV,GAAQxkB,MAAMmP,EAAQhQ,IAW/BqlB,GAAQpV,kBAAoB,SAAUD,EAAQhQ,GAK5C,OAHAC,QAAMG,QAAQ,SAAU4P,GAGnB5P,UAAQJ,IAGbA,EAAO,GAAKgQ,EAAO,GACnBhQ,EAAO,GAAKgQ,EAAO,GACnBhQ,EAAO,GAAKgQ,EAAO,GACnBhQ,EAAO,GAAKgQ,EAAO,GACZhQ,GANE,IAAIqlB,GAAQrV,EAAO,GAAIA,EAAO,GAAIA,EAAO,GAAIA,EAAO,KAsB/DqV,GAAQzT,UAAY,SAAUC,EAAO7R,GAKnC,OAHAC,QAAMC,OAAOC,OAAO,QAAS0R,GAGxBzR,UAAQJ,IAIbA,EAAO,GAAK6R,EAAMpS,EAClBO,EAAO,GAAK,EACZA,EAAO,GAAK,EACZA,EAAO,GAAK6R,EAAMnS,EACXM,GAPE,IAAIqlB,GAAQxT,EAAMpS,EAAG,EAAK,EAAKoS,EAAMnS,IAuBhD2lB,GAAQvT,iBAAmB,SAAUD,EAAO7R,GAK1C,OAHAC,QAAMC,OAAO4B,OAAO,QAAS+P,GAGxBzR,UAAQJ,IAIbA,EAAO,GAAK6R,EACZ7R,EAAO,GAAK,EACZA,EAAO,GAAK,EACZA,EAAO,GAAK6R,EACL7R,GAPE,IAAIqlB,GAAQxT,EAAO,EAAK,EAAKA,IAuBxCwT,GAAQC,aAAe,SAAUpT,EAAOlS,GAEtCC,QAAMC,OAAO4B,OAAO,QAASoQ,GAG7B,IAAIC,EAAW1R,KAAKE,IAAIuR,GACpBE,EAAW3R,KAAKC,IAAIwR,GAExB,OAAK9R,UAAQJ,IAGbA,EAAO,GAAKmS,EACZnS,EAAO,GAAKoS,EACZpS,EAAO,IAAMoS,EACbpS,EAAO,GAAKmS,EACLnS,GANE,IAAIqlB,GAAQlT,GAAWC,EAAUA,EAAUD,IAiBtDkT,GAAQ9S,QAAU,SAAUzC,EAAQ9P,GAKlC,OAHAC,QAAMC,OAAOC,OAAO,SAAU2P,GAGzB1P,UAAQJ,IAGbA,EAAO,GAAK8P,EAAO,GACnB9P,EAAO,GAAK8P,EAAO,GACnB9P,EAAO,GAAK8P,EAAO,GACnB9P,EAAO,GAAK8P,EAAO,GACZ9P,GANE,CAAC8P,EAAO,GAAIA,EAAO,GAAIA,EAAO,GAAIA,EAAO,KAyBpDuV,GAAQ7S,gBAAkB,SAAUC,EAAQC,GAS1C,OAPAzS,QAAMC,OAAO4B,OAAOC,oBAAoB,MAAO2Q,EAAK,GACpDzS,QAAMC,OAAO4B,OAAO6Q,iBAAiB,MAAOD,EAAK,GAEjDzS,QAAMC,OAAO4B,OAAOC,oBAAoB,SAAU0Q,EAAQ,GAC1DxS,QAAMC,OAAO4B,OAAO6Q,iBAAiB,SAAUF,EAAQ,GAGvC,EAATA,EAAaC,GAatB2S,GAAQzS,UAAY,SAAU9C,EAAQ9N,EAAOhC,GAE3CC,QAAMC,OAAOC,OAAO,SAAU2P,GAE9B7P,QAAMC,OAAO4B,OAAOC,oBAAoB,QAASC,EAAO,GACxD/B,QAAMC,OAAO4B,OAAO6Q,iBAAiB,QAAS3Q,EAAO,GAErD/B,QAAMC,OAAOC,OAAO,SAAUH,GAG9B,IAAI6S,EAAqB,EAAR7Q,EACbvC,EAAIqQ,EAAO+C,GACXnT,EAAIoQ,EAAO+C,EAAa,GAI5B,OAFA7S,EAAOP,EAAIA,EACXO,EAAON,EAAIA,EACJM,GAcTqlB,GAAQvS,UAAY,SAAUhD,EAAQ9N,EAAOlB,EAAWd,GAEtDC,QAAMC,OAAOC,OAAO,SAAU2P,GAE9B7P,QAAMC,OAAO4B,OAAOC,oBAAoB,QAASC,EAAO,GACxD/B,QAAMC,OAAO4B,OAAO6Q,iBAAiB,QAAS3Q,EAAO,GAErD/B,QAAMC,OAAOC,OAAO,YAAaW,GACjCb,QAAMC,OAAOC,OAAO,SAAUH,GAI9B,IAAI6S,EAAqB,EAAR7Q,EAGjB,OAJAhC,EAASqlB,GAAQxkB,MAAMiP,EAAQ9P,IAExB6S,GAAc/R,EAAUrB,EAC/BO,EAAO6S,EAAa,GAAK/R,EAAUpB,EAC5BM,GAaTqlB,GAAQtS,OAAS,SAAUjD,EAAQ9N,EAAOhC,GAExCC,QAAMC,OAAOC,OAAO,SAAU2P,GAE9B7P,QAAMC,OAAO4B,OAAOC,oBAAoB,QAASC,EAAO,GACxD/B,QAAMC,OAAO4B,OAAO6Q,iBAAiB,QAAS3Q,EAAO,GAErD/B,QAAMC,OAAOC,OAAO,SAAUH,GAG9B,IAAIP,EAAIqQ,EAAO9N,GACXtC,EAAIoQ,EAAO9N,EAAQ,GAIvB,OAFAhC,EAAOP,EAAIA,EACXO,EAAON,EAAIA,EACJM,GAcTqlB,GAAQrS,OAAS,SAAUlD,EAAQ9N,EAAOlB,EAAWd,GAcnD,OAZAC,QAAMC,OAAOC,OAAO,SAAU2P,GAE9B7P,QAAMC,OAAO4B,OAAOC,oBAAoB,QAASC,EAAO,GACxD/B,QAAMC,OAAO4B,OAAO6Q,iBAAiB,QAAS3Q,EAAO,GAErD/B,QAAMC,OAAOC,OAAO,YAAaW,GACjCb,QAAMC,OAAOC,OAAO,SAAUH,IAG9BA,EAASqlB,GAAQxkB,MAAMiP,EAAQ9P,IACxBgC,GAASlB,EAAUrB,EAC1BO,EAAOgC,EAAQ,GAAKlB,EAAUpB,EACvBM,GAGT,IAAIiT,GAAgB,IAAI+R,GASxBK,GAAQnS,SAAW,SAAUpD,EAAQ9P,GAYnC,OAVAC,QAAMC,OAAOC,OAAO,SAAU2P,GAC9B7P,QAAMC,OAAOC,OAAO,SAAUH,GAG9BA,EAAOP,EAAIulB,GAAWzkB,UACpBykB,GAAWpkB,aAAakP,EAAO,GAAIA,EAAO,GAAImD,KAEhDjT,EAAON,EAAIslB,GAAWzkB,UACpBykB,GAAWpkB,aAAakP,EAAO,GAAIA,EAAO,GAAImD,KAEzCjT,GAGT,IAAImT,GAAe,IAAI6R,GASvBK,GAAQjS,gBAAkB,SAAUtD,GAElC,OADAuV,GAAQnS,SAASpD,EAAQqD,IAClB6R,GAAW9iB,iBAAiBiR,KAWrCkS,GAAQhS,SAAW,SAAUvQ,EAAMC,EAAO/C,GAExCC,QAAMC,OAAOC,OAAO,OAAQ2C,GAC5B7C,QAAMC,OAAOC,OAAO,QAAS4C,GAC7B9C,QAAMC,OAAOC,OAAO,SAAUH,GAG9B,IAAIgO,EAAclL,EAAK,GAAKC,EAAM,GAAKD,EAAK,GAAKC,EAAM,GACnDkL,EAAcnL,EAAK,GAAKC,EAAM,GAAKD,EAAK,GAAKC,EAAM,GACnDoL,EAAcrL,EAAK,GAAKC,EAAM,GAAKD,EAAK,GAAKC,EAAM,GACnDqL,EAActL,EAAK,GAAKC,EAAM,GAAKD,EAAK,GAAKC,EAAM,GAMvD,OAJA/C,EAAO,GAAKgO,EACZhO,EAAO,GAAKmO,EACZnO,EAAO,GAAKiO,EACZjO,EAAO,GAAKoO,EACLpO,GAWTqlB,GAAQ9hB,IAAM,SAAUT,EAAMC,EAAO/C,GAWnC,OATAC,QAAMC,OAAOC,OAAO,OAAQ2C,GAC5B7C,QAAMC,OAAOC,OAAO,QAAS4C,GAC7B9C,QAAMC,OAAOC,OAAO,SAAUH,GAG9BA,EAAO,GAAK8C,EAAK,GAAKC,EAAM,GAC5B/C,EAAO,GAAK8C,EAAK,GAAKC,EAAM,GAC5B/C,EAAO,GAAK8C,EAAK,GAAKC,EAAM,GAC5B/C,EAAO,GAAK8C,EAAK,GAAKC,EAAM,GACrB/C,GAWTqlB,GAAQriB,SAAW,SAAUF,EAAMC,EAAO/C,GAWxC,OATAC,QAAMC,OAAOC,OAAO,OAAQ2C,GAC5B7C,QAAMC,OAAOC,OAAO,QAAS4C,GAC7B9C,QAAMC,OAAOC,OAAO,SAAUH,GAG9BA,EAAO,GAAK8C,EAAK,GAAKC,EAAM,GAC5B/C,EAAO,GAAK8C,EAAK,GAAKC,EAAM,GAC5B/C,EAAO,GAAK8C,EAAK,GAAKC,EAAM,GAC5B/C,EAAO,GAAK8C,EAAK,GAAKC,EAAM,GACrB/C,GAWTqlB,GAAQ/R,iBAAmB,SAAUxD,EAAQhP,EAAWd,GAEtDC,QAAMC,OAAOC,OAAO,SAAU2P,GAC9B7P,QAAMC,OAAOC,OAAO,YAAaW,GACjCb,QAAMC,OAAOC,OAAO,SAAUH,GAG9B,IAAIP,EAAIqQ,EAAO,GAAKhP,EAAUrB,EAAIqQ,EAAO,GAAKhP,EAAUpB,EACpDA,EAAIoQ,EAAO,GAAKhP,EAAUrB,EAAIqQ,EAAO,GAAKhP,EAAUpB,EAIxD,OAFAM,EAAOP,EAAIA,EACXO,EAAON,EAAIA,EACJM,GAWTqlB,GAAQ7hB,iBAAmB,SAAUsM,EAAQrM,EAAQzD,GAWnD,OATAC,QAAMC,OAAOC,OAAO,SAAU2P,GAC9B7P,QAAMC,OAAO4B,OAAO,SAAU2B,GAC9BxD,QAAMC,OAAOC,OAAO,SAAUH,GAG9BA,EAAO,GAAK8P,EAAO,GAAKrM,EACxBzD,EAAO,GAAK8P,EAAO,GAAKrM,EACxBzD,EAAO,GAAK8P,EAAO,GAAKrM,EACxBzD,EAAO,GAAK8P,EAAO,GAAKrM,EACjBzD,GAmBTqlB,GAAQ3R,gBAAkB,SAAU5D,EAAQ+B,EAAO7R,GAWjD,OATAC,QAAMC,OAAOC,OAAO,SAAU2P,GAC9B7P,QAAMC,OAAOC,OAAO,QAAS0R,GAC7B5R,QAAMC,OAAOC,OAAO,SAAUH,GAG9BA,EAAO,GAAK8P,EAAO,GAAK+B,EAAMpS,EAC9BO,EAAO,GAAK8P,EAAO,GAAK+B,EAAMpS,EAC9BO,EAAO,GAAK8P,EAAO,GAAK+B,EAAMnS,EAC9BM,EAAO,GAAK8P,EAAO,GAAK+B,EAAMnS,EACvBM,GAUTqlB,GAAQ1hB,OAAS,SAAUmM,EAAQ9P,GAUjC,OARAC,QAAMC,OAAOC,OAAO,SAAU2P,GAC9B7P,QAAMC,OAAOC,OAAO,SAAUH,GAG9BA,EAAO,IAAM8P,EAAO,GACpB9P,EAAO,IAAM8P,EAAO,GACpB9P,EAAO,IAAM8P,EAAO,GACpB9P,EAAO,IAAM8P,EAAO,GACb9P,GAUTqlB,GAAQ1R,UAAY,SAAU7D,EAAQ9P,GAEpCC,QAAMC,OAAOC,OAAO,SAAU2P,GAC9B7P,QAAMC,OAAOC,OAAO,SAAUH,GAG9B,IAAIgO,EAAc8B,EAAO,GACrB3B,EAAc2B,EAAO,GACrB7B,EAAc6B,EAAO,GACrB1B,EAAc0B,EAAO,GAMzB,OAJA9P,EAAO,GAAKgO,EACZhO,EAAO,GAAKmO,EACZnO,EAAO,GAAKiO,EACZjO,EAAO,GAAKoO,EACLpO,GAUTqlB,GAAQzhB,IAAM,SAAUkM,EAAQ9P,GAW9B,OATAC,QAAMC,OAAOC,OAAO,SAAU2P,GAC9B7P,QAAMC,OAAOC,OAAO,SAAUH,GAG9BA,EAAO,GAAKS,KAAKmD,IAAIkM,EAAO,IAC5B9P,EAAO,GAAKS,KAAKmD,IAAIkM,EAAO,IAC5B9P,EAAO,GAAKS,KAAKmD,IAAIkM,EAAO,IAC5B9P,EAAO,GAAKS,KAAKmD,IAAIkM,EAAO,IAErB9P,GAWTqlB,GAAQngB,OAAS,SAAUpC,EAAMC,GAC/B,OACED,IAASC,GACR3C,UAAQ0C,IACP1C,UAAQ2C,IACRD,EAAK,KAAOC,EAAM,IAClBD,EAAK,KAAOC,EAAM,IAClBD,EAAK,KAAOC,EAAM,IAClBD,EAAK,KAAOC,EAAM,IAOxBsiB,GAAQlgB,YAAc,SAAU2K,EAAQ3O,EAAOiE,GAC7C,OACE0K,EAAO,KAAO3O,EAAMiE,IACpB0K,EAAO,KAAO3O,EAAMiE,EAAS,IAC7B0K,EAAO,KAAO3O,EAAMiE,EAAS,IAC7B0K,EAAO,KAAO3O,EAAMiE,EAAS,IAcjCigB,GAAQhgB,cAAgB,SAAUvC,EAAMC,EAAOsI,GAE7C,OADAA,EAAUxL,eAAawL,EAAS,GAE9BvI,IAASC,GACR3C,UAAQ0C,IACP1C,UAAQ2C,IACRtC,KAAKmD,IAAId,EAAK,GAAKC,EAAM,KAAOsI,GAChC5K,KAAKmD,IAAId,EAAK,GAAKC,EAAM,KAAOsI,GAChC5K,KAAKmD,IAAId,EAAK,GAAKC,EAAM,KAAOsI,GAChC5K,KAAKmD,IAAId,EAAK,GAAKC,EAAM,KAAOsI,GAUtCga,GAAQzQ,SAAWzN,OAAOC,OAAO,IAAIie,GAAQ,EAAK,EAAK,EAAK,IAQ5DA,GAAQne,KAAOC,OAAOC,OAAO,IAAIie,GAAQ,EAAK,EAAK,EAAK,IAYxDA,GAAQnP,YAAc,EAYtBmP,GAAQlP,YAAc,EAYtBkP,GAAQhP,YAAc,EAYtBgP,GAAQ/O,YAAc,EAEtBnP,OAAOmE,iBAAiB+Z,GAAQ/d,UAAW,CAOzC/F,OAAQ,CACNiK,IAAK,WACH,OAAO6Z,GAAQrkB,iBAWrBqkB,GAAQ/d,UAAUzG,MAAQ,SAAUb,GAClC,OAAOqlB,GAAQxkB,MAAMjB,KAAMI,IAU7BqlB,GAAQ/d,UAAUpC,OAAS,SAAUnC,GACnC,OAAOsiB,GAAQngB,OAAOtF,KAAMmD,IAY9BsiB,GAAQ/d,UAAUjC,cAAgB,SAAUtC,EAAOsI,GACjD,OAAOga,GAAQhgB,cAAczF,KAAMmD,EAAOsI,IAS5Cga,GAAQ/d,UAAUC,SAAW,WAC3B,MACE,IACA3H,KAAK,GACL,KACAA,KAAK,GAHL,OAMAA,KAAK,GACL,KACAA,KAAK,GACL"}